var jh = Object.defineProperty; var zh = (e, t, i) => t in e ? jh(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i; var Lt = (e, t, i) => (zh(e, typeof t != "symbol" ? t + "" : t, i), i); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const n of document.querySelectorAll('link[rel="modulepreload"]')) r(n); new MutationObserver(n => { for (const s of n) if (s.type === "childList") for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a) }).observe(document, { childList: !0, subtree: !0 }); function i(n) { const s = {}; return n.integrity && (s.integrity = n.integrity), n.referrerPolicy && (s.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? s.credentials = "include" : n.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(n) { if (n.ep) return; n.ep = !0; const s = i(n); fetch(n.href, s) } })(); function fn(e, t) { const i = Object.create(null), r = e.split(","); for (let n = 0; n < r.length; n++)i[r[n]] = !0; return t ? n => !!i[n.toLowerCase()] : n => !!i[n] } const Yh = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt", Vh = fn(Yh); function gr(e) { if (J(e)) { const t = {}; for (let i = 0; i < e.length; i++) { const r = e[i], n = bt(r) ? qh(r) : gr(r); if (n) for (const s in n) t[s] = n[s] } return t } else { if (bt(e)) return e; if (vt(e)) return e } } const Kh = /;(?![^(]*\))/g, Xh = /:([^]+)/, $h = /\/\*.*?\*\//gs; function qh(e) { const t = {}; return e.replace($h, "").split(Kh).forEach(i => { if (i) { const r = i.split(Xh); r.length > 1 && (t[r[0].trim()] = r[1].trim()) } }), t } function pr(e) { let t = ""; if (bt(e)) t = e; else if (J(e)) for (let i = 0; i < e.length; i++) { const r = pr(e[i]); r && (t += r + " ") } else if (vt(e)) for (const i in e) e[i] && (t += i + " "); return t.trim() } function Jh(e) { if (!e) return null; let { class: t, style: i } = e; return t && !bt(t) && (e.class = pr(t)), i && (e.style = gr(i)), e } const Qh = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Zh = fn(Qh); function xo(e) { return !!e || e === "" } function tc(e, t) { if (e.length !== t.length) return !1; let i = !0; for (let r = 0; i && r < e.length; r++)i = Le(e[r], t[r]); return i } function Le(e, t) { if (e === t) return !0; let i = va(e), r = va(t); if (i || r) return i && r ? e.getTime() === t.getTime() : !1; if (i = ar(e), r = ar(t), i || r) return e === t; if (i = J(e), r = J(t), i || r) return i && r ? tc(e, t) : !1; if (i = vt(e), r = vt(t), i || r) { if (!i || !r) return !1; const n = Object.keys(e).length, s = Object.keys(t).length; if (n !== s) return !1; for (const a in e) { const o = e.hasOwnProperty(a), l = t.hasOwnProperty(a); if (o && !l || !o && l || !Le(e[a], t[a])) return !1 } } return String(e) === String(t) } function un(e, t) { return e.findIndex(i => Le(i, t)) } const ec = e => bt(e) ? e : e == null ? "" : J(e) || vt(e) && (e.toString === To || !it(e.toString)) ? JSON.stringify(e, Eo, 2) : String(e), Eo = (e, t) => t && t.__v_isRef ? Eo(e, t.value) : _i(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((i, [r, n]) => (i[`${r} =>`] = n, i), {}) } : ni(t) ? { [`Set(${t.size})`]: [...t.values()] } : vt(t) && !J(t) && !Po(t) ? String(t) : t, pt = {}, mi = [], se = () => { }, ic = () => !1, rc = /^on[^a-z]/, vr = e => rc.test(e), Ts = e => e.startsWith("onUpdate:"), Tt = Object.assign, Ps = (e, t) => { const i = e.indexOf(t); i > -1 && e.splice(i, 1) }, nc = Object.prototype.hasOwnProperty, ht = (e, t) => nc.call(e, t), J = Array.isArray, _i = e => ki(e) === "[object Map]", ni = e => ki(e) === "[object Set]", va = e => ki(e) === "[object Date]", sc = e => ki(e) === "[object RegExp]", it = e => typeof e == "function", bt = e => typeof e == "string", ar = e => typeof e == "symbol", vt = e => e !== null && typeof e == "object", As = e => vt(e) && it(e.then) && it(e.catch), To = Object.prototype.toString, ki = e => To.call(e), ac = e => ki(e).slice(8, -1), Po = e => ki(e) === "[object Object]", ks = e => bt(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, $i = fn(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), dn = e => { const t = Object.create(null); return i => t[i] || (t[i] = e(i)) }, oc = /-(\w)/g, zt = dn(e => e.replace(oc, (t, i) => i ? i.toUpperCase() : "")), lc = /\B([A-Z])/g, Zt = dn(e => e.replace(lc, "-$1").toLowerCase()), mr = dn(e => e.charAt(0).toUpperCase() + e.slice(1)), qi = dn(e => e ? `on${mr(e)}` : ""), xi = (e, t) => !Object.is(e, t), yi = (e, t) => { for (let i = 0; i < e.length; i++)e[i](t) }, tn = (e, t, i) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: i }) }, en = e => { const t = parseFloat(e); return isNaN(t) ? e : t }, rn = e => { const t = bt(e) ? Number(e) : NaN; return isNaN(t) ? e : t }; let ma; const hc = () => ma || (ma = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); let Kt; class Ms { constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Kt, !t && Kt && (this.index = (Kt.scopes || (Kt.scopes = [])).push(this) - 1) } get active() { return this._active } run(t) { if (this._active) { const i = Kt; try { return Kt = this, t() } finally { Kt = i } } } on() { Kt = this } off() { Kt = this.parent } stop(t) { if (this._active) { let i, r; for (i = 0, r = this.effects.length; i < r; i++)this.effects[i].stop(); for (i = 0, r = this.cleanups.length; i < r; i++)this.cleanups[i](); if (this.scopes) for (i = 0, r = this.scopes.length; i < r; i++)this.scopes[i].stop(!0); if (!this.detached && this.parent && !t) { const n = this.parent.scopes.pop(); n && n !== this && (this.parent.scopes[this.index] = n, n.index = this.index) } this.parent = void 0, this._active = !1 } } } function cc(e) { return new Ms(e) } function Ao(e, t = Kt) { t && t.active && t.effects.push(e) } function ko() { return Kt } function fc(e) { Kt && Kt.cleanups.push(e) } const Rs = e => { const t = new Set(e); return t.w = 0, t.n = 0, t }, Mo = e => (e.w & Ie) > 0, Ro = e => (e.n & Ie) > 0, uc = ({ deps: e }) => { if (e.length) for (let t = 0; t < e.length; t++)e[t].w |= Ie }, dc = e => { const { deps: t } = e; if (t.length) { let i = 0; for (let r = 0; r < t.length; r++) { const n = t[r]; Mo(n) && !Ro(n) ? n.delete(e) : t[i++] = n, n.w &= ~Ie, n.n &= ~Ie } t.length = i } }, nn = new WeakMap; let ji = 0, Ie = 1; const Qn = 30; let re; const qe = Symbol(""), Zn = Symbol(""); class _r { constructor(t, i = null, r) { this.fn = t, this.scheduler = i, this.active = !0, this.deps = [], this.parent = void 0, Ao(this, r) } run() { if (!this.active) return this.fn(); let t = re, i = Re; for (; t;) { if (t === this) return; t = t.parent } try { return this.parent = re, re = this, Re = !0, Ie = 1 << ++ji, ji <= Qn ? uc(this) : _a(this), this.fn() } finally { ji <= Qn && dc(this), Ie = 1 << --ji, re = this.parent, Re = i, this.parent = void 0, this.deferStop && this.stop() } } stop() { re === this ? this.deferStop = !0 : this.active && (_a(this), this.onStop && this.onStop(), this.active = !1) } } function _a(e) { const { deps: t } = e; if (t.length) { for (let i = 0; i < t.length; i++)t[i].delete(e); t.length = 0 } } function gc(e, t) { e.effect && (e = e.effect.fn); const i = new _r(e); t && (Tt(i, t), t.scope && Ao(i, t.scope)), (!t || !t.lazy) && i.run(); const r = i.run.bind(i); return r.effect = i, r } function pc(e) { e.effect.stop() } let Re = !0; const Oo = []; function Mi() { Oo.push(Re), Re = !1 } function Ri() { const e = Oo.pop(); Re = e === void 0 ? !0 : e } function Yt(e, t, i) { if (Re && re) { let r = nn.get(e); r || nn.set(e, r = new Map); let n = r.get(i); n || r.set(i, n = Rs()), Lo(n) } } function Lo(e, t) { let i = !1; ji <= Qn ? Ro(e) || (e.n |= Ie, i = !Mo(e)) : i = !e.has(re), i && (e.add(re), re.deps.push(e)) } function be(e, t, i, r, n, s) { const a = nn.get(e); if (!a) return; let o = []; if (t === "clear") o = [...a.values()]; else if (i === "length" && J(e)) { const l = Number(r); a.forEach((h, c) => { (c === "length" || c >= l) && o.push(h) }) } else switch (i !== void 0 && o.push(a.get(i)), t) { case "add": J(e) ? ks(i) && o.push(a.get("length")) : (o.push(a.get(qe)), _i(e) && o.push(a.get(Zn))); break; case "delete": J(e) || (o.push(a.get(qe)), _i(e) && o.push(a.get(Zn))); break; case "set": _i(e) && o.push(a.get(qe)); break }if (o.length === 1) o[0] && ts(o[0]); else { const l = []; for (const h of o) h && l.push(...h); ts(Rs(l)) } } function ts(e, t) { const i = J(e) ? e : [...e]; for (const r of i) r.computed && ya(r); for (const r of i) r.computed || ya(r) } function ya(e, t) { (e !== re || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run()) } function vc(e, t) { var i; return (i = nn.get(e)) === null || i === void 0 ? void 0 : i.get(t) } const mc = fn("__proto__,__v_isRef,__isVue"), Io = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(ar)), _c = gn(), yc = gn(!1, !0), bc = gn(!0), Cc = gn(!0, !0), ba = Sc(); function Sc() { const e = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(t => { e[t] = function (...i) { const r = lt(this); for (let s = 0, a = this.length; s < a; s++)Yt(r, "get", s + ""); const n = r[t](...i); return n === -1 || n === !1 ? r[t](...i.map(lt)) : n } }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => { e[t] = function (...i) { Mi(); const r = lt(this)[t].apply(this, i); return Ri(), r } }), e } function wc(e) { const t = lt(this); return Yt(t, "has", e), t.hasOwnProperty(e) } function gn(e = !1, t = !1) { return function (r, n, s) { if (n === "__v_isReactive") return !e; if (n === "__v_isReadonly") return e; if (n === "__v_isShallow") return t; if (n === "__v_raw" && s === (e ? t ? Uo : Ho : t ? Bo : Go).get(r)) return r; const a = J(r); if (!e) { if (a && ht(ba, n)) return Reflect.get(ba, n, s); if (n === "hasOwnProperty") return wc } const o = Reflect.get(r, n, s); return (ar(n) ? Io.has(n) : mc(n)) || (e || Yt(r, "get", n), t) ? o : Ot(o) ? a && ks(n) ? o : o.value : vt(o) ? e ? Ls(o) : mn(o) : o } } const xc = Do(), Ec = Do(!0); function Do(e = !1) { return function (i, r, n, s) { let a = i[r]; if (ti(a) && Ot(a) && !Ot(n)) return !1; if (!e && (!or(n) && !ti(n) && (a = lt(a), n = lt(n)), !J(i) && Ot(a) && !Ot(n))) return a.value = n, !0; const o = J(i) && ks(r) ? Number(r) < i.length : ht(i, r), l = Reflect.set(i, r, n, s); return i === lt(s) && (o ? xi(n, a) && be(i, "set", r, n) : be(i, "add", r, n)), l } } function Tc(e, t) { const i = ht(e, t); e[t]; const r = Reflect.deleteProperty(e, t); return r && i && be(e, "delete", t, void 0), r } function Pc(e, t) { const i = Reflect.has(e, t); return (!ar(t) || !Io.has(t)) && Yt(e, "has", t), i } function Ac(e) { return Yt(e, "iterate", J(e) ? "length" : qe), Reflect.ownKeys(e) } const No = { get: _c, set: xc, deleteProperty: Tc, has: Pc, ownKeys: Ac }, Fo = { get: bc, set(e, t) { return !0 }, deleteProperty(e, t) { return !0 } }, kc = Tt({}, No, { get: yc, set: Ec }), Mc = Tt({}, Fo, { get: Cc }), Os = e => e, pn = e => Reflect.getPrototypeOf(e); function Er(e, t, i = !1, r = !1) { e = e.__v_raw; const n = lt(e), s = lt(t); i || (t !== s && Yt(n, "get", t), Yt(n, "get", s)); const { has: a } = pn(n), o = r ? Os : i ? Ns : lr; if (a.call(n, t)) return o(e.get(t)); if (a.call(n, s)) return o(e.get(s)); e !== n && e.get(t) } function Tr(e, t = !1) { const i = this.__v_raw, r = lt(i), n = lt(e); return t || (e !== n && Yt(r, "has", e), Yt(r, "has", n)), e === n ? i.has(e) : i.has(e) || i.has(n) } function Pr(e, t = !1) { return e = e.__v_raw, !t && Yt(lt(e), "iterate", qe), Reflect.get(e, "size", e) } function Ca(e) { e = lt(e); const t = lt(this); return pn(t).has.call(t, e) || (t.add(e), be(t, "add", e, e)), this } function Sa(e, t) { t = lt(t); const i = lt(this), { has: r, get: n } = pn(i); let s = r.call(i, e); s || (e = lt(e), s = r.call(i, e)); const a = n.call(i, e); return i.set(e, t), s ? xi(t, a) && be(i, "set", e, t) : be(i, "add", e, t), this } function wa(e) { const t = lt(this), { has: i, get: r } = pn(t); let n = i.call(t, e); n || (e = lt(e), n = i.call(t, e)), r && r.call(t, e); const s = t.delete(e); return n && be(t, "delete", e, void 0), s } function xa() { const e = lt(this), t = e.size !== 0, i = e.clear(); return t && be(e, "clear", void 0, void 0), i } function Ar(e, t) { return function (r, n) { const s = this, a = s.__v_raw, o = lt(a), l = t ? Os : e ? Ns : lr; return !e && Yt(o, "iterate", qe), a.forEach((h, c) => r.call(n, l(h), l(c), s)) } } function kr(e, t, i) { return function (...r) { const n = this.__v_raw, s = lt(n), a = _i(s), o = e === "entries" || e === Symbol.iterator && a, l = e === "keys" && a, h = n[e](...r), c = i ? Os : t ? Ns : lr; return !t && Yt(s, "iterate", l ? Zn : qe), { next() { const { value: f, done: u } = h.next(); return u ? { value: f, done: u } : { value: o ? [c(f[0]), c(f[1])] : c(f), done: u } }, [Symbol.iterator]() { return this } } } } function Ee(e) { return function (...t) { return e === "delete" ? !1 : this } } function Rc() { const e = { get(s) { return Er(this, s) }, get size() { return Pr(this) }, has: Tr, add: Ca, set: Sa, delete: wa, clear: xa, forEach: Ar(!1, !1) }, t = { get(s) { return Er(this, s, !1, !0) }, get size() { return Pr(this) }, has: Tr, add: Ca, set: Sa, delete: wa, clear: xa, forEach: Ar(!1, !0) }, i = { get(s) { return Er(this, s, !0) }, get size() { return Pr(this, !0) }, has(s) { return Tr.call(this, s, !0) }, add: Ee("add"), set: Ee("set"), delete: Ee("delete"), clear: Ee("clear"), forEach: Ar(!0, !1) }, r = { get(s) { return Er(this, s, !0, !0) }, get size() { return Pr(this, !0) }, has(s) { return Tr.call(this, s, !0) }, add: Ee("add"), set: Ee("set"), delete: Ee("delete"), clear: Ee("clear"), forEach: Ar(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(s => { e[s] = kr(s, !1, !1), i[s] = kr(s, !0, !1), t[s] = kr(s, !1, !0), r[s] = kr(s, !0, !0) }), [e, i, t, r] } const [Oc, Lc, Ic, Dc] = Rc(); function vn(e, t) { const i = t ? e ? Dc : Ic : e ? Lc : Oc; return (r, n, s) => n === "__v_isReactive" ? !e : n === "__v_isReadonly" ? e : n === "__v_raw" ? r : Reflect.get(ht(i, n) && n in r ? i : r, n, s) } const Nc = { get: vn(!1, !1) }, Fc = { get: vn(!1, !0) }, Gc = { get: vn(!0, !1) }, Bc = { get: vn(!0, !0) }, Go = new WeakMap, Bo = new WeakMap, Ho = new WeakMap, Uo = new WeakMap; function Hc(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function Uc(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : Hc(ac(e)) } function mn(e) { return ti(e) ? e : _n(e, !1, No, Nc, Go) } function Wo(e) { return _n(e, !1, kc, Fc, Bo) } function Ls(e) { return _n(e, !0, Fo, Gc, Ho) } function Wc(e) { return _n(e, !0, Mc, Bc, Uo) } function _n(e, t, i, r, n) { if (!vt(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const s = n.get(e); if (s) return s; const a = Uc(e); if (a === 0) return e; const o = new Proxy(e, a === 2 ? r : i); return n.set(e, o), o } function Je(e) { return ti(e) ? Je(e.__v_raw) : !!(e && e.__v_isReactive) } function ti(e) { return !!(e && e.__v_isReadonly) } function or(e) { return !!(e && e.__v_isShallow) } function Is(e) { return Je(e) || ti(e) } function lt(e) { const t = e && e.__v_raw; return t ? lt(t) : e } function Ds(e) { return tn(e, "__v_skip", !0), e } const lr = e => vt(e) ? mn(e) : e, Ns = e => vt(e) ? Ls(e) : e; function Fs(e) { Re && re && (e = lt(e), Lo(e.dep || (e.dep = Rs()))) } function yn(e, t) { e = lt(e); const i = e.dep; i && ts(i) } function Ot(e) { return !!(e && e.__v_isRef === !0) } function Xr(e) { return jo(e, !1) } function jc(e) { return jo(e, !0) } function jo(e, t) { return Ot(e) ? e : new zc(e, t) } class zc { constructor(t, i) { this.__v_isShallow = i, this.dep = void 0, this.__v_isRef = !0, this._rawValue = i ? t : lt(t), this._value = i ? t : lr(t) } get value() { return Fs(this), this._value } set value(t) { const i = this.__v_isShallow || or(t) || ti(t); t = i ? t : lt(t), xi(t, this._rawValue) && (this._rawValue = t, this._value = i ? t : lr(t), yn(this)) } } function Yc(e) { yn(e) } function zo(e) { return Ot(e) ? e.value : e } const Vc = { get: (e, t, i) => zo(Reflect.get(e, t, i)), set: (e, t, i, r) => { const n = e[t]; return Ot(n) && !Ot(i) ? (n.value = i, !0) : Reflect.set(e, t, i, r) } }; function Gs(e) { return Je(e) ? e : new Proxy(e, Vc) } class Kc { constructor(t) { this.dep = void 0, this.__v_isRef = !0; const { get: i, set: r } = t(() => Fs(this), () => yn(this)); this._get = i, this._set = r } get value() { return this._get() } set value(t) { this._set(t) } } function Xc(e) { return new Kc(e) } function $c(e) { const t = J(e) ? new Array(e.length) : {}; for (const i in e) t[i] = Yo(e, i); return t } class qc { constructor(t, i, r) { this._object = t, this._key = i, this._defaultValue = r, this.__v_isRef = !0 } get value() { const t = this._object[this._key]; return t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } get dep() { return vc(lt(this._object), this._key) } } function Yo(e, t, i) { const r = e[t]; return Ot(r) ? r : new qc(e, t, i) } var Vo; class Jc { constructor(t, i, r, n) { this._setter = i, this.dep = void 0, this.__v_isRef = !0, this[Vo] = !1, this._dirty = !0, this.effect = new _r(t, () => { this._dirty || (this._dirty = !0, yn(this)) }), this.effect.computed = this, this.effect.active = this._cacheable = !n, this.__v_isReadonly = r } get value() { const t = lt(this); return Fs(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value } set value(t) { this._setter(t) } } Vo = "__v_isReadonly"; function Qc(e, t, i = !1) { let r, n; const s = it(e); return s ? (r = e, n = se) : (r = e.get, n = e.set), new Jc(r, n, s || !n, i) } function Zc(e, ...t) { } function tf(e, t) { } function ye(e, t, i, r) { let n; try { n = r ? e(...r) : e() } catch (s) { si(s, t, i) } return n } function qt(e, t, i, r) { if (it(e)) { const s = ye(e, t, i, r); return s && As(s) && s.catch(a => { si(a, t, i) }), s } const n = []; for (let s = 0; s < e.length; s++)n.push(qt(e[s], t, i, r)); return n } function si(e, t, i, r = !0) { const n = t ? t.vnode : null; if (t) { let s = t.parent; const a = t.proxy, o = i; for (; s;) { const h = s.ec; if (h) { for (let c = 0; c < h.length; c++)if (h[c](e, a, o) === !1) return } s = s.parent } const l = t.appContext.config.errorHandler; if (l) { ye(l, null, 10, [e, a, o]); return } } ef(e, i, n, r) } function ef(e, t, i, r = !0) { console.error(e) } let hr = !1, es = !1; const Bt = []; let ce = 0; const bi = []; let me = null, Ke = 0; const Ko = Promise.resolve(); let Bs = null; function Hs(e) { const t = Bs || Ko; return e ? t.then(this ? e.bind(this) : e) : t } function rf(e) { let t = ce + 1, i = Bt.length; for (; t < i;) { const r = t + i >>> 1; cr(Bt[r]) < e ? t = r + 1 : i = r } return t } function bn(e) { (!Bt.length || !Bt.includes(e, hr && e.allowRecurse ? ce + 1 : ce)) && (e.id == null ? Bt.push(e) : Bt.splice(rf(e.id), 0, e), Xo()) } function Xo() { !hr && !es && (es = !0, Bs = Ko.then($o)) } function nf(e) { const t = Bt.indexOf(e); t > ce && Bt.splice(t, 1) } function Us(e) { J(e) ? bi.push(...e) : (!me || !me.includes(e, e.allowRecurse ? Ke + 1 : Ke)) && bi.push(e), Xo() } function Ea(e, t = hr ? ce + 1 : 0) { for (; t < Bt.length; t++) { const i = Bt[t]; i && i.pre && (Bt.splice(t, 1), t--, i()) } } function sn(e) { if (bi.length) { const t = [...new Set(bi)]; if (bi.length = 0, me) { me.push(...t); return } for (me = t, me.sort((i, r) => cr(i) - cr(r)), Ke = 0; Ke < me.length; Ke++)me[Ke](); me = null, Ke = 0 } } const cr = e => e.id == null ? 1 / 0 : e.id, sf = (e, t) => { const i = cr(e) - cr(t); if (i === 0) { if (e.pre && !t.pre) return -1; if (t.pre && !e.pre) return 1 } return i }; function $o(e) { es = !1, hr = !0, Bt.sort(sf); const t = se; try { for (ce = 0; ce < Bt.length; ce++) { const i = Bt[ce]; i && i.active !== !1 && ye(i, null, 14) } } finally { ce = 0, Bt.length = 0, sn(), hr = !1, Bs = null, (Bt.length || bi.length) && $o() } } let pi, Mr = []; function qo(e, t) { var i, r; pi = e, pi ? (pi.enabled = !0, Mr.forEach(({ event: n, args: s }) => pi.emit(n, ...s)), Mr = []) : typeof window < "u" && window.HTMLElement && !(!((r = (i = window.navigator) === null || i === void 0 ? void 0 : i.userAgent) === null || r === void 0) && r.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(s => { qo(s, t) }), setTimeout(() => { pi || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Mr = []) }, 3e3)) : Mr = [] } function af(e, t, ...i) { if (e.isUnmounted) return; const r = e.vnode.props || pt; let n = i; const s = t.startsWith("update:"), a = s && t.slice(7); if (a && a in r) { const c = `${a === "modelValue" ? "model" : a}Modifiers`, { number: f, trim: u } = r[c] || pt; u && (n = i.map(g => bt(g) ? g.trim() : g)), f && (n = i.map(en)) } let o, l = r[o = qi(t)] || r[o = qi(zt(t))]; !l && s && (l = r[o = qi(Zt(t))]), l && qt(l, e, 6, n); const h = r[o + "Once"]; if (h) { if (!e.emitted) e.emitted = {}; else if (e.emitted[o]) return; e.emitted[o] = !0, qt(h, e, 6, n) } } function Jo(e, t, i = !1) { const r = t.emitsCache, n = r.get(e); if (n !== void 0) return n; const s = e.emits; let a = {}, o = !1; if (!it(e)) { const l = h => { const c = Jo(h, t, !0); c && (o = !0, Tt(a, c)) }; !i && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l) } return !s && !o ? (vt(e) && r.set(e, null), null) : (J(s) ? s.forEach(l => a[l] = null) : Tt(a, s), vt(e) && r.set(e, a), a) } function Cn(e, t) { return !e || !vr(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), ht(e, t[0].toLowerCase() + t.slice(1)) || ht(e, Zt(t)) || ht(e, t)) } let Ft = null, Sn = null; function fr(e) { const t = Ft; return Ft = e, Sn = e && e.type.__scopeId || null, t } function of(e) { Sn = e } function lf() { Sn = null } const hf = e => Ws; function Ws(e, t = Ft, i) { if (!t || e._n) return e; const r = (...n) => { r._d && ls(-1); const s = fr(t); let a; try { a = e(...n) } finally { fr(s), r._d && ls(1) } return a }; return r._n = !0, r._c = !0, r._d = !0, r } function $r(e) { const { type: t, vnode: i, proxy: r, withProxy: n, props: s, propsOptions: [a], slots: o, attrs: l, emit: h, render: c, renderCache: f, data: u, setupState: g, ctx: d, inheritAttrs: y } = e; let C, b; const p = fr(e); try { if (i.shapeFlag & 4) { const w = n || r; C = Xt(c.call(w, w, f, s, g, u, d)), b = l } else { const w = t; C = Xt(w.length > 1 ? w(s, { attrs: l, slots: o, emit: h }) : w(s, null)), b = t.props ? l : ff(l) } } catch (w) { er.length = 0, si(w, e, 1), C = yt(Ht) } let m = C; if (b && y !== !1) { const w = Object.keys(b), { shapeFlag: A } = m; w.length && A & 7 && (a && w.some(Ts) && (b = uf(b, a)), m = fe(m, b)) } return i.dirs && (m = fe(m), m.dirs = m.dirs ? m.dirs.concat(i.dirs) : i.dirs), i.transition && (m.transition = i.transition), C = m, fr(p), C } function cf(e) { let t; for (let i = 0; i < e.length; i++) { const r = e[i]; if (De(r)) { if (r.type !== Ht || r.children === "v-if") { if (t) return; t = r } } else return } return t } const ff = e => { let t; for (const i in e) (i === "class" || i === "style" || vr(i)) && ((t || (t = {}))[i] = e[i]); return t }, uf = (e, t) => { const i = {}; for (const r in e) (!Ts(r) || !(r.slice(9) in t)) && (i[r] = e[r]); return i }; function df(e, t, i) { const { props: r, children: n, component: s } = e, { props: a, children: o, patchFlag: l } = t, h = s.emitsOptions; if (t.dirs || t.transition) return !0; if (i && l >= 0) { if (l & 1024) return !0; if (l & 16) return r ? Ta(r, a, h) : !!a; if (l & 8) { const c = t.dynamicProps; for (let f = 0; f < c.length; f++) { const u = c[f]; if (a[u] !== r[u] && !Cn(h, u)) return !0 } } } else return (n || o) && (!o || !o.$stable) ? !0 : r === a ? !1 : r ? a ? Ta(r, a, h) : !0 : !!a; return !1 } function Ta(e, t, i) { const r = Object.keys(t); if (r.length !== Object.keys(e).length) return !0; for (let n = 0; n < r.length; n++) { const s = r[n]; if (t[s] !== e[s] && !Cn(i, s)) return !0 } return !1 } function js({ vnode: e, parent: t }, i) { for (; t && t.subTree === e;)(e = t.vnode).el = i, t = t.parent } const Qo = e => e.__isSuspense, gf = { name: "Suspense", __isSuspense: !0, process(e, t, i, r, n, s, a, o, l, h) { e == null ? vf(t, i, r, n, s, a, o, l, h) : mf(e, t, i, r, n, a, o, l, h) }, hydrate: _f, create: zs, normalize: yf }, pf = gf; function ur(e, t) { const i = e.props && e.props[t]; it(i) && i() } function vf(e, t, i, r, n, s, a, o, l) { const { p: h, o: { createElement: c } } = l, f = c("div"), u = e.suspense = zs(e, n, r, t, f, i, s, a, o, l); h(null, u.pendingBranch = e.ssContent, f, null, r, u, s, a), u.deps > 0 ? (ur(e, "onPending"), ur(e, "onFallback"), h(null, e.ssFallback, t, i, r, null, s, a), Ci(u, e.ssFallback)) : u.resolve() } function mf(e, t, i, r, n, s, a, o, { p: l, um: h, o: { createElement: c } }) { const f = t.suspense = e.suspense; f.vnode = t, t.el = e.el; const u = t.ssContent, g = t.ssFallback, { activeBranch: d, pendingBranch: y, isInFallback: C, isHydrating: b } = f; if (y) f.pendingBranch = u, ne(u, y) ? (l(y, u, f.hiddenContainer, null, n, f, s, a, o), f.deps <= 0 ? f.resolve() : C && (l(d, g, i, r, n, null, s, a, o), Ci(f, g))) : (f.pendingId++, b ? (f.isHydrating = !1, f.activeBranch = y) : h(y, n, f), f.deps = 0, f.effects.length = 0, f.hiddenContainer = c("div"), C ? (l(null, u, f.hiddenContainer, null, n, f, s, a, o), f.deps <= 0 ? f.resolve() : (l(d, g, i, r, n, null, s, a, o), Ci(f, g))) : d && ne(u, d) ? (l(d, u, i, r, n, f, s, a, o), f.resolve(!0)) : (l(null, u, f.hiddenContainer, null, n, f, s, a, o), f.deps <= 0 && f.resolve())); else if (d && ne(u, d)) l(d, u, i, r, n, f, s, a, o), Ci(f, u); else if (ur(t, "onPending"), f.pendingBranch = u, f.pendingId++, l(null, u, f.hiddenContainer, null, n, f, s, a, o), f.deps <= 0) f.resolve(); else { const { timeout: p, pendingId: m } = f; p > 0 ? setTimeout(() => { f.pendingId === m && f.fallback(g) }, p) : p === 0 && f.fallback(g) } } function zs(e, t, i, r, n, s, a, o, l, h, c = !1) { const { p: f, m: u, um: g, n: d, o: { parentNode: y, remove: C } } = h, b = e.props ? rn(e.props.timeout) : void 0, p = { vnode: e, parent: t, parentComponent: i, isSVG: a, container: r, hiddenContainer: n, anchor: s, deps: 0, pendingId: 0, timeout: typeof b == "number" ? b : -1, activeBranch: null, pendingBranch: null, isInFallback: !0, isHydrating: c, isUnmounted: !1, effects: [], resolve(m = !1) { const { vnode: w, activeBranch: A, pendingBranch: T, pendingId: R, effects: E, parentComponent: L, container: O } = p; if (p.isHydrating) p.isHydrating = !1; else if (!m) { const k = A && T.transition && T.transition.mode === "out-in"; k && (A.transition.afterLeave = () => { R === p.pendingId && u(T, O, P, 0) }); let { anchor: P } = p; A && (P = d(A), g(A, L, p, !0)), k || u(T, O, P, 0) } Ci(p, T), p.pendingBranch = null, p.isInFallback = !1; let I = p.parent, D = !1; for (; I;) { if (I.pendingBranch) { I.effects.push(...E), D = !0; break } I = I.parent } D || Us(E), p.effects = [], ur(w, "onResolve") }, fallback(m) { if (!p.pendingBranch) return; const { vnode: w, activeBranch: A, parentComponent: T, container: R, isSVG: E } = p; ur(w, "onFallback"); const L = d(A), O = () => { p.isInFallback && (f(null, m, R, L, T, null, E, o, l), Ci(p, m)) }, I = m.transition && m.transition.mode === "out-in"; I && (A.transition.afterLeave = O), p.isInFallback = !0, g(A, T, null, !0), I || O() }, move(m, w, A) { p.activeBranch && u(p.activeBranch, m, w, A), p.container = m }, next() { return p.activeBranch && d(p.activeBranch) }, registerDep(m, w) { const A = !!p.pendingBranch; A && p.deps++; const T = m.vnode.el; m.asyncDep.catch(R => { si(R, m, 0) }).then(R => { if (m.isUnmounted || p.isUnmounted || p.pendingId !== m.suspenseId) return; m.asyncResolved = !0; const { vnode: E } = m; hs(m, R, !1), T && (E.el = T); const L = !T && m.subTree.el; w(m, E, y(T || m.subTree.el), T ? null : d(m.subTree), p, a, l), L && C(L), js(m, E.el), A && --p.deps === 0 && p.resolve() }) }, unmount(m, w) { p.isUnmounted = !0, p.activeBranch && g(p.activeBranch, i, m, w), p.pendingBranch && g(p.pendingBranch, i, m, w) } }; return p } function _f(e, t, i, r, n, s, a, o, l) { const h = t.suspense = zs(t, r, i, e.parentNode, document.createElement("div"), null, n, s, a, o, !0), c = l(e, h.pendingBranch = t.ssContent, i, h, s, a); return h.deps === 0 && h.resolve(), c } function yf(e) { const { shapeFlag: t, children: i } = e, r = t & 32; e.ssContent = Pa(r ? i.default : i), e.ssFallback = r ? Pa(i.fallback) : yt(Ht) } function Pa(e) { let t; if (it(e)) { const i = ri && e._c; i && (e._d = !1, Sr()), e = e(), i && (e._d = !0, t = jt, Tl()) } return J(e) && (e = cf(e)), e = Xt(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(i => i !== e)), e } function Zo(e, t) { t && t.pendingBranch ? J(e) ? t.effects.push(...e) : t.effects.push(e) : Us(e) } function Ci(e, t) { e.activeBranch = t; const { vnode: i, parentComponent: r } = e, n = i.el = t.el; r && r.subTree === i && (r.vnode.el = n, js(r, n)) } function tl(e, t) { if (Et) { let i = Et.provides; const r = Et.parent && Et.parent.provides; r === i && (i = Et.provides = Object.create(r)), i[e] = t } } function Ji(e, t, i = !1) { const r = Et || Ft; if (r) { const n = r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides; if (n && e in n) return n[e]; if (arguments.length > 1) return i && it(t) ? t.call(r.proxy) : t } } function bf(e, t) { return yr(e, null, t) } function el(e, t) { return yr(e, null, { flush: "post" }) } function Cf(e, t) { return yr(e, null, { flush: "sync" }) } const Rr = {}; function Qi(e, t, i) { return yr(e, t, i) } function yr(e, t, { immediate: i, deep: r, flush: n, onTrack: s, onTrigger: a } = pt) { const o = ko() === (Et == null ? void 0 : Et.scope) ? Et : null; let l, h = !1, c = !1; if (Ot(e) ? (l = () => e.value, h = or(e)) : Je(e) ? (l = () => e, r = !0) : J(e) ? (c = !0, h = e.some(m => Je(m) || or(m)), l = () => e.map(m => { if (Ot(m)) return m.value; if (Je(m)) return $e(m); if (it(m)) return ye(m, o, 2) })) : it(e) ? t ? l = () => ye(e, o, 2) : l = () => { if (!(o && o.isUnmounted)) return f && f(), qt(e, o, 3, [u]) } : l = se, t && r) { const m = l; l = () => $e(m()) } let f, u = m => { f = b.onStop = () => { ye(m, o, 4) } }, g; if (Ti) if (u = se, t ? i && qt(t, o, 3, [l(), c ? [] : void 0, u]) : l(), n === "sync") { const m = Ul(); g = m.__watcherHandles || (m.__watcherHandles = []) } else return se; let d = c ? new Array(e.length).fill(Rr) : Rr; const y = () => { if (b.active) if (t) { const m = b.run(); (r || h || (c ? m.some((w, A) => xi(w, d[A])) : xi(m, d))) && (f && f(), qt(t, o, 3, [m, d === Rr ? void 0 : c && d[0] === Rr ? [] : d, u]), d = m) } else b.run() }; y.allowRecurse = !!t; let C; n === "sync" ? C = y : n === "post" ? C = () => Dt(y, o && o.suspense) : (y.pre = !0, o && (y.id = o.uid), C = () => bn(y)); const b = new _r(l, C); t ? i ? y() : d = b.run() : n === "post" ? Dt(b.run.bind(b), o && o.suspense) : b.run(); const p = () => { b.stop(), o && o.scope && Ps(o.scope.effects, b) }; return g && g.push(p), p } function Sf(e, t, i) { const r = this.proxy, n = bt(e) ? e.includes(".") ? il(r, e) : () => r[e] : e.bind(r, r); let s; it(t) ? s = t : (s = t.handler, i = t); const a = Et; Ne(this); const o = yr(n, s.bind(r), i); return a ? Ne(a) : Oe(), o } function il(e, t) { const i = t.split("."); return () => { let r = e; for (let n = 0; n < i.length && r; n++)r = r[i[n]]; return r } } function $e(e, t) { if (!vt(e) || e.__v_skip || (t = t || new Set, t.has(e))) return e; if (t.add(e), Ot(e)) $e(e.value, t); else if (J(e)) for (let i = 0; i < e.length; i++)$e(e[i], t); else if (ni(e) || _i(e)) e.forEach(i => { $e(i, t) }); else if (Po(e)) for (const i in e) $e(e[i], t); return e } function Ys() { const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return Cr(() => { e.isMounted = !0 }), Tn(() => { e.isUnmounting = !0 }), e } const Qt = [Function, Array], wf = { name: "BaseTransition", props: { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: Qt, onEnter: Qt, onAfterEnter: Qt, onEnterCancelled: Qt, onBeforeLeave: Qt, onLeave: Qt, onAfterLeave: Qt, onLeaveCancelled: Qt, onBeforeAppear: Qt, onAppear: Qt, onAfterAppear: Qt, onAppearCancelled: Qt }, setup(e, { slots: t }) { const i = Ge(), r = Ys(); let n; return () => { const s = t.default && wn(t.default(), !0); if (!s || !s.length) return; let a = s[0]; if (s.length > 1) { for (const y of s) if (y.type !== Ht) { a = y; break } } const o = lt(e), { mode: l } = o; if (r.isLeaving) return In(a); const h = Aa(a); if (!h) return In(a); const c = Ei(h, o, r, i); ei(h, c); const f = i.subTree, u = f && Aa(f); let g = !1; const { getTransitionKey: d } = h.type; if (d) { const y = d(); n === void 0 ? n = y : y !== n && (n = y, g = !0) } if (u && u.type !== Ht && (!ne(h, u) || g)) { const y = Ei(u, o, r, i); if (ei(u, y), l === "out-in") return r.isLeaving = !0, y.afterLeave = () => { r.isLeaving = !1, i.update.active !== !1 && i.update() }, In(a); l === "in-out" && h.type !== Ht && (y.delayLeave = (C, b, p) => { const m = rl(r, u); m[String(u.key)] = u, C._leaveCb = () => { b(), C._leaveCb = void 0, delete c.delayedLeave }, c.delayedLeave = p }) } return a } } }, Vs = wf; function rl(e, t) { const { leavingVNodes: i } = e; let r = i.get(t.type); return r || (r = Object.create(null), i.set(t.type, r)), r } function Ei(e, t, i, r) { const { appear: n, mode: s, persisted: a = !1, onBeforeEnter: o, onEnter: l, onAfterEnter: h, onEnterCancelled: c, onBeforeLeave: f, onLeave: u, onAfterLeave: g, onLeaveCancelled: d, onBeforeAppear: y, onAppear: C, onAfterAppear: b, onAppearCancelled: p } = t, m = String(e.key), w = rl(i, e), A = (E, L) => { E && qt(E, r, 9, L) }, T = (E, L) => { const O = L[1]; A(E, L), J(E) ? E.every(I => I.length <= 1) && O() : E.length <= 1 && O() }, R = { mode: s, persisted: a, beforeEnter(E) { let L = o; if (!i.isMounted) if (n) L = y || o; else return; E._leaveCb && E._leaveCb(!0); const O = w[m]; O && ne(e, O) && O.el._leaveCb && O.el._leaveCb(), A(L, [E]) }, enter(E) { let L = l, O = h, I = c; if (!i.isMounted) if (n) L = C || l, O = b || h, I = p || c; else return; let D = !1; const k = E._enterCb = P => { D || (D = !0, P ? A(I, [E]) : A(O, [E]), R.delayedLeave && R.delayedLeave(), E._enterCb = void 0) }; L ? T(L, [E, k]) : k() }, leave(E, L) { const O = String(e.key); if (E._enterCb && E._enterCb(!0), i.isUnmounting) return L(); A(f, [E]); let I = !1; const D = E._leaveCb = k => { I || (I = !0, L(), k ? A(d, [E]) : A(g, [E]), E._leaveCb = void 0, w[O] === e && delete w[O]) }; w[O] = e, u ? T(u, [E, D]) : D() }, clone(E) { return Ei(E, t, i, r) } }; return R } function In(e) { if (br(e)) return e = fe(e), e.children = null, e } function Aa(e) { return br(e) ? e.children ? e.children[0] : void 0 : e } function ei(e, t) { e.shapeFlag & 6 && e.component ? ei(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function wn(e, t = !1, i) { let r = [], n = 0; for (let s = 0; s < e.length; s++) { let a = e[s]; const o = i == null ? a.key : String(i) + String(a.key != null ? a.key : s); a.type === Nt ? (a.patchFlag & 128 && n++, r = r.concat(wn(a.children, t, o))) : (t || a.type !== Ht) && r.push(o != null ? fe(a, { key: o }) : a) } if (n > 1) for (let s = 0; s < r.length; s++)r[s].patchFlag = -2; return r } function Ks(e) { return it(e) ? { setup: e, name: e.name } : e } const Qe = e => !!e.type.__asyncLoader; function xf(e) { it(e) && (e = { loader: e }); const { loader: t, loadingComponent: i, errorComponent: r, delay: n = 200, timeout: s, suspensible: a = !0, onError: o } = e; let l = null, h, c = 0; const f = () => (c++, l = null, u()), u = () => { let g; return l || (g = l = t().catch(d => { if (d = d instanceof Error ? d : new Error(String(d)), o) return new Promise((y, C) => { o(d, () => y(f()), () => C(d), c + 1) }); throw d }).then(d => g !== l && l ? l : (d && (d.__esModule || d[Symbol.toStringTag] === "Module") && (d = d.default), h = d, d))) }; return Ks({ name: "AsyncComponentWrapper", __asyncLoader: u, get __asyncResolved() { return h }, setup() { const g = Et; if (h) return () => Dn(h, g); const d = p => { l = null, si(p, g, 13, !r) }; if (a && g.suspense || Ti) return u().then(p => () => Dn(p, g)).catch(p => (d(p), () => r ? yt(r, { error: p }) : null)); const y = Xr(!1), C = Xr(), b = Xr(!!n); return n && setTimeout(() => { b.value = !1 }, n), s != null && setTimeout(() => { if (!y.value && !C.value) { const p = new Error(`Async component timed out after ${s}ms.`); d(p), C.value = p } }, s), u().then(() => { y.value = !0, g.parent && br(g.parent.vnode) && bn(g.parent.update) }).catch(p => { d(p), C.value = p }), () => { if (y.value && h) return Dn(h, g); if (C.value && r) return yt(r, { error: C.value }); if (i && !b.value) return yt(i) } } }) } function Dn(e, t) { const { ref: i, props: r, children: n, ce: s } = t.vnode, a = yt(e, r, n); return a.ref = i, a.ce = s, delete t.vnode.ce, a } const br = e => e.type.__isKeepAlive, Ef = { name: "KeepAlive", __isKeepAlive: !0, props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, setup(e, { slots: t }) { const i = Ge(), r = i.ctx; if (!r.renderer) return () => { const p = t.default && t.default(); return p && p.length === 1 ? p[0] : p }; const n = new Map, s = new Set; let a = null; const o = i.suspense, { renderer: { p: l, m: h, um: c, o: { createElement: f } } } = r, u = f("div"); r.activate = (p, m, w, A, T) => { const R = p.component; h(p, m, w, 0, o), l(R.vnode, p, m, w, R, o, A, p.slotScopeIds, T), Dt(() => { R.isDeactivated = !1, R.a && yi(R.a); const E = p.props && p.props.onVnodeMounted; E && Wt(E, R.parent, p) }, o) }, r.deactivate = p => { const m = p.component; h(p, u, null, 1, o), Dt(() => { m.da && yi(m.da); const w = p.props && p.props.onVnodeUnmounted; w && Wt(w, m.parent, p), m.isDeactivated = !0 }, o) }; function g(p) { Nn(p), c(p, i, o, !0) } function d(p) { n.forEach((m, w) => { const A = fs(m.type); A && (!p || !p(A)) && y(w) }) } function y(p) { const m = n.get(p); !a || !ne(m, a) ? g(m) : a && Nn(a), n.delete(p), s.delete(p) } Qi(() => [e.include, e.exclude], ([p, m]) => { p && d(w => zi(p, w)), m && d(w => !zi(m, w)) }, { flush: "post", deep: !0 }); let C = null; const b = () => { C != null && n.set(C, Fn(i.subTree)) }; return Cr(b), En(b), Tn(() => { n.forEach(p => { const { subTree: m, suspense: w } = i, A = Fn(m); if (p.type === A.type && p.key === A.key) { Nn(A); const T = A.component.da; T && Dt(T, w); return } g(p) }) }), () => { if (C = null, !t.default) return null; const p = t.default(), m = p[0]; if (p.length > 1) return a = null, p; if (!De(m) || !(m.shapeFlag & 4) && !(m.shapeFlag & 128)) return a = null, m; let w = Fn(m); const A = w.type, T = fs(Qe(w) ? w.type.__asyncResolved || {} : A), { include: R, exclude: E, max: L } = e; if (R && (!T || !zi(R, T)) || E && T && zi(E, T)) return a = w, m; const O = w.key == null ? A : w.key, I = n.get(O); return w.el && (w = fe(w), m.shapeFlag & 128 && (m.ssContent = w)), C = O, I ? (w.el = I.el, w.component = I.component, w.transition && ei(w, w.transition), w.shapeFlag |= 512, s.delete(O), s.add(O)) : (s.add(O), L && s.size > parseInt(L, 10) && y(s.values().next().value)), w.shapeFlag |= 256, a = w, Qo(m.type) ? m : w } } }, Tf = Ef; function zi(e, t) { return J(e) ? e.some(i => zi(i, t)) : bt(e) ? e.split(",").includes(t) : sc(e) ? e.test(t) : !1 } function nl(e, t) { al(e, "a", t) } function sl(e, t) { al(e, "da", t) } function al(e, t, i = Et) { const r = e.__wdc || (e.__wdc = () => { let n = i; for (; n;) { if (n.isDeactivated) return; n = n.parent } return e() }); if (xn(t, r, i), i) { let n = i.parent; for (; n && n.parent;)br(n.parent.vnode) && Pf(r, t, i, n), n = n.parent } } function Pf(e, t, i, r) { const n = xn(t, e, r, !0); Pn(() => { Ps(r[t], n) }, i) } function Nn(e) { e.shapeFlag &= -257, e.shapeFlag &= -513 } function Fn(e) { return e.shapeFlag & 128 ? e.ssContent : e } function xn(e, t, i = Et, r = !1) { if (i) { const n = i[e] || (i[e] = []), s = t.__weh || (t.__weh = (...a) => { if (i.isUnmounted) return; Mi(), Ne(i); const o = qt(t, i, e, a); return Oe(), Ri(), o }); return r ? n.unshift(s) : n.push(s), s } } const Ce = e => (t, i = Et) => (!Ti || e === "sp") && xn(e, (...r) => t(...r), i), ol = Ce("bm"), Cr = Ce("m"), ll = Ce("bu"), En = Ce("u"), Tn = Ce("bum"), Pn = Ce("um"), hl = Ce("sp"), cl = Ce("rtg"), fl = Ce("rtc"); function ul(e, t = Et) { xn("ec", e, t) } function Af(e, t) { const i = Ft; if (i === null) return e; const r = kn(i) || i.proxy, n = e.dirs || (e.dirs = []); for (let s = 0; s < t.length; s++) { let [a, o, l, h = pt] = t[s]; a && (it(a) && (a = { mounted: a, updated: a }), a.deep && $e(o), n.push({ dir: a, instance: r, value: o, oldValue: void 0, arg: l, modifiers: h })) } return e } function he(e, t, i, r) { const n = e.dirs, s = t && t.dirs; for (let a = 0; a < n.length; a++) { const o = n[a]; s && (o.oldValue = s[a].value); let l = o.dir[r]; l && (Mi(), qt(l, i, 8, [e.el, o, e, t]), Ri()) } } const Xs = "components", kf = "directives"; function Mf(e, t) { return $s(Xs, e, !0, t) || e } const dl = Symbol(); function Rf(e) { return bt(e) ? $s(Xs, e, !1) || e : e || dl } function Of(e) { return $s(kf, e) } function $s(e, t, i = !0, r = !1) { const n = Ft || Et; if (n) { const s = n.type; if (e === Xs) { const o = fs(s, !1); if (o && (o === t || o === zt(t) || o === mr(zt(t)))) return s } const a = ka(n[e] || s[e], t) || ka(n.appContext[e], t); return !a && r ? s : a } } function ka(e, t) { return e && (e[t] || e[zt(t)] || e[mr(zt(t))]) } function Lf(e, t, i, r) { let n; const s = i && i[r]; if (J(e) || bt(e)) { n = new Array(e.length); for (let a = 0, o = e.length; a < o; a++)n[a] = t(e[a], a, void 0, s && s[a]) } else if (typeof e == "number") { n = new Array(e); for (let a = 0; a < e; a++)n[a] = t(a + 1, a, void 0, s && s[a]) } else if (vt(e)) if (e[Symbol.iterator]) n = Array.from(e, (a, o) => t(a, o, void 0, s && s[o])); else { const a = Object.keys(e); n = new Array(a.length); for (let o = 0, l = a.length; o < l; o++) { const h = a[o]; n[o] = t(e[h], h, o, s && s[o]) } } else n = []; return i && (i[r] = n), n } function If(e, t) { for (let i = 0; i < t.length; i++) { const r = t[i]; if (J(r)) for (let n = 0; n < r.length; n++)e[r[n].name] = r[n].fn; else r && (e[r.name] = r.key ? (...n) => { const s = r.fn(...n); return s && (s.key = r.key), s } : r.fn) } return e } function Df(e, t, i = {}, r, n) { if (Ft.isCE || Ft.parent && Qe(Ft.parent) && Ft.parent.isCE) return t !== "default" && (i.name = t), yt("slot", i, r && r()); let s = e[t]; s && s._c && (s._d = !1), Sr(); const a = s && gl(s(i)), o = Zs(Nt, { key: i.key || a && a.key || `_${t}` }, a || (r ? r() : []), a && e._ === 1 ? 64 : -2); return !n && o.scopeId && (o.slotScopeIds = [o.scopeId + "-s"]), s && s._c && (s._d = !0), o } function gl(e) { return e.some(t => De(t) ? !(t.type === Ht || t.type === Nt && !gl(t.children)) : !0) ? e : null } function Nf(e, t) { const i = {}; for (const r in e) i[t && /[A-Z]/.test(r) ? `on:${r}` : qi(r)] = e[r]; return i } const is = e => e ? Ll(e) ? kn(e) || e.proxy : is(e.parent) : null, Zi = Tt(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => is(e.parent), $root: e => is(e.root), $emit: e => e.emit, $options: e => qs(e), $forceUpdate: e => e.f || (e.f = () => bn(e.update)), $nextTick: e => e.n || (e.n = Hs.bind(e.proxy)), $watch: e => Sf.bind(e) }), Gn = (e, t) => e !== pt && !e.__isScriptSetup && ht(e, t), rs = { get({ _: e }, t) { const { ctx: i, setupState: r, data: n, props: s, accessCache: a, type: o, appContext: l } = e; let h; if (t[0] !== "$") { const g = a[t]; if (g !== void 0) switch (g) { case 1: return r[t]; case 2: return n[t]; case 4: return i[t]; case 3: return s[t] } else { if (Gn(r, t)) return a[t] = 1, r[t]; if (n !== pt && ht(n, t)) return a[t] = 2, n[t]; if ((h = e.propsOptions[0]) && ht(h, t)) return a[t] = 3, s[t]; if (i !== pt && ht(i, t)) return a[t] = 4, i[t]; ns && (a[t] = 0) } } const c = Zi[t]; let f, u; if (c) return t === "$attrs" && Yt(e, "get", t), c(e); if ((f = o.__cssModules) && (f = f[t])) return f; if (i !== pt && ht(i, t)) return a[t] = 4, i[t]; if (u = l.config.globalProperties, ht(u, t)) return u[t] }, set({ _: e }, t, i) { const { data: r, setupState: n, ctx: s } = e; return Gn(n, t) ? (n[t] = i, !0) : r !== pt && ht(r, t) ? (r[t] = i, !0) : ht(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (s[t] = i, !0) }, has({ _: { data: e, setupState: t, accessCache: i, ctx: r, appContext: n, propsOptions: s } }, a) { let o; return !!i[a] || e !== pt && ht(e, a) || Gn(t, a) || (o = s[0]) && ht(o, a) || ht(r, a) || ht(Zi, a) || ht(n.config.globalProperties, a) }, defineProperty(e, t, i) { return i.get != null ? e._.accessCache[t] = 0 : ht(i, "value") && this.set(e, t, i.value, null), Reflect.defineProperty(e, t, i) } }, Ff = Tt({}, rs, { get(e, t) { if (t !== Symbol.unscopables) return rs.get(e, t, e) }, has(e, t) { return t[0] !== "_" && !Vh(t) } }); let ns = !0; function Gf(e) { const t = qs(e), i = e.proxy, r = e.ctx; ns = !1, t.beforeCreate && Ma(t.beforeCreate, e, "bc"); const { data: n, computed: s, methods: a, watch: o, provide: l, inject: h, created: c, beforeMount: f, mounted: u, beforeUpdate: g, updated: d, activated: y, deactivated: C, beforeDestroy: b, beforeUnmount: p, destroyed: m, unmounted: w, render: A, renderTracked: T, renderTriggered: R, errorCaptured: E, serverPrefetch: L, expose: O, inheritAttrs: I, components: D, directives: k, filters: P } = t; if (h && Bf(h, r, null, e.appContext.config.unwrapInjectedRef), a) for (const $ in a) { const Z = a[$]; it(Z) && (r[$] = Z.bind(i)) } if (n) { const $ = n.call(i, i); vt($) && (e.data = mn($)) } if (ns = !0, s) for (const $ in s) { const Z = s[$], st = it(Z) ? Z.bind(i, i) : it(Z.get) ? Z.get.bind(i, i) : se, q = !it(Z) && it(Z.set) ? Z.set.bind(i) : se, nt = Fl({ get: st, set: q }); Object.defineProperty(r, $, { enumerable: !0, configurable: !0, get: () => nt.value, set: ot => nt.value = ot }) } if (o) for (const $ in o) pl(o[$], r, i, $); if (l) { const $ = it(l) ? l.call(i) : l; Reflect.ownKeys($).forEach(Z => { tl(Z, $[Z]) }) } c && Ma(c, e, "c"); function H($, Z) { J(Z) ? Z.forEach(st => $(st.bind(i))) : Z && $(Z.bind(i)) } if (H(ol, f), H(Cr, u), H(ll, g), H(En, d), H(nl, y), H(sl, C), H(ul, E), H(fl, T), H(cl, R), H(Tn, p), H(Pn, w), H(hl, L), J(O)) if (O.length) { const $ = e.exposed || (e.exposed = {}); O.forEach(Z => { Object.defineProperty($, Z, { get: () => i[Z], set: st => i[Z] = st }) }) } else e.exposed || (e.exposed = {}); A && e.render === se && (e.render = A), I != null && (e.inheritAttrs = I), D && (e.components = D), k && (e.directives = k) } function Bf(e, t, i = se, r = !1) { J(e) && (e = ss(e)); for (const n in e) { const s = e[n]; let a; vt(s) ? "default" in s ? a = Ji(s.from || n, s.default, !0) : a = Ji(s.from || n) : a = Ji(s), Ot(a) && r ? Object.defineProperty(t, n, { enumerable: !0, configurable: !0, get: () => a.value, set: o => a.value = o }) : t[n] = a } } function Ma(e, t, i) { qt(J(e) ? e.map(r => r.bind(t.proxy)) : e.bind(t.proxy), t, i) } function pl(e, t, i, r) { const n = r.includes(".") ? il(i, r) : () => i[r]; if (bt(e)) { const s = t[e]; it(s) && Qi(n, s) } else if (it(e)) Qi(n, e.bind(i)); else if (vt(e)) if (J(e)) e.forEach(s => pl(s, t, i, r)); else { const s = it(e.handler) ? e.handler.bind(i) : t[e.handler]; it(s) && Qi(n, s, e) } } function qs(e) { const t = e.type, { mixins: i, extends: r } = t, { mixins: n, optionsCache: s, config: { optionMergeStrategies: a } } = e.appContext, o = s.get(t); let l; return o ? l = o : !n.length && !i && !r ? l = t : (l = {}, n.length && n.forEach(h => an(l, h, a, !0)), an(l, t, a)), vt(t) && s.set(t, l), l } function an(e, t, i, r = !1) { const { mixins: n, extends: s } = t; s && an(e, s, i, !0), n && n.forEach(a => an(e, a, i, !0)); for (const a in t) if (!(r && a === "expose")) { const o = Hf[a] || i && i[a]; e[a] = o ? o(e[a], t[a]) : t[a] } return e } const Hf = { data: Ra, props: Ve, emits: Ve, methods: Ve, computed: Ve, beforeCreate: Ut, created: Ut, beforeMount: Ut, mounted: Ut, beforeUpdate: Ut, updated: Ut, beforeDestroy: Ut, beforeUnmount: Ut, destroyed: Ut, unmounted: Ut, activated: Ut, deactivated: Ut, errorCaptured: Ut, serverPrefetch: Ut, components: Ve, directives: Ve, watch: Wf, provide: Ra, inject: Uf }; function Ra(e, t) { return t ? e ? function () { return Tt(it(e) ? e.call(this, this) : e, it(t) ? t.call(this, this) : t) } : t : e } function Uf(e, t) { return Ve(ss(e), ss(t)) } function ss(e) { if (J(e)) { const t = {}; for (let i = 0; i < e.length; i++)t[e[i]] = e[i]; return t } return e } function Ut(e, t) { return e ? [...new Set([].concat(e, t))] : t } function Ve(e, t) { return e ? Tt(Tt(Object.create(null), e), t) : t } function Wf(e, t) { if (!e) return t; if (!t) return e; const i = Tt(Object.create(null), e); for (const r in t) i[r] = Ut(e[r], t[r]); return i } function jf(e, t, i, r = !1) { const n = {}, s = {}; tn(s, An, 1), e.propsDefaults = Object.create(null), vl(e, t, n, s); for (const a in e.propsOptions[0]) a in n || (n[a] = void 0); i ? e.props = r ? n : Wo(n) : e.type.props ? e.props = n : e.props = s, e.attrs = s } function zf(e, t, i, r) { const { props: n, attrs: s, vnode: { patchFlag: a } } = e, o = lt(n), [l] = e.propsOptions; let h = !1; if ((r || a > 0) && !(a & 16)) { if (a & 8) { const c = e.vnode.dynamicProps; for (let f = 0; f < c.length; f++) { let u = c[f]; if (Cn(e.emitsOptions, u)) continue; const g = t[u]; if (l) if (ht(s, u)) g !== s[u] && (s[u] = g, h = !0); else { const d = zt(u); n[d] = as(l, o, d, g, e, !1) } else g !== s[u] && (s[u] = g, h = !0) } } } else { vl(e, t, n, s) && (h = !0); let c; for (const f in o) (!t || !ht(t, f) && ((c = Zt(f)) === f || !ht(t, c))) && (l ? i && (i[f] !== void 0 || i[c] !== void 0) && (n[f] = as(l, o, f, void 0, e, !0)) : delete n[f]); if (s !== o) for (const f in s) (!t || !ht(t, f)) && (delete s[f], h = !0) } h && be(e, "set", "$attrs") } function vl(e, t, i, r) { const [n, s] = e.propsOptions; let a = !1, o; if (t) for (let l in t) { if ($i(l)) continue; const h = t[l]; let c; n && ht(n, c = zt(l)) ? !s || !s.includes(c) ? i[c] = h : (o || (o = {}))[c] = h : Cn(e.emitsOptions, l) || (!(l in r) || h !== r[l]) && (r[l] = h, a = !0) } if (s) { const l = lt(i), h = o || pt; for (let c = 0; c < s.length; c++) { const f = s[c]; i[f] = as(n, l, f, h[f], e, !ht(h, f)) } } return a } function as(e, t, i, r, n, s) { const a = e[i]; if (a != null) { const o = ht(a, "default"); if (o && r === void 0) { const l = a.default; if (a.type !== Function && it(l)) { const { propsDefaults: h } = n; i in h ? r = h[i] : (Ne(n), r = h[i] = l.call(null, t), Oe()) } else r = l } a[0] && (s && !o ? r = !1 : a[1] && (r === "" || r === Zt(i)) && (r = !0)) } return r } function ml(e, t, i = !1) { const r = t.propsCache, n = r.get(e); if (n) return n; const s = e.props, a = {}, o = []; let l = !1; if (!it(e)) { const c = f => { l = !0; const [u, g] = ml(f, t, !0); Tt(a, u), g && o.push(...g) }; !i && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c) } if (!s && !l) return vt(e) && r.set(e, mi), mi; if (J(s)) for (let c = 0; c < s.length; c++) { const f = zt(s[c]); Oa(f) && (a[f] = pt) } else if (s) for (const c in s) { const f = zt(c); if (Oa(f)) { const u = s[c], g = a[f] = J(u) || it(u) ? { type: u } : Object.assign({}, u); if (g) { const d = Da(Boolean, g.type), y = Da(String, g.type); g[0] = d > -1, g[1] = y < 0 || d < y, (d > -1 || ht(g, "default")) && o.push(f) } } } const h = [a, o]; return vt(e) && r.set(e, h), h } function Oa(e) { return e[0] !== "$" } function La(e) { const t = e && e.toString().match(/^\s*(function|class) (\w+)/); return t ? t[2] : e === null ? "null" : "" } function Ia(e, t) { return La(e) === La(t) } function Da(e, t) { return J(t) ? t.findIndex(i => Ia(i, e)) : it(t) && Ia(t, e) ? 0 : -1 } const _l = e => e[0] === "_" || e === "$stable", Js = e => J(e) ? e.map(Xt) : [Xt(e)], Yf = (e, t, i) => { if (t._n) return t; const r = Ws((...n) => Js(t(...n)), i); return r._c = !1, r }, yl = (e, t, i) => { const r = e._ctx; for (const n in e) { if (_l(n)) continue; const s = e[n]; if (it(s)) t[n] = Yf(n, s, r); else if (s != null) { const a = Js(s); t[n] = () => a } } }, bl = (e, t) => { const i = Js(t); e.slots.default = () => i }, Vf = (e, t) => { if (e.vnode.shapeFlag & 32) { const i = t._; i ? (e.slots = lt(t), tn(t, "_", i)) : yl(t, e.slots = {}) } else e.slots = {}, t && bl(e, t); tn(e.slots, An, 1) }, Kf = (e, t, i) => { const { vnode: r, slots: n } = e; let s = !0, a = pt; if (r.shapeFlag & 32) { const o = t._; o ? i && o === 1 ? s = !1 : (Tt(n, t), !i && o === 1 && delete n._) : (s = !t.$stable, yl(t, n)), a = t } else t && (bl(e, t), a = { default: 1 }); if (s) for (const o in n) !_l(o) && !(o in a) && delete n[o] }; function Cl() { return { app: null, config: { isNativeTag: ic, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let Xf = 0; function $f(e, t) { return function (r, n = null) { it(r) || (r = Object.assign({}, r)), n != null && !vt(n) && (n = null); const s = Cl(), a = new Set; let o = !1; const l = s.app = { _uid: Xf++, _component: r, _props: n, _container: null, _context: s, _instance: null, version: jl, get config() { return s.config }, set config(h) { }, use(h, ...c) { return a.has(h) || (h && it(h.install) ? (a.add(h), h.install(l, ...c)) : it(h) && (a.add(h), h(l, ...c))), l }, mixin(h) { return s.mixins.includes(h) || s.mixins.push(h), l }, component(h, c) { return c ? (s.components[h] = c, l) : s.components[h] }, directive(h, c) { return c ? (s.directives[h] = c, l) : s.directives[h] }, mount(h, c, f) { if (!o) { const u = yt(r, n); return u.appContext = s, c && t ? t(u, h) : e(u, h, f), o = !0, l._container = h, h.__vue_app__ = l, kn(u.component) || u.component.proxy } }, unmount() { o && (e(null, l._container), delete l._container.__vue_app__) }, provide(h, c) { return s.provides[h] = c, l } }; return l } } function on(e, t, i, r, n = !1) { if (J(e)) { e.forEach((u, g) => on(u, t && (J(t) ? t[g] : t), i, r, n)); return } if (Qe(r) && !n) return; const s = r.shapeFlag & 4 ? kn(r.component) || r.component.proxy : r.el, a = n ? null : s, { i: o, r: l } = e, h = t && t.r, c = o.refs === pt ? o.refs = {} : o.refs, f = o.setupState; if (h != null && h !== l && (bt(h) ? (c[h] = null, ht(f, h) && (f[h] = null)) : Ot(h) && (h.value = null)), it(l)) ye(l, o, 12, [a, c]); else { const u = bt(l), g = Ot(l); if (u || g) { const d = () => { if (e.f) { const y = u ? ht(f, l) ? f[l] : c[l] : l.value; n ? J(y) && Ps(y, s) : J(y) ? y.includes(s) || y.push(s) : u ? (c[l] = [s], ht(f, l) && (f[l] = c[l])) : (l.value = [s], e.k && (c[e.k] = l.value)) } else u ? (c[l] = a, ht(f, l) && (f[l] = a)) : g && (l.value = a, e.k && (c[e.k] = a)) }; a ? (d.id = -1, Dt(d, i)) : d() } } } let Te = !1; const Or = e => /svg/.test(e.namespaceURI) && e.tagName !== "foreignObject", Lr = e => e.nodeType === 8; function qf(e) { const { mt: t, p: i, o: { patchProp: r, createText: n, nextSibling: s, parentNode: a, remove: o, insert: l, createComment: h } } = e, c = (b, p) => { if (!p.hasChildNodes()) { i(null, b, p), sn(), p._vnode = b; return } Te = !1, f(p.firstChild, b, null, null, null), sn(), p._vnode = b, Te && console.error("Hydration completed but contains mismatches.") }, f = (b, p, m, w, A, T = !1) => { const R = Lr(b) && b.data === "[", E = () => y(b, p, m, w, A, R), { type: L, ref: O, shapeFlag: I, patchFlag: D } = p; let k = b.nodeType; p.el = b, D === -2 && (T = !1, p.dynamicChildren = null); let P = null; switch (L) { case ii: k !== 3 ? p.children === "" ? (l(p.el = n(""), a(b), b), P = b) : P = E() : (b.data !== p.children && (Te = !0, b.data = p.children), P = s(b)); break; case Ht: k !== 8 || R ? P = E() : P = s(b); break; case Ze: if (R && (b = s(b), k = b.nodeType), k === 1 || k === 3) { P = b; const V = !p.children.length; for (let H = 0; H < p.staticCount; H++)V && (p.children += P.nodeType === 1 ? P.outerHTML : P.data), H === p.staticCount - 1 && (p.anchor = P), P = s(P); return R ? s(P) : P } else E(); break; case Nt: R ? P = d(b, p, m, w, A, T) : P = E(); break; default: if (I & 1) k !== 1 || p.type.toLowerCase() !== b.tagName.toLowerCase() ? P = E() : P = u(b, p, m, w, A, T); else if (I & 6) { p.slotScopeIds = A; const V = a(b); if (t(p, V, null, m, w, Or(V), T), P = R ? C(b) : s(b), P && Lr(P) && P.data === "teleport end" && (P = s(P)), Qe(p)) { let H; R ? (H = yt(Nt), H.anchor = P ? P.previousSibling : V.lastChild) : H = b.nodeType === 3 ? ea("") : yt("div"), H.el = b, p.component.subTree = H } } else I & 64 ? k !== 8 ? P = E() : P = p.type.hydrate(b, p, m, w, A, T, e, g) : I & 128 && (P = p.type.hydrate(b, p, m, w, Or(a(b)), A, T, e, f)) }return O != null && on(O, null, w, p), P }, u = (b, p, m, w, A, T) => { T = T || !!p.dynamicChildren; const { type: R, props: E, patchFlag: L, shapeFlag: O, dirs: I } = p, D = R === "input" && I || R === "option"; if (D || L !== -1) { if (I && he(p, null, m, "created"), E) if (D || !T || L & 48) for (const P in E) (D && P.endsWith("value") || vr(P) && !$i(P)) && r(b, P, null, E[P], !1, void 0, m); else E.onClick && r(b, "onClick", null, E.onClick, !1, void 0, m); let k; if ((k = E && E.onVnodeBeforeMount) && Wt(k, m, p), I && he(p, null, m, "beforeMount"), ((k = E && E.onVnodeMounted) || I) && Zo(() => { k && Wt(k, m, p), I && he(p, null, m, "mounted") }, w), O & 16 && !(E && (E.innerHTML || E.textContent))) { let P = g(b.firstChild, p, b, m, w, A, T); for (; P;) { Te = !0; const V = P; P = P.nextSibling, o(V) } } else O & 8 && b.textContent !== p.children && (Te = !0, b.textContent = p.children) } return b.nextSibling }, g = (b, p, m, w, A, T, R) => { R = R || !!p.dynamicChildren; const E = p.children, L = E.length; for (let O = 0; O < L; O++) { const I = R ? E[O] : E[O] = Xt(E[O]); if (b) b = f(b, I, w, A, T, R); else { if (I.type === ii && !I.children) continue; Te = !0, i(null, I, m, null, w, A, Or(m), T) } } return b }, d = (b, p, m, w, A, T) => { const { slotScopeIds: R } = p; R && (A = A ? A.concat(R) : R); const E = a(b), L = g(s(b), p, E, m, w, A, T); return L && Lr(L) && L.data === "]" ? s(p.anchor = L) : (Te = !0, l(p.anchor = h("]"), E, L), L) }, y = (b, p, m, w, A, T) => { if (Te = !0, p.el = null, T) { const L = C(b); for (; ;) { const O = s(b); if (O && O !== L) o(O); else break } } const R = s(b), E = a(b); return o(b), i(null, p, E, R, m, w, Or(E), A), R }, C = b => { let p = 0; for (; b;)if (b = s(b), b && Lr(b) && (b.data === "[" && p++, b.data === "]")) { if (p === 0) return s(b); p-- } return b }; return [c, f] } const Dt = Zo; function Sl(e) { return xl(e) } function wl(e) { return xl(e, qf) } function xl(e, t) { const i = hc(); i.__VUE__ = !0; const { insert: r, remove: n, patchProp: s, createElement: a, createText: o, createComment: l, setText: h, setElementText: c, parentNode: f, nextSibling: u, setScopeId: g = se, insertStaticContent: d } = e, y = (_, S, M, F = null, N = null, z = null, K = !1, j = null, Y = !!S.dynamicChildren) => { if (_ === S) return; _ && !ne(_, S) && (F = ee(_), ot(_, N, z, !0), _ = null), S.patchFlag === -2 && (Y = !1, S.dynamicChildren = null); const { type: B, ref: tt, shapeFlag: Q } = S; switch (B) { case ii: C(_, S, M, F); break; case Ht: b(_, S, M, F); break; case Ze: _ == null && p(S, M, F, K); break; case Nt: D(_, S, M, F, N, z, K, j, Y); break; default: Q & 1 ? A(_, S, M, F, N, z, K, j, Y) : Q & 6 ? k(_, S, M, F, N, z, K, j, Y) : (Q & 64 || Q & 128) && B.process(_, S, M, F, N, z, K, j, Y, oe) }tt != null && N && on(tt, _ && _.ref, z, S || _, !S) }, C = (_, S, M, F) => { if (_ == null) r(S.el = o(S.children), M, F); else { const N = S.el = _.el; S.children !== _.children && h(N, S.children) } }, b = (_, S, M, F) => { _ == null ? r(S.el = l(S.children || ""), M, F) : S.el = _.el }, p = (_, S, M, F) => { [_.el, _.anchor] = d(_.children, S, M, F, _.el, _.anchor) }, m = ({ el: _, anchor: S }, M, F) => { let N; for (; _ && _ !== S;)N = u(_), r(_, M, F), _ = N; r(S, M, F) }, w = ({ el: _, anchor: S }) => { let M; for (; _ && _ !== S;)M = u(_), n(_), _ = M; n(S) }, A = (_, S, M, F, N, z, K, j, Y) => { K = K || S.type === "svg", _ == null ? T(S, M, F, N, z, K, j, Y) : L(_, S, N, z, K, j, Y) }, T = (_, S, M, F, N, z, K, j) => { let Y, B; const { type: tt, props: Q, shapeFlag: et, transition: rt, dirs: at } = _; if (Y = _.el = a(_.type, z, Q && Q.is, Q), et & 8 ? c(Y, _.children) : et & 16 && E(_.children, Y, null, F, N, z && tt !== "foreignObject", K, j), at && he(_, null, F, "created"), R(Y, _, _.scopeId, K, F), Q) { for (const dt in Q) dt !== "value" && !$i(dt) && s(Y, dt, null, Q[dt], z, _.children, F, N, xt); "value" in Q && s(Y, "value", null, Q.value), (B = Q.onVnodeBeforeMount) && Wt(B, F, _) } at && he(_, null, F, "beforeMount"); const _t = (!N || N && !N.pendingBranch) && rt && !rt.persisted; _t && rt.beforeEnter(Y), r(Y, S, M), ((B = Q && Q.onVnodeMounted) || _t || at) && Dt(() => { B && Wt(B, F, _), _t && rt.enter(Y), at && he(_, null, F, "mounted") }, N) }, R = (_, S, M, F, N) => { if (M && g(_, M), F) for (let z = 0; z < F.length; z++)g(_, F[z]); if (N) { let z = N.subTree; if (S === z) { const K = N.vnode; R(_, K, K.scopeId, K.slotScopeIds, N.parent) } } }, E = (_, S, M, F, N, z, K, j, Y = 0) => { for (let B = Y; B < _.length; B++) { const tt = _[B] = j ? Me(_[B]) : Xt(_[B]); y(null, tt, S, M, F, N, z, K, j) } }, L = (_, S, M, F, N, z, K) => { const j = S.el = _.el; let { patchFlag: Y, dynamicChildren: B, dirs: tt } = S; Y |= _.patchFlag & 16; const Q = _.props || pt, et = S.props || pt; let rt; M && We(M, !1), (rt = et.onVnodeBeforeUpdate) && Wt(rt, M, S, _), tt && he(S, _, M, "beforeUpdate"), M && We(M, !0); const at = N && S.type !== "foreignObject"; if (B ? O(_.dynamicChildren, B, j, M, F, at, z) : K || Z(_, S, j, null, M, F, at, z, !1), Y > 0) { if (Y & 16) I(j, S, Q, et, M, F, N); else if (Y & 2 && Q.class !== et.class && s(j, "class", null, et.class, N), Y & 4 && s(j, "style", Q.style, et.style, N), Y & 8) { const _t = S.dynamicProps; for (let dt = 0; dt < _t.length; dt++) { const At = _t[dt], ie = Q[At], ui = et[At]; (ui !== ie || At === "value") && s(j, At, ie, ui, N, _.children, M, F, xt) } } Y & 1 && _.children !== S.children && c(j, S.children) } else !K && B == null && I(j, S, Q, et, M, F, N); ((rt = et.onVnodeUpdated) || tt) && Dt(() => { rt && Wt(rt, M, S, _), tt && he(S, _, M, "updated") }, F) }, O = (_, S, M, F, N, z, K) => { for (let j = 0; j < S.length; j++) { const Y = _[j], B = S[j], tt = Y.el && (Y.type === Nt || !ne(Y, B) || Y.shapeFlag & 70) ? f(Y.el) : M; y(Y, B, tt, null, F, N, z, K, !0) } }, I = (_, S, M, F, N, z, K) => { if (M !== F) { if (M !== pt) for (const j in M) !$i(j) && !(j in F) && s(_, j, M[j], null, K, S.children, N, z, xt); for (const j in F) { if ($i(j)) continue; const Y = F[j], B = M[j]; Y !== B && j !== "value" && s(_, j, B, Y, K, S.children, N, z, xt) } "value" in F && s(_, "value", M.value, F.value) } }, D = (_, S, M, F, N, z, K, j, Y) => { const B = S.el = _ ? _.el : o(""), tt = S.anchor = _ ? _.anchor : o(""); let { patchFlag: Q, dynamicChildren: et, slotScopeIds: rt } = S; rt && (j = j ? j.concat(rt) : rt), _ == null ? (r(B, M, F), r(tt, M, F), E(S.children, M, tt, N, z, K, j, Y)) : Q > 0 && Q & 64 && et && _.dynamicChildren ? (O(_.dynamicChildren, et, M, N, z, K, j), (S.key != null || N && S === N.subTree) && Qs(_, S, !0)) : Z(_, S, M, tt, N, z, K, j, Y) }, k = (_, S, M, F, N, z, K, j, Y) => { S.slotScopeIds = j, _ == null ? S.shapeFlag & 512 ? N.ctx.activate(S, M, F, K, Y) : P(S, M, F, N, z, K, Y) : V(_, S, Y) }, P = (_, S, M, F, N, z, K) => { const j = _.component = Ol(_, F, N); if (br(_) && (j.ctx.renderer = oe), Il(j), j.asyncDep) { if (N && N.registerDep(j, H), !_.el) { const Y = j.subTree = yt(Ht); b(null, Y, S, M) } return } H(j, _, S, M, N, z, K) }, V = (_, S, M) => { const F = S.component = _.component; if (df(_, S, M)) if (F.asyncDep && !F.asyncResolved) { $(F, S, M); return } else F.next = S, nf(F.update), F.update(); else S.el = _.el, F.vnode = S }, H = (_, S, M, F, N, z, K) => { const j = () => { if (_.isMounted) { let { next: tt, bu: Q, u: et, parent: rt, vnode: at } = _, _t = tt, dt; We(_, !1), tt ? (tt.el = at.el, $(_, tt, K)) : tt = at, Q && yi(Q), (dt = tt.props && tt.props.onVnodeBeforeUpdate) && Wt(dt, rt, tt, at), We(_, !0); const At = $r(_), ie = _.subTree; _.subTree = At, y(ie, At, f(ie.el), ee(ie), _, N, z), tt.el = At.el, _t === null && js(_, At.el), et && Dt(et, N), (dt = tt.props && tt.props.onVnodeUpdated) && Dt(() => Wt(dt, rt, tt, at), N) } else { let tt; const { el: Q, props: et } = S, { bm: rt, m: at, parent: _t } = _, dt = Qe(S); if (We(_, !1), rt && yi(rt), !dt && (tt = et && et.onVnodeBeforeMount) && Wt(tt, _t, S), We(_, !0), Q && fi) { const At = () => { _.subTree = $r(_), fi(Q, _.subTree, _, N, null) }; dt ? S.type.__asyncLoader().then(() => !_.isUnmounted && At()) : At() } else { const At = _.subTree = $r(_); y(null, At, M, F, _, N, z), S.el = At.el } if (at && Dt(at, N), !dt && (tt = et && et.onVnodeMounted)) { const At = S; Dt(() => Wt(tt, _t, At), N) } (S.shapeFlag & 256 || _t && Qe(_t.vnode) && _t.vnode.shapeFlag & 256) && _.a && Dt(_.a, N), _.isMounted = !0, S = M = F = null } }, Y = _.effect = new _r(j, () => bn(B), _.scope), B = _.update = () => Y.run(); B.id = _.uid, We(_, !0), B() }, $ = (_, S, M) => { S.component = _; const F = _.vnode.props; _.vnode = S, _.next = null, zf(_, S.props, F, M), Kf(_, S.children, M), Mi(), Ea(), Ri() }, Z = (_, S, M, F, N, z, K, j, Y = !1) => { const B = _ && _.children, tt = _ ? _.shapeFlag : 0, Q = S.children, { patchFlag: et, shapeFlag: rt } = S; if (et > 0) { if (et & 128) { q(B, Q, M, F, N, z, K, j, Y); return } else if (et & 256) { st(B, Q, M, F, N, z, K, j, Y); return } } rt & 8 ? (tt & 16 && xt(B, N, z), Q !== B && c(M, Q)) : tt & 16 ? rt & 16 ? q(B, Q, M, F, N, z, K, j, Y) : xt(B, N, z, !0) : (tt & 8 && c(M, ""), rt & 16 && E(Q, M, F, N, z, K, j, Y)) }, st = (_, S, M, F, N, z, K, j, Y) => { _ = _ || mi, S = S || mi; const B = _.length, tt = S.length, Q = Math.min(B, tt); let et; for (et = 0; et < Q; et++) { const rt = S[et] = Y ? Me(S[et]) : Xt(S[et]); y(_[et], rt, M, null, N, z, K, j, Y) } B > tt ? xt(_, N, z, !0, !1, Q) : E(S, M, F, N, z, K, j, Y, Q) }, q = (_, S, M, F, N, z, K, j, Y) => { let B = 0; const tt = S.length; let Q = _.length - 1, et = tt - 1; for (; B <= Q && B <= et;) { const rt = _[B], at = S[B] = Y ? Me(S[B]) : Xt(S[B]); if (ne(rt, at)) y(rt, at, M, null, N, z, K, j, Y); else break; B++ } for (; B <= Q && B <= et;) { const rt = _[Q], at = S[et] = Y ? Me(S[et]) : Xt(S[et]); if (ne(rt, at)) y(rt, at, M, null, N, z, K, j, Y); else break; Q--, et-- } if (B > Q) { if (B <= et) { const rt = et + 1, at = rt < tt ? S[rt].el : F; for (; B <= et;)y(null, S[B] = Y ? Me(S[B]) : Xt(S[B]), M, at, N, z, K, j, Y), B++ } } else if (B > et) for (; B <= Q;)ot(_[B], N, z, !0), B++; else { const rt = B, at = B, _t = new Map; for (B = at; B <= et; B++) { const Vt = S[B] = Y ? Me(S[B]) : Xt(S[B]); Vt.key != null && _t.set(Vt.key, B) } let dt, At = 0; const ie = et - at + 1; let ui = !1, da = 0; const Di = new Array(ie); for (B = 0; B < ie; B++)Di[B] = 0; for (B = rt; B <= Q; B++) { const Vt = _[B]; if (At >= ie) { ot(Vt, N, z, !0); continue } let le; if (Vt.key != null) le = _t.get(Vt.key); else for (dt = at; dt <= et; dt++)if (Di[dt - at] === 0 && ne(Vt, S[dt])) { le = dt; break } le === void 0 ? ot(Vt, N, z, !0) : (Di[le - at] = B + 1, le >= da ? da = le : ui = !0, y(Vt, S[le], M, null, N, z, K, j, Y), At++) } const ga = ui ? Jf(Di) : mi; for (dt = ga.length - 1, B = ie - 1; B >= 0; B--) { const Vt = at + B, le = S[Vt], pa = Vt + 1 < tt ? S[Vt + 1].el : F; Di[B] === 0 ? y(null, le, M, pa, N, z, K, j, Y) : ui && (dt < 0 || B !== ga[dt] ? nt(le, M, pa, 2) : dt--) } } }, nt = (_, S, M, F, N = null) => { const { el: z, type: K, transition: j, children: Y, shapeFlag: B } = _; if (B & 6) { nt(_.component.subTree, S, M, F); return } if (B & 128) { _.suspense.move(S, M, F); return } if (B & 64) { K.move(_, S, M, oe); return } if (K === Nt) { r(z, S, M); for (let Q = 0; Q < Y.length; Q++)nt(Y[Q], S, M, F); r(_.anchor, S, M); return } if (K === Ze) { m(_, S, M); return } if (F !== 2 && B & 1 && j) if (F === 0) j.beforeEnter(z), r(z, S, M), Dt(() => j.enter(z), N); else { const { leave: Q, delayLeave: et, afterLeave: rt } = j, at = () => r(z, S, M), _t = () => { Q(z, () => { at(), rt && rt() }) }; et ? et(z, at, _t) : _t() } else r(z, S, M) }, ot = (_, S, M, F = !1, N = !1) => { const { type: z, props: K, ref: j, children: Y, dynamicChildren: B, shapeFlag: tt, patchFlag: Q, dirs: et } = _; if (j != null && on(j, null, M, _, !0), tt & 256) { S.ctx.deactivate(_); return } const rt = tt & 1 && et, at = !Qe(_); let _t; if (at && (_t = K && K.onVnodeBeforeUnmount) && Wt(_t, S, _), tt & 6) wt(_.component, M, F); else { if (tt & 128) { _.suspense.unmount(M, F); return } rt && he(_, null, S, "beforeUnmount"), tt & 64 ? _.type.remove(_, S, M, N, oe, F) : B && (z !== Nt || Q > 0 && Q & 64) ? xt(B, S, M, !1, !0) : (z === Nt && Q & 384 || !N && tt & 16) && xt(Y, S, M), F && ut(_) } (at && (_t = K && K.onVnodeUnmounted) || rt) && Dt(() => { _t && Wt(_t, S, _), rt && he(_, null, S, "unmounted") }, M) }, ut = _ => { const { type: S, el: M, anchor: F, transition: N } = _; if (S === Nt) { Gt(M, F); return } if (S === Ze) { w(_); return } const z = () => { n(M), N && !N.persisted && N.afterLeave && N.afterLeave() }; if (_.shapeFlag & 1 && N && !N.persisted) { const { leave: K, delayLeave: j } = N, Y = () => K(M, z); j ? j(_.el, z, Y) : Y() } else z() }, Gt = (_, S) => { let M; for (; _ !== S;)M = u(_), n(_), _ = M; n(S) }, wt = (_, S, M) => { const { bum: F, scope: N, update: z, subTree: K, um: j } = _; F && yi(F), N.stop(), z && (z.active = !1, ot(K, _, S, M)), j && Dt(j, S), Dt(() => { _.isUnmounted = !0 }, S), S && S.pendingBranch && !S.isUnmounted && _.asyncDep && !_.asyncResolved && _.suspenseId === S.pendingId && (S.deps--, S.deps === 0 && S.resolve()) }, xt = (_, S, M, F = !1, N = !1, z = 0) => { for (let K = z; K < _.length; K++)ot(_[K], S, M, F, N) }, ee = _ => _.shapeFlag & 6 ? ee(_.component.subTree) : _.shapeFlag & 128 ? _.suspense.next() : u(_.anchor || _.el), Rt = (_, S, M) => { _ == null ? S._vnode && ot(S._vnode, null, null, !0) : y(S._vnode || null, _, S, null, null, null, M), Ea(), sn(), S._vnode = _ }, oe = { p: y, um: ot, m: nt, r: ut, mt: P, mc: E, pc: Z, pbc: O, n: ee, o: e }; let Ii, fi; return t && ([Ii, fi] = t(oe)), { render: Rt, hydrate: Ii, createApp: $f(Rt, Ii) } } function We({ effect: e, update: t }, i) { e.allowRecurse = t.allowRecurse = i } function Qs(e, t, i = !1) { const r = e.children, n = t.children; if (J(r) && J(n)) for (let s = 0; s < r.length; s++) { const a = r[s]; let o = n[s]; o.shapeFlag & 1 && !o.dynamicChildren && ((o.patchFlag <= 0 || o.patchFlag === 32) && (o = n[s] = Me(n[s]), o.el = a.el), i || Qs(a, o)), o.type === ii && (o.el = a.el) } } function Jf(e) { const t = e.slice(), i = [0]; let r, n, s, a, o; const l = e.length; for (r = 0; r < l; r++) { const h = e[r]; if (h !== 0) { if (n = i[i.length - 1], e[n] < h) { t[r] = n, i.push(r); continue } for (s = 0, a = i.length - 1; s < a;)o = s + a >> 1, e[i[o]] < h ? s = o + 1 : a = o; h < e[i[s]] && (s > 0 && (t[r] = i[s - 1]), i[s] = r) } } for (s = i.length, a = i[s - 1]; s-- > 0;)i[s] = a, a = t[a]; return i } const Qf = e => e.__isTeleport, tr = e => e && (e.disabled || e.disabled === ""), Na = e => typeof SVGElement < "u" && e instanceof SVGElement, os = (e, t) => { const i = e && e.to; return bt(i) ? t ? t(i) : null : i }, Zf = { __isTeleport: !0, process(e, t, i, r, n, s, a, o, l, h) { const { mc: c, pc: f, pbc: u, o: { insert: g, querySelector: d, createText: y, createComment: C } } = h, b = tr(t.props); let { shapeFlag: p, children: m, dynamicChildren: w } = t; if (e == null) { const A = t.el = y(""), T = t.anchor = y(""); g(A, i, r), g(T, i, r); const R = t.target = os(t.props, d), E = t.targetAnchor = y(""); R && (g(E, R), a = a || Na(R)); const L = (O, I) => { p & 16 && c(m, O, I, n, s, a, o, l) }; b ? L(i, T) : R && L(R, E) } else { t.el = e.el; const A = t.anchor = e.anchor, T = t.target = e.target, R = t.targetAnchor = e.targetAnchor, E = tr(e.props), L = E ? i : T, O = E ? A : R; if (a = a || Na(T), w ? (u(e.dynamicChildren, w, L, n, s, a, o), Qs(e, t, !0)) : l || f(e, t, L, O, n, s, a, o, !1), b) E || Ir(t, i, A, h, 1); else if ((t.props && t.props.to) !== (e.props && e.props.to)) { const I = t.target = os(t.props, d); I && Ir(t, I, null, h, 0) } else E && Ir(t, T, R, h, 1) } El(t) }, remove(e, t, i, r, { um: n, o: { remove: s } }, a) { const { shapeFlag: o, children: l, anchor: h, targetAnchor: c, target: f, props: u } = e; if (f && s(c), (a || !tr(u)) && (s(h), o & 16)) for (let g = 0; g < l.length; g++) { const d = l[g]; n(d, t, i, !0, !!d.dynamicChildren) } }, move: Ir, hydrate: tu }; function Ir(e, t, i, { o: { insert: r }, m: n }, s = 2) { s === 0 && r(e.targetAnchor, t, i); const { el: a, anchor: o, shapeFlag: l, children: h, props: c } = e, f = s === 2; if (f && r(a, t, i), (!f || tr(c)) && l & 16) for (let u = 0; u < h.length; u++)n(h[u], t, i, 2); f && r(o, t, i) } function tu(e, t, i, r, n, s, { o: { nextSibling: a, parentNode: o, querySelector: l } }, h) { const c = t.target = os(t.props, l); if (c) { const f = c._lpa || c.firstChild; if (t.shapeFlag & 16) if (tr(t.props)) t.anchor = h(a(e), t, o(e), i, r, n, s), t.targetAnchor = f; else { t.anchor = a(e); let u = f; for (; u;)if (u = a(u), u && u.nodeType === 8 && u.data === "teleport anchor") { t.targetAnchor = u, c._lpa = t.targetAnchor && a(t.targetAnchor); break } h(f, t, c, i, r, n, s) } El(t) } return t.anchor && a(t.anchor) } const eu = Zf; function El(e) { const t = e.ctx; if (t && t.ut) { let i = e.children[0].el; for (; i !== e.targetAnchor;)i.nodeType === 1 && i.setAttribute("data-v-owner", t.uid), i = i.nextSibling; t.ut() } } const Nt = Symbol(void 0), ii = Symbol(void 0), Ht = Symbol(void 0), Ze = Symbol(void 0), er = []; let jt = null; function Sr(e = !1) { er.push(jt = e ? null : []) } function Tl() { er.pop(), jt = er[er.length - 1] || null } let ri = 1; function ls(e) { ri += e } function Pl(e) { return e.dynamicChildren = ri > 0 ? jt || mi : null, Tl(), ri > 0 && jt && jt.push(e), e } function Al(e, t, i, r, n, s) { return Pl(ta(e, t, i, r, n, s, !0)) } function Zs(e, t, i, r, n) { return Pl(yt(e, t, i, r, n, !0)) } function De(e) { return e ? e.__v_isVNode === !0 : !1 } function ne(e, t) { return e.type === t.type && e.key === t.key } function iu(e) { } const An = "__vInternal", kl = ({ key: e }) => e ?? null, qr = ({ ref: e, ref_key: t, ref_for: i }) => e != null ? bt(e) || Ot(e) || it(e) ? { i: Ft, r: e, k: t, f: !!i } : e : null; function ta(e, t = null, i = null, r = 0, n = null, s = e === Nt ? 0 : 1, a = !1, o = !1) { const l = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && kl(t), ref: t && qr(t), scopeId: Sn, slotScopeIds: null, children: i, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: s, patchFlag: r, dynamicProps: n, dynamicChildren: null, appContext: null, ctx: Ft }; return o ? (ia(l, i), s & 128 && e.normalize(l)) : i && (l.shapeFlag |= bt(i) ? 8 : 16), ri > 0 && !a && jt && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && jt.push(l), l } const yt = ru; function ru(e, t = null, i = null, r = 0, n = null, s = !1) { if ((!e || e === dl) && (e = Ht), De(e)) { const o = fe(e, t, !0); return i && ia(o, i), ri > 0 && !s && jt && (o.shapeFlag & 6 ? jt[jt.indexOf(e)] = o : jt.push(o)), o.patchFlag |= -2, o } if (uu(e) && (e = e.__vccOpts), t) { t = Ml(t); let { class: o, style: l } = t; o && !bt(o) && (t.class = pr(o)), vt(l) && (Is(l) && !J(l) && (l = Tt({}, l)), t.style = gr(l)) } const a = bt(e) ? 1 : Qo(e) ? 128 : Qf(e) ? 64 : vt(e) ? 4 : it(e) ? 2 : 0; return ta(e, t, i, r, n, a, s, !0) } function Ml(e) { return e ? Is(e) || An in e ? Tt({}, e) : e : null } function fe(e, t, i = !1) { const { props: r, ref: n, patchFlag: s, children: a } = e, o = t ? Rl(r || {}, t) : r; return { __v_isVNode: !0, __v_skip: !0, type: e.type, props: o, key: o && kl(o), ref: t && t.ref ? i && n ? J(n) ? n.concat(qr(t)) : [n, qr(t)] : qr(t) : n, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: a, target: e.target, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== Nt ? s === -1 ? 16 : s | 16 : s, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: e.transition, component: e.component, suspense: e.suspense, ssContent: e.ssContent && fe(e.ssContent), ssFallback: e.ssFallback && fe(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce } } function ea(e = " ", t = 0) { return yt(ii, null, e, t) } function nu(e, t) { const i = yt(Ze, null, e); return i.staticCount = t, i } function su(e = "", t = !1) { return t ? (Sr(), Zs(Ht, null, e)) : yt(Ht, null, e) } function Xt(e) { return e == null || typeof e == "boolean" ? yt(Ht) : J(e) ? yt(Nt, null, e.slice()) : typeof e == "object" ? Me(e) : yt(ii, null, String(e)) } function Me(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : fe(e) } function ia(e, t) { let i = 0; const { shapeFlag: r } = e; if (t == null) t = null; else if (J(t)) i = 16; else if (typeof t == "object") if (r & 65) { const n = t.default; n && (n._c && (n._d = !1), ia(e, n()), n._c && (n._d = !0)); return } else { i = 32; const n = t._; !n && !(An in t) ? t._ctx = Ft : n === 3 && Ft && (Ft.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else it(t) ? (t = { default: t, _ctx: Ft }, i = 32) : (t = String(t), r & 64 ? (i = 16, t = [ea(t)]) : i = 8); e.children = t, e.shapeFlag |= i } function Rl(...e) { const t = {}; for (let i = 0; i < e.length; i++) { const r = e[i]; for (const n in r) if (n === "class") t.class !== r.class && (t.class = pr([t.class, r.class])); else if (n === "style") t.style = gr([t.style, r.style]); else if (vr(n)) { const s = t[n], a = r[n]; a && s !== a && !(J(s) && s.includes(a)) && (t[n] = s ? [].concat(s, a) : a) } else n !== "" && (t[n] = r[n]) } return t } function Wt(e, t, i, r = null) { qt(e, t, 7, [i, r]) } const au = Cl(); let ou = 0; function Ol(e, t, i) { const r = e.type, n = (t ? t.appContext : e.appContext) || au, s = { uid: ou++, vnode: e, type: r, parent: t, appContext: n, root: null, next: null, subTree: null, effect: null, update: null, scope: new Ms(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(n.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: ml(r, n), emitsOptions: Jo(r, n), emit: null, emitted: null, propsDefaults: pt, inheritAttrs: r.inheritAttrs, ctx: pt, data: pt, props: pt, attrs: pt, slots: pt, refs: pt, setupState: pt, setupContext: null, suspense: i, suspenseId: i ? i.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return s.ctx = { _: s }, s.root = t ? t.root : s, s.emit = af.bind(null, s), e.ce && e.ce(s), s } let Et = null; const Ge = () => Et || Ft, Ne = e => { Et = e, e.scope.on() }, Oe = () => { Et && Et.scope.off(), Et = null }; function Ll(e) { return e.vnode.shapeFlag & 4 } let Ti = !1; function Il(e, t = !1) { Ti = t; const { props: i, children: r } = e.vnode, n = Ll(e); jf(e, i, n, t), Vf(e, r); const s = n ? lu(e, t) : void 0; return Ti = !1, s } function lu(e, t) { const i = e.type; e.accessCache = Object.create(null), e.proxy = Ds(new Proxy(e.ctx, rs)); const { setup: r } = i; if (r) { const n = e.setupContext = r.length > 1 ? Nl(e) : null; Ne(e), Mi(); const s = ye(r, e, 0, [e.props, n]); if (Ri(), Oe(), As(s)) { if (s.then(Oe, Oe), t) return s.then(a => { hs(e, a, t) }).catch(a => { si(a, e, 0) }); e.asyncDep = s } else hs(e, s, t) } else Dl(e, t) } function hs(e, t, i) { it(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : vt(t) && (e.setupState = Gs(t)), Dl(e, i) } let ln, cs; function hu(e) { ln = e, cs = t => { t.render._rc && (t.withProxy = new Proxy(t.ctx, Ff)) } } const cu = () => !ln; function Dl(e, t, i) { const r = e.type; if (!e.render) { if (!t && ln && !r.render) { const n = r.template || qs(e).template; if (n) { const { isCustomElement: s, compilerOptions: a } = e.appContext.config, { delimiters: o, compilerOptions: l } = r, h = Tt(Tt({ isCustomElement: s, delimiters: o }, a), l); r.render = ln(n, h) } } e.render = r.render || se, cs && cs(e) } Ne(e), Mi(), Gf(e), Ri(), Oe() } function fu(e) { return new Proxy(e.attrs, { get(t, i) { return Yt(e, "get", "$attrs"), t[i] } }) } function Nl(e) { const t = r => { e.exposed = r || {} }; let i; return { get attrs() { return i || (i = fu(e)) }, slots: e.slots, emit: e.emit, expose: t } } function kn(e) { if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(Gs(Ds(e.exposed)), { get(t, i) { if (i in t) return t[i]; if (i in Zi) return Zi[i](e) }, has(t, i) { return i in t || i in Zi } })) } function fs(e, t = !0) { return it(e) ? e.displayName || e.name : e.name || t && e.__name } function uu(e) { return it(e) && "__vccOpts" in e } const Fl = (e, t) => Qc(e, t, Ti); function du() { return null } function gu() { return null } function pu(e) { } function vu(e, t) { return null } function mu() { return Gl().slots } function _u() { return Gl().attrs } function Gl() { const e = Ge(); return e.setupContext || (e.setupContext = Nl(e)) } function yu(e, t) { const i = J(e) ? e.reduce((r, n) => (r[n] = {}, r), {}) : e; for (const r in t) { const n = i[r]; n ? J(n) || it(n) ? i[r] = { type: n, default: t[r] } : n.default = t[r] : n === null && (i[r] = { default: t[r] }) } return i } function bu(e, t) { const i = {}; for (const r in e) t.includes(r) || Object.defineProperty(i, r, { enumerable: !0, get: () => e[r] }); return i } function Cu(e) { const t = Ge(); let i = e(); return Oe(), As(i) && (i = i.catch(r => { throw Ne(t), r })), [i, () => Ne(t)] } function Bl(e, t, i) { const r = arguments.length; return r === 2 ? vt(t) && !J(t) ? De(t) ? yt(e, null, [t]) : yt(e, t) : yt(e, null, t) : (r > 3 ? i = Array.prototype.slice.call(arguments, 2) : r === 3 && De(i) && (i = [i]), yt(e, t, i)) } const Hl = Symbol(""), Ul = () => Ji(Hl); function Su() { } function wu(e, t, i, r) { const n = i[r]; if (n && Wl(n, e)) return n; const s = t(); return s.memo = e.slice(), i[r] = s } function Wl(e, t) { const i = e.memo; if (i.length != t.length) return !1; for (let r = 0; r < i.length; r++)if (xi(i[r], t[r])) return !1; return ri > 0 && jt && jt.push(e), !0 } const jl = "3.2.47", xu = { createComponentInstance: Ol, setupComponent: Il, renderComponentRoot: $r, setCurrentRenderingInstance: fr, isVNode: De, normalizeVNode: Xt }, Eu = xu, Tu = null, Pu = null, Au = "http://www.w3.org/2000/svg", Xe = typeof document < "u" ? document : null, Fa = Xe && Xe.createElement("template"), ku = { insert: (e, t, i) => { t.insertBefore(e, i || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, i, r) => { const n = t ? Xe.createElementNS(Au, e) : Xe.createElement(e, i ? { is: i } : void 0); return e === "select" && r && r.multiple != null && n.setAttribute("multiple", r.multiple), n }, createText: e => Xe.createTextNode(e), createComment: e => Xe.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Xe.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, i, r, n, s) { const a = i ? i.previousSibling : t.lastChild; if (n && (n === s || n.nextSibling)) for (; t.insertBefore(n.cloneNode(!0), i), !(n === s || !(n = n.nextSibling));); else { Fa.innerHTML = r ? `<svg>${e}</svg>` : e; const o = Fa.content; if (r) { const l = o.firstChild; for (; l.firstChild;)o.appendChild(l.firstChild); o.removeChild(l) } t.insertBefore(o, i) } return [a ? a.nextSibling : t.firstChild, i ? i.previousSibling : t.lastChild] } }; function Mu(e, t, i) { const r = e._vtc; r && (t = (t ? [t, ...r] : [...r]).join(" ")), t == null ? e.removeAttribute("class") : i ? e.setAttribute("class", t) : e.className = t } function Ru(e, t, i) { const r = e.style, n = bt(i); if (i && !n) { if (t && !bt(t)) for (const s in t) i[s] == null && us(r, s, ""); for (const s in i) us(r, s, i[s]) } else { const s = r.display; n ? t !== i && (r.cssText = i) : t && e.removeAttribute("style"), "_vod" in e && (r.display = s) } } const Ga = /\s*!important$/; function us(e, t, i) { if (J(i)) i.forEach(r => us(e, t, r)); else if (i == null && (i = ""), t.startsWith("--")) e.setProperty(t, i); else { const r = Ou(e, t); Ga.test(i) ? e.setProperty(Zt(r), i.replace(Ga, ""), "important") : e[r] = i } } const Ba = ["Webkit", "Moz", "ms"], Bn = {}; function Ou(e, t) { const i = Bn[t]; if (i) return i; let r = zt(t); if (r !== "filter" && r in e) return Bn[t] = r; r = mr(r); for (let n = 0; n < Ba.length; n++) { const s = Ba[n] + r; if (s in e) return Bn[t] = s } return t } const Ha = "http://www.w3.org/1999/xlink"; function Lu(e, t, i, r, n) { if (r && t.startsWith("xlink:")) i == null ? e.removeAttributeNS(Ha, t.slice(6, t.length)) : e.setAttributeNS(Ha, t, i); else { const s = Zh(t); i == null || s && !xo(i) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : i) } } function Iu(e, t, i, r, n, s, a) { if (t === "innerHTML" || t === "textContent") { r && a(r, n, s), e[t] = i ?? ""; return } if (t === "value" && e.tagName !== "PROGRESS" && !e.tagName.includes("-")) { e._value = i; const l = i ?? ""; (e.value !== l || e.tagName === "OPTION") && (e.value = l), i == null && e.removeAttribute(t); return } let o = !1; if (i === "" || i == null) { const l = typeof e[t]; l === "boolean" ? i = xo(i) : i == null && l === "string" ? (i = "", o = !0) : l === "number" && (i = 0, o = !0) } try { e[t] = i } catch { } o && e.removeAttribute(t) } function _e(e, t, i, r) { e.addEventListener(t, i, r) } function Du(e, t, i, r) { e.removeEventListener(t, i, r) } function Nu(e, t, i, r, n = null) { const s = e._vei || (e._vei = {}), a = s[t]; if (r && a) a.value = r; else { const [o, l] = Fu(t); if (r) { const h = s[t] = Hu(r, n); _e(e, o, h, l) } else a && (Du(e, o, a, l), s[t] = void 0) } } const Ua = /(?:Once|Passive|Capture)$/; function Fu(e) { let t; if (Ua.test(e)) { t = {}; let r; for (; r = e.match(Ua);)e = e.slice(0, e.length - r[0].length), t[r[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : Zt(e.slice(2)), t] } let Hn = 0; const Gu = Promise.resolve(), Bu = () => Hn || (Gu.then(() => Hn = 0), Hn = Date.now()); function Hu(e, t) { const i = r => { if (!r._vts) r._vts = Date.now(); else if (r._vts <= i.attached) return; qt(Uu(r, i.value), t, 5, [r]) }; return i.value = e, i.attached = Bu(), i } function Uu(e, t) { if (J(t)) { const i = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { i.call(e), e._stopped = !0 }, t.map(r => n => !n._stopped && r && r(n)) } else return t } const Wa = /^on[a-z]/, Wu = (e, t, i, r, n = !1, s, a, o, l) => { t === "class" ? Mu(e, r, n) : t === "style" ? Ru(e, i, r) : vr(t) ? Ts(t) || Nu(e, t, i, r, a) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : ju(e, t, r, n)) ? Iu(e, t, r, s, a, o, l) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r), Lu(e, t, r, n)) }; function ju(e, t, i, r) { return r ? !!(t === "innerHTML" || t === "textContent" || t in e && Wa.test(t) && it(i)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || Wa.test(t) && bt(i) ? !1 : t in e } function zl(e, t) { const i = Ks(e); class r extends Mn { constructor(s) { super(i, s, t) } } return r.def = i, r } const zu = e => zl(e, ah), Yu = typeof HTMLElement < "u" ? HTMLElement : class { }; class Mn extends Yu { constructor(t, i = {}, r) { super(), this._def = t, this._props = i, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this.shadowRoot && r ? r(this._createVNode(), this.shadowRoot) : (this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def)) } connectedCallback() { this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef()) } disconnectedCallback() { this._connected = !1, Hs(() => { this._connected || (ps(null, this.shadowRoot), this._instance = null) }) } _resolveDef() { this._resolved = !0; for (let r = 0; r < this.attributes.length; r++)this._setAttr(this.attributes[r].name); new MutationObserver(r => { for (const n of r) this._setAttr(n.attributeName) }).observe(this, { attributes: !0 }); const t = (r, n = !1) => { const { props: s, styles: a } = r; let o; if (s && !J(s)) for (const l in s) { const h = s[l]; (h === Number || h && h.type === Number) && (l in this._props && (this._props[l] = rn(this._props[l])), (o || (o = Object.create(null)))[zt(l)] = !0) } this._numberProps = o, n && this._resolveProps(r), this._applyStyles(a), this._update() }, i = this._def.__asyncLoader; i ? i().then(r => t(r, !0)) : t(this._def) } _resolveProps(t) { const { props: i } = t, r = J(i) ? i : Object.keys(i || {}); for (const n of Object.keys(this)) n[0] !== "_" && r.includes(n) && this._setProp(n, this[n], !0, !1); for (const n of r.map(zt)) Object.defineProperty(this, n, { get() { return this._getProp(n) }, set(s) { this._setProp(n, s) } }) } _setAttr(t) { let i = this.getAttribute(t); const r = zt(t); this._numberProps && this._numberProps[r] && (i = rn(i)), this._setProp(r, i, !1) } _getProp(t) { return this._props[t] } _setProp(t, i, r = !0, n = !0) { i !== this._props[t] && (this._props[t] = i, n && this._instance && this._update(), r && (i === !0 ? this.setAttribute(Zt(t), "") : typeof i == "string" || typeof i == "number" ? this.setAttribute(Zt(t), i + "") : i || this.removeAttribute(Zt(t)))) } _update() { ps(this._createVNode(), this.shadowRoot) } _createVNode() { const t = yt(this._def, Tt({}, this._props)); return this._instance || (t.ce = i => { this._instance = i, i.isCE = !0; const r = (s, a) => { this.dispatchEvent(new CustomEvent(s, { detail: a })) }; i.emit = (s, ...a) => { r(s, a), Zt(s) !== s && r(Zt(s), a) }; let n = this; for (; n = n && (n.parentNode || n.host);)if (n instanceof Mn) { i.parent = n._instance, i.provides = n._instance.provides; break } }), t } _applyStyles(t) { t && t.forEach(i => { const r = document.createElement("style"); r.textContent = i, this.shadowRoot.appendChild(r) }) } } function Vu(e = "$style") { { const t = Ge(); if (!t) return pt; const i = t.type.__cssModules; if (!i) return pt; const r = i[e]; return r || pt } } function Ku(e) { const t = Ge(); if (!t) return; const i = t.ut = (n = e(t.proxy)) => { Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(s => gs(s, n)) }, r = () => { const n = e(t.proxy); ds(t.subTree, n), i(n) }; el(r), Cr(() => { const n = new MutationObserver(r); n.observe(t.subTree.el.parentNode, { childList: !0 }), Pn(() => n.disconnect()) }) } function ds(e, t) { if (e.shapeFlag & 128) { const i = e.suspense; e = i.activeBranch, i.pendingBranch && !i.isHydrating && i.effects.push(() => { ds(i.activeBranch, t) }) } for (; e.component;)e = e.component.subTree; if (e.shapeFlag & 1 && e.el) gs(e.el, t); else if (e.type === Nt) e.children.forEach(i => ds(i, t)); else if (e.type === Ze) { let { el: i, anchor: r } = e; for (; i && (gs(i, t), i !== r);)i = i.nextSibling } } function gs(e, t) { if (e.nodeType === 1) { const i = e.style; for (const r in t) i.setProperty(`--${r}`, t[r]) } } const Pe = "transition", Ni = "animation", ra = (e, { slots: t }) => Bl(Vs, Vl(e), t); ra.displayName = "Transition"; const Yl = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, Xu = ra.props = Tt({}, Vs.props, Yl), je = (e, t = []) => { J(e) ? e.forEach(i => i(...t)) : e && e(...t) }, ja = e => e ? J(e) ? e.some(t => t.length > 1) : e.length > 1 : !1; function Vl(e) { const t = {}; for (const D in e) D in Yl || (t[D] = e[D]); if (e.css === !1) return t; const { name: i = "v", type: r, duration: n, enterFromClass: s = `${i}-enter-from`, enterActiveClass: a = `${i}-enter-active`, enterToClass: o = `${i}-enter-to`, appearFromClass: l = s, appearActiveClass: h = a, appearToClass: c = o, leaveFromClass: f = `${i}-leave-from`, leaveActiveClass: u = `${i}-leave-active`, leaveToClass: g = `${i}-leave-to` } = e, d = $u(n), y = d && d[0], C = d && d[1], { onBeforeEnter: b, onEnter: p, onEnterCancelled: m, onLeave: w, onLeaveCancelled: A, onBeforeAppear: T = b, onAppear: R = p, onAppearCancelled: E = m } = t, L = (D, k, P) => { Ae(D, k ? c : o), Ae(D, k ? h : a), P && P() }, O = (D, k) => { D._isLeaving = !1, Ae(D, f), Ae(D, g), Ae(D, u), k && k() }, I = D => (k, P) => { const V = D ? R : p, H = () => L(k, D, P); je(V, [k, H]), za(() => { Ae(k, D ? l : s), ge(k, D ? c : o), ja(V) || Ya(k, r, y, H) }) }; return Tt(t, { onBeforeEnter(D) { je(b, [D]), ge(D, s), ge(D, a) }, onBeforeAppear(D) { je(T, [D]), ge(D, l), ge(D, h) }, onEnter: I(!1), onAppear: I(!0), onLeave(D, k) { D._isLeaving = !0; const P = () => O(D, k); ge(D, f), Xl(), ge(D, u), za(() => { D._isLeaving && (Ae(D, f), ge(D, g), ja(w) || Ya(D, r, C, P)) }), je(w, [D, P]) }, onEnterCancelled(D) { L(D, !1), je(m, [D]) }, onAppearCancelled(D) { L(D, !0), je(E, [D]) }, onLeaveCancelled(D) { O(D), je(A, [D]) } }) } function $u(e) { if (e == null) return null; if (vt(e)) return [Un(e.enter), Un(e.leave)]; { const t = Un(e); return [t, t] } } function Un(e) { return rn(e) } function ge(e, t) { t.split(/\s+/).forEach(i => i && e.classList.add(i)), (e._vtc || (e._vtc = new Set)).add(t) } function Ae(e, t) { t.split(/\s+/).forEach(r => r && e.classList.remove(r)); const { _vtc: i } = e; i && (i.delete(t), i.size || (e._vtc = void 0)) } function za(e) { requestAnimationFrame(() => { requestAnimationFrame(e) }) } let qu = 0; function Ya(e, t, i, r) { const n = e._endId = ++qu, s = () => { n === e._endId && r() }; if (i) return setTimeout(s, i); const { type: a, timeout: o, propCount: l } = Kl(e, t); if (!a) return r(); const h = a + "end"; let c = 0; const f = () => { e.removeEventListener(h, u), s() }, u = g => { g.target === e && ++c >= l && f() }; setTimeout(() => { c < l && f() }, o + 1), e.addEventListener(h, u) } function Kl(e, t) { const i = window.getComputedStyle(e), r = d => (i[d] || "").split(", "), n = r(`${Pe}Delay`), s = r(`${Pe}Duration`), a = Va(n, s), o = r(`${Ni}Delay`), l = r(`${Ni}Duration`), h = Va(o, l); let c = null, f = 0, u = 0; t === Pe ? a > 0 && (c = Pe, f = a, u = s.length) : t === Ni ? h > 0 && (c = Ni, f = h, u = l.length) : (f = Math.max(a, h), c = f > 0 ? a > h ? Pe : Ni : null, u = c ? c === Pe ? s.length : l.length : 0); const g = c === Pe && /\b(transform|all)(,|$)/.test(r(`${Pe}Property`).toString()); return { type: c, timeout: f, propCount: u, hasTransform: g } } function Va(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max(...t.map((i, r) => Ka(i) + Ka(e[r]))) } function Ka(e) { return Number(e.slice(0, -1).replace(",", ".")) * 1e3 } function Xl() { return document.body.offsetHeight } const $l = new WeakMap, ql = new WeakMap, Jl = { name: "TransitionGroup", props: Tt({}, Xu, { tag: String, moveClass: String }), setup(e, { slots: t }) { const i = Ge(), r = Ys(); let n, s; return En(() => { if (!n.length) return; const a = e.moveClass || `${e.name || "v"}-move`; if (!id(n[0].el, i.vnode.el, a)) return; n.forEach(Zu), n.forEach(td); const o = n.filter(ed); Xl(), o.forEach(l => { const h = l.el, c = h.style; ge(h, a), c.transform = c.webkitTransform = c.transitionDuration = ""; const f = h._moveCb = u => { u && u.target !== h || (!u || /transform$/.test(u.propertyName)) && (h.removeEventListener("transitionend", f), h._moveCb = null, Ae(h, a)) }; h.addEventListener("transitionend", f) }) }), () => { const a = lt(e), o = Vl(a); let l = a.tag || Nt; n = s, s = t.default ? wn(t.default()) : []; for (let h = 0; h < s.length; h++) { const c = s[h]; c.key != null && ei(c, Ei(c, o, r, i)) } if (n) for (let h = 0; h < n.length; h++) { const c = n[h]; ei(c, Ei(c, o, r, i)), $l.set(c, c.el.getBoundingClientRect()) } return yt(l, null, s) } } }, Ju = e => delete e.mode; Jl.props; const Qu = Jl; function Zu(e) { const t = e.el; t._moveCb && t._moveCb(), t._enterCb && t._enterCb() } function td(e) { ql.set(e, e.el.getBoundingClientRect()) } function ed(e) { const t = $l.get(e), i = ql.get(e), r = t.left - i.left, n = t.top - i.top; if (r || n) { const s = e.el.style; return s.transform = s.webkitTransform = `translate(${r}px,${n}px)`, s.transitionDuration = "0s", e } } function id(e, t, i) { const r = e.cloneNode(); e._vtc && e._vtc.forEach(a => { a.split(/\s+/).forEach(o => o && r.classList.remove(o)) }), i.split(/\s+/).forEach(a => a && r.classList.add(a)), r.style.display = "none"; const n = t.nodeType === 1 ? t : t.parentNode; n.appendChild(r); const { hasTransform: s } = Kl(r); return n.removeChild(r), s } const Fe = e => { const t = e.props["onUpdate:modelValue"] || !1; return J(t) ? i => yi(t, i) : t }; function rd(e) { e.target.composing = !0 } function Xa(e) { const t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event("input"))) } const hn = { created(e, { modifiers: { lazy: t, trim: i, number: r } }, n) { e._assign = Fe(n); const s = r || n.props && n.props.type === "number"; _e(e, t ? "change" : "input", a => { if (a.target.composing) return; let o = e.value; i && (o = o.trim()), s && (o = en(o)), e._assign(o) }), i && _e(e, "change", () => { e.value = e.value.trim() }), t || (_e(e, "compositionstart", rd), _e(e, "compositionend", Xa), _e(e, "change", Xa)) }, mounted(e, { value: t }) { e.value = t ?? "" }, beforeUpdate(e, { value: t, modifiers: { lazy: i, trim: r, number: n } }, s) { if (e._assign = Fe(s), e.composing || document.activeElement === e && e.type !== "range" && (i || r && e.value.trim() === t || (n || e.type === "number") && en(e.value) === t)) return; const a = t ?? ""; e.value !== a && (e.value = a) } }, na = { deep: !0, created(e, t, i) { e._assign = Fe(i), _e(e, "change", () => { const r = e._modelValue, n = Pi(e), s = e.checked, a = e._assign; if (J(r)) { const o = un(r, n), l = o !== -1; if (s && !l) a(r.concat(n)); else if (!s && l) { const h = [...r]; h.splice(o, 1), a(h) } } else if (ni(r)) { const o = new Set(r); s ? o.add(n) : o.delete(n), a(o) } else a(Zl(e, s)) }) }, mounted: $a, beforeUpdate(e, t, i) { e._assign = Fe(i), $a(e, t, i) } }; function $a(e, { value: t, oldValue: i }, r) { e._modelValue = t, J(t) ? e.checked = un(t, r.props.value) > -1 : ni(t) ? e.checked = t.has(r.props.value) : t !== i && (e.checked = Le(t, Zl(e, !0))) } const sa = { created(e, { value: t }, i) { e.checked = Le(t, i.props.value), e._assign = Fe(i), _e(e, "change", () => { e._assign(Pi(e)) }) }, beforeUpdate(e, { value: t, oldValue: i }, r) { e._assign = Fe(r), t !== i && (e.checked = Le(t, r.props.value)) } }, Ql = { deep: !0, created(e, { value: t, modifiers: { number: i } }, r) { const n = ni(t); _e(e, "change", () => { const s = Array.prototype.filter.call(e.options, a => a.selected).map(a => i ? en(Pi(a)) : Pi(a)); e._assign(e.multiple ? n ? new Set(s) : s : s[0]) }), e._assign = Fe(r) }, mounted(e, { value: t }) { qa(e, t) }, beforeUpdate(e, t, i) { e._assign = Fe(i) }, updated(e, { value: t }) { qa(e, t) } }; function qa(e, t) { const i = e.multiple; if (!(i && !J(t) && !ni(t))) { for (let r = 0, n = e.options.length; r < n; r++) { const s = e.options[r], a = Pi(s); if (i) J(t) ? s.selected = un(t, a) > -1 : s.selected = t.has(a); else if (Le(Pi(s), t)) { e.selectedIndex !== r && (e.selectedIndex = r); return } } !i && e.selectedIndex !== -1 && (e.selectedIndex = -1) } } function Pi(e) { return "_value" in e ? e._value : e.value } function Zl(e, t) { const i = t ? "_trueValue" : "_falseValue"; return i in e ? e[i] : t } const th = { created(e, t, i) { Dr(e, t, i, null, "created") }, mounted(e, t, i) { Dr(e, t, i, null, "mounted") }, beforeUpdate(e, t, i, r) { Dr(e, t, i, r, "beforeUpdate") }, updated(e, t, i, r) { Dr(e, t, i, r, "updated") } }; function eh(e, t) { switch (e) { case "SELECT": return Ql; case "TEXTAREA": return hn; default: switch (t) { case "checkbox": return na; case "radio": return sa; default: return hn } } } function Dr(e, t, i, r, n) { const a = eh(e.tagName, i.props && i.props.type)[n]; a && a(e, t, i, r) } function nd() { hn.getSSRProps = ({ value: e }) => ({ value: e }), sa.getSSRProps = ({ value: e }, t) => { if (t.props && Le(t.props.value, e)) return { checked: !0 } }, na.getSSRProps = ({ value: e }, t) => { if (J(e)) { if (t.props && un(e, t.props.value) > -1) return { checked: !0 } } else if (ni(e)) { if (t.props && e.has(t.props.value)) return { checked: !0 } } else if (e) return { checked: !0 } }, th.getSSRProps = (e, t) => { if (typeof t.type != "string") return; const i = eh(t.type.toUpperCase(), t.props && t.props.type); if (i.getSSRProps) return i.getSSRProps(e, t) } } const sd = ["ctrl", "shift", "alt", "meta"], ad = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && e.button !== 0, middle: e => "button" in e && e.button !== 1, right: e => "button" in e && e.button !== 2, exact: (e, t) => sd.some(i => e[`${i}Key`] && !t.includes(i)) }, od = (e, t) => (i, ...r) => { for (let n = 0; n < t.length; n++) { const s = ad[t[n]]; if (s && s(i, t)) return } return e(i, ...r) }, ld = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, hd = (e, t) => i => { if (!("key" in i)) return; const r = Zt(i.key); if (t.some(n => n === r || ld[n] === r)) return e(i) }, ih = { beforeMount(e, { value: t }, { transition: i }) { e._vod = e.style.display === "none" ? "" : e.style.display, i && t ? i.beforeEnter(e) : Fi(e, t) }, mounted(e, { value: t }, { transition: i }) { i && t && i.enter(e) }, updated(e, { value: t, oldValue: i }, { transition: r }) { !t != !i && (r ? t ? (r.beforeEnter(e), Fi(e, !0), r.enter(e)) : r.leave(e, () => { Fi(e, !1) }) : Fi(e, t)) }, beforeUnmount(e, { value: t }) { Fi(e, t) } }; function Fi(e, t) { e.style.display = t ? e._vod : "none" } function cd() { ih.getSSRProps = ({ value: e }) => { if (!e) return { style: { display: "none" } } } } const rh = Tt({ patchProp: Wu }, ku); let ir, Ja = !1; function nh() { return ir || (ir = Sl(rh)) } function sh() { return ir = Ja ? ir : wl(rh), Ja = !0, ir } const ps = (...e) => { nh().render(...e) }, ah = (...e) => { sh().hydrate(...e) }, oh = (...e) => { const t = nh().createApp(...e), { mount: i } = t; return t.mount = r => { const n = lh(r); if (!n) return; const s = t._component; !it(s) && !s.render && !s.template && (s.template = n.innerHTML), n.innerHTML = ""; const a = i(n, !1, n instanceof SVGElement); return n instanceof Element && (n.removeAttribute("v-cloak"), n.setAttribute("data-v-app", "")), a }, t }, fd = (...e) => { const t = sh().createApp(...e), { mount: i } = t; return t.mount = r => { const n = lh(r); if (n) return i(n, !0, n instanceof SVGElement) }, t }; function lh(e) { return bt(e) ? document.querySelector(e) : e } let Qa = !1; const ud = () => { Qa || (Qa = !0, nd(), cd()) }, dd = () => { }, gd = Object.freeze(Object.defineProperty({ __proto__: null, BaseTransition: Vs, Comment: Ht, EffectScope: Ms, Fragment: Nt, KeepAlive: Tf, ReactiveEffect: _r, Static: Ze, Suspense: pf, Teleport: eu, Text: ii, Transition: ra, TransitionGroup: Qu, VueElement: Mn, assertNumber: tf, callWithAsyncErrorHandling: qt, callWithErrorHandling: ye, camelize: zt, capitalize: mr, cloneVNode: fe, compatUtils: Pu, compile: dd, computed: Fl, createApp: oh, createBlock: Zs, createCommentVNode: su, createElementBlock: Al, createElementVNode: ta, createHydrationRenderer: wl, createPropsRestProxy: bu, createRenderer: Sl, createSSRApp: fd, createSlots: If, createStaticVNode: nu, createTextVNode: ea, createVNode: yt, customRef: Xc, defineAsyncComponent: xf, defineComponent: Ks, defineCustomElement: zl, defineEmits: gu, defineExpose: pu, defineProps: du, defineSSRCustomElement: zu, get devtools() { return pi }, effect: gc, effectScope: cc, getCurrentInstance: Ge, getCurrentScope: ko, getTransitionRawChildren: wn, guardReactiveProps: Ml, h: Bl, handleError: si, hydrate: ah, initCustomFormatter: Su, initDirectivesForSSR: ud, inject: Ji, isMemoSame: Wl, isProxy: Is, isReactive: Je, isReadonly: ti, isRef: Ot, isRuntimeOnly: cu, isShallow: or, isVNode: De, markRaw: Ds, mergeDefaults: yu, mergeProps: Rl, nextTick: Hs, normalizeClass: pr, normalizeProps: Jh, normalizeStyle: gr, onActivated: nl, onBeforeMount: ol, onBeforeUnmount: Tn, onBeforeUpdate: ll, onDeactivated: sl, onErrorCaptured: ul, onMounted: Cr, onRenderTracked: fl, onRenderTriggered: cl, onScopeDispose: fc, onServerPrefetch: hl, onUnmounted: Pn, onUpdated: En, openBlock: Sr, popScopeId: lf, provide: tl, proxyRefs: Gs, pushScopeId: of, queuePostFlushCb: Us, reactive: mn, readonly: Ls, ref: Xr, registerRuntimeCompiler: hu, render: ps, renderList: Lf, renderSlot: Df, resolveComponent: Mf, resolveDirective: Of, resolveDynamicComponent: Rf, resolveFilter: Tu, resolveTransitionHooks: Ei, setBlockTracking: ls, setDevtoolsHook: qo, setTransitionHooks: ei, shallowReactive: Wo, shallowReadonly: Wc, shallowRef: jc, ssrContextKey: Hl, ssrUtils: Eu, stop: pc, toDisplayString: ec, toHandlerKey: qi, toHandlers: Nf, toRaw: lt, toRef: Yo, toRefs: $c, transformVNodeArgs: iu, triggerRef: Yc, unref: zo, useAttrs: _u, useCssModule: Vu, useCssVars: Ku, useSSRContext: Ul, useSlots: mu, useTransitionState: Ys, vModelCheckbox: na, vModelDynamic: th, vModelRadio: sa, vModelSelect: Ql, vModelText: hn, vShow: ih, version: jl, warn: Zc, watch: Qi, watchEffect: bf, watchPostEffect: el, watchSyncEffect: Cf, withAsyncContext: Cu, withCtx: Ws, withDefaults: vu, withDirectives: Af, withKeys: hd, withMemo: wu, withModifiers: od, withScopeId: hf }, Symbol.toStringTag, { value: "Module" })); var pd = Math.PI / 180; function vd() { return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]") } const Si = typeof global < "u" ? global : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {}, X = { _global: Si, version: "8.4.3", isBrowser: vd(), isUnminified: /param/.test(function (e) { }.toString()), dblClickWindow: 400, getAngle(e) { return X.angleDeg ? e * pd : e }, enableTrace: !1, pointerEventsEnabled: !0, autoDrawEnabled: !0, hitOnDragEnabled: !1, capturePointerEventsEnabled: !1, _mouseListenClick: !1, _touchListenClick: !1, _pointerListenClick: !1, _mouseInDblClickWindow: !1, _touchInDblClickWindow: !1, _pointerInDblClickWindow: !1, _mouseDblClickPointerId: null, _touchDblClickPointerId: null, _pointerDblClickPointerId: null, pixelRatio: typeof window < "u" && window.devicePixelRatio || 1, dragDistance: 3, angleDeg: !0, showWarnings: !0, dragButtons: [0, 1], isDragging() { return X.DD.isDragging }, isDragReady() { return !!X.DD.node }, releaseCanvasOnDestroy: !0, document: Si.document, _injectGlobal(e) { Si.Konva = e } }, St = e => { X[e.prototype.getClassName()] = e }; X._injectGlobal(X); class $t { constructor(t = [1, 0, 0, 1, 0, 0]) { this.dirty = !1, this.m = t && t.slice() || [1, 0, 0, 1, 0, 0] } reset() { this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0 } copy() { return new $t(this.m) } copyInto(t) { t.m[0] = this.m[0], t.m[1] = this.m[1], t.m[2] = this.m[2], t.m[3] = this.m[3], t.m[4] = this.m[4], t.m[5] = this.m[5] } point(t) { var i = this.m; return { x: i[0] * t.x + i[2] * t.y + i[4], y: i[1] * t.x + i[3] * t.y + i[5] } } translate(t, i) { return this.m[4] += this.m[0] * t + this.m[2] * i, this.m[5] += this.m[1] * t + this.m[3] * i, this } scale(t, i) { return this.m[0] *= t, this.m[1] *= t, this.m[2] *= i, this.m[3] *= i, this } rotate(t) { var i = Math.cos(t), r = Math.sin(t), n = this.m[0] * i + this.m[2] * r, s = this.m[1] * i + this.m[3] * r, a = this.m[0] * -r + this.m[2] * i, o = this.m[1] * -r + this.m[3] * i; return this.m[0] = n, this.m[1] = s, this.m[2] = a, this.m[3] = o, this } getTranslation() { return { x: this.m[4], y: this.m[5] } } skew(t, i) { var r = this.m[0] + this.m[2] * i, n = this.m[1] + this.m[3] * i, s = this.m[2] + this.m[0] * t, a = this.m[3] + this.m[1] * t; return this.m[0] = r, this.m[1] = n, this.m[2] = s, this.m[3] = a, this } multiply(t) { var i = this.m[0] * t.m[0] + this.m[2] * t.m[1], r = this.m[1] * t.m[0] + this.m[3] * t.m[1], n = this.m[0] * t.m[2] + this.m[2] * t.m[3], s = this.m[1] * t.m[2] + this.m[3] * t.m[3], a = this.m[0] * t.m[4] + this.m[2] * t.m[5] + this.m[4], o = this.m[1] * t.m[4] + this.m[3] * t.m[5] + this.m[5]; return this.m[0] = i, this.m[1] = r, this.m[2] = n, this.m[3] = s, this.m[4] = a, this.m[5] = o, this } invert() { var t = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), i = this.m[3] * t, r = -this.m[1] * t, n = -this.m[2] * t, s = this.m[0] * t, a = t * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), o = t * (this.m[1] * this.m[4] - this.m[0] * this.m[5]); return this.m[0] = i, this.m[1] = r, this.m[2] = n, this.m[3] = s, this.m[4] = a, this.m[5] = o, this } getMatrix() { return this.m } decompose() { var t = this.m[0], i = this.m[1], r = this.m[2], n = this.m[3], s = this.m[4], a = this.m[5], o = t * n - i * r; let l = { x: s, y: a, rotation: 0, scaleX: 0, scaleY: 0, skewX: 0, skewY: 0 }; if (t != 0 || i != 0) { var h = Math.sqrt(t * t + i * i); l.rotation = i > 0 ? Math.acos(t / h) : -Math.acos(t / h), l.scaleX = h, l.scaleY = o / h, l.skewX = (t * r + i * n) / o, l.skewY = 0 } else if (r != 0 || n != 0) { var c = Math.sqrt(r * r + n * n); l.rotation = Math.PI / 2 - (n > 0 ? Math.acos(-r / c) : -Math.acos(r / c)), l.scaleX = o / c, l.scaleY = c, l.skewX = 0, l.skewY = (t * r + i * n) / o } return l.rotation = x._getRotation(l.rotation), l } } var md = "[object Array]", _d = "[object Number]", yd = "[object String]", bd = "[object Boolean]", Cd = Math.PI / 180, Sd = 180 / Math.PI, Wn = "#", wd = "", xd = "0", Ed = "Konva warning: ", Za = "Konva error: ", Td = "rgb(", jn = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 132, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 255, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 203], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [119, 128, 144], slategrey: [119, 128, 144], snow: [255, 255, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], transparent: [255, 255, 255, 0], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 5] }, Pd = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, Nr = []; const Ad = typeof requestAnimationFrame < "u" && requestAnimationFrame || function (e) { setTimeout(e, 60) }, x = { _isElement(e) { return !!(e && e.nodeType == 1) }, _isFunction(e) { return !!(e && e.constructor && e.call && e.apply) }, _isPlainObject(e) { return !!e && e.constructor === Object }, _isArray(e) { return Object.prototype.toString.call(e) === md }, _isNumber(e) { return Object.prototype.toString.call(e) === _d && !isNaN(e) && isFinite(e) }, _isString(e) { return Object.prototype.toString.call(e) === yd }, _isBoolean(e) { return Object.prototype.toString.call(e) === bd }, isObject(e) { return e instanceof Object }, isValidSelector(e) { if (typeof e != "string") return !1; var t = e[0]; return t === "#" || t === "." || t === t.toUpperCase() }, _sign(e) { return e === 0 || e > 0 ? 1 : -1 }, requestAnimFrame(e) { Nr.push(e), Nr.length === 1 && Ad(function () { const t = Nr; Nr = [], t.forEach(function (i) { i() }) }) }, createCanvasElement() { var e = document.createElement("canvas"); try { e.style = e.style || {} } catch { } return e }, createImageElement() { return document.createElement("img") }, _isInDocument(e) { for (; e = e.parentNode;)if (e == document) return !0; return !1 }, _urlToImage(e, t) { var i = x.createImageElement(); i.onload = function () { t(i) }, i.src = e }, _rgbToHex(e, t, i) { return ((1 << 24) + (e << 16) + (t << 8) + i).toString(16).slice(1) }, _hexToRgb(e) { e = e.replace(Wn, wd); var t = parseInt(e, 16); return { r: t >> 16 & 255, g: t >> 8 & 255, b: t & 255 } }, getRandomColor() { for (var e = (Math.random() * 16777215 << 0).toString(16); e.length < 6;)e = xd + e; return Wn + e }, getRGB(e) { var t; return e in jn ? (t = jn[e], { r: t[0], g: t[1], b: t[2] }) : e[0] === Wn ? this._hexToRgb(e.substring(1)) : e.substr(0, 4) === Td ? (t = Pd.exec(e.replace(/ /g, "")), { r: parseInt(t[1], 10), g: parseInt(t[2], 10), b: parseInt(t[3], 10) }) : { r: 0, g: 0, b: 0 } }, colorToRGBA(e) { return e = e || "black", x._namedColorToRBA(e) || x._hex3ColorToRGBA(e) || x._hex4ColorToRGBA(e) || x._hex6ColorToRGBA(e) || x._hex8ColorToRGBA(e) || x._rgbColorToRGBA(e) || x._rgbaColorToRGBA(e) || x._hslColorToRGBA(e) }, _namedColorToRBA(e) { var t = jn[e.toLowerCase()]; return t ? { r: t[0], g: t[1], b: t[2], a: 1 } : null }, _rgbColorToRGBA(e) { if (e.indexOf("rgb(") === 0) { e = e.match(/rgb\(([^)]+)\)/)[1]; var t = e.split(/ *, */).map(Number); return { r: t[0], g: t[1], b: t[2], a: 1 } } }, _rgbaColorToRGBA(e) { if (e.indexOf("rgba(") === 0) { e = e.match(/rgba\(([^)]+)\)/)[1]; var t = e.split(/ *, */).map((i, r) => i.slice(-1) === "%" ? r === 3 ? parseInt(i) / 100 : parseInt(i) / 100 * 255 : Number(i)); return { r: t[0], g: t[1], b: t[2], a: t[3] } } }, _hex8ColorToRGBA(e) { if (e[0] === "#" && e.length === 9) return { r: parseInt(e.slice(1, 3), 16), g: parseInt(e.slice(3, 5), 16), b: parseInt(e.slice(5, 7), 16), a: parseInt(e.slice(7, 9), 16) / 255 } }, _hex6ColorToRGBA(e) { if (e[0] === "#" && e.length === 7) return { r: parseInt(e.slice(1, 3), 16), g: parseInt(e.slice(3, 5), 16), b: parseInt(e.slice(5, 7), 16), a: 1 } }, _hex4ColorToRGBA(e) { if (e[0] === "#" && e.length === 5) return { r: parseInt(e[1] + e[1], 16), g: parseInt(e[2] + e[2], 16), b: parseInt(e[3] + e[3], 16), a: parseInt(e[4] + e[4], 16) / 255 } }, _hex3ColorToRGBA(e) { if (e[0] === "#" && e.length === 4) return { r: parseInt(e[1] + e[1], 16), g: parseInt(e[2] + e[2], 16), b: parseInt(e[3] + e[3], 16), a: 1 } }, _hslColorToRGBA(e) { if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(e)) { const [t, ...i] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e), r = Number(i[0]) / 360, n = Number(i[1]) / 100, s = Number(i[2]) / 100; let a, o, l; if (n === 0) return l = s * 255, { r: Math.round(l), g: Math.round(l), b: Math.round(l), a: 1 }; s < .5 ? a = s * (1 + n) : a = s + n - s * n; const h = 2 * s - a, c = [0, 0, 0]; for (let f = 0; f < 3; f++)o = r + 1 / 3 * -(f - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? l = h + (a - h) * 6 * o : 2 * o < 1 ? l = a : 3 * o < 2 ? l = h + (a - h) * (2 / 3 - o) * 6 : l = h, c[f] = l * 255; return { r: Math.round(c[0]), g: Math.round(c[1]), b: Math.round(c[2]), a: 1 } } }, haveIntersection(e, t) { return !(t.x > e.x + e.width || t.x + t.width < e.x || t.y > e.y + e.height || t.y + t.height < e.y) }, cloneObject(e) { var t = {}; for (var i in e) this._isPlainObject(e[i]) ? t[i] = this.cloneObject(e[i]) : this._isArray(e[i]) ? t[i] = this.cloneArray(e[i]) : t[i] = e[i]; return t }, cloneArray(e) { return e.slice(0) }, degToRad(e) { return e * Cd }, radToDeg(e) { return e * Sd }, _degToRad(e) { return x.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), x.degToRad(e) }, _radToDeg(e) { return x.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), x.radToDeg(e) }, _getRotation(e) { return X.angleDeg ? x.radToDeg(e) : e }, _capitalize(e) { return e.charAt(0).toUpperCase() + e.slice(1) }, throw(e) { throw new Error(Za + e) }, error(e) { console.error(Za + e) }, warn(e) { X.showWarnings && console.warn(Ed + e) }, each(e, t) { for (var i in e) t(i, e[i]) }, _inRange(e, t, i) { return t <= e && e < i }, _getProjectionToSegment(e, t, i, r, n, s) { var a, o, l, h = (e - i) * (e - i) + (t - r) * (t - r); if (h == 0) a = e, o = t, l = (n - i) * (n - i) + (s - r) * (s - r); else { var c = ((n - e) * (i - e) + (s - t) * (r - t)) / h; c < 0 ? (a = e, o = t, l = (e - n) * (e - n) + (t - s) * (t - s)) : c > 1 ? (a = i, o = r, l = (i - n) * (i - n) + (r - s) * (r - s)) : (a = e + c * (i - e), o = t + c * (r - t), l = (a - n) * (a - n) + (o - s) * (o - s)) } return [a, o, l] }, _getProjectionToLine(e, t, i) { var r = x.cloneObject(e), n = Number.MAX_VALUE; return t.forEach(function (s, a) { if (!(!i && a === t.length - 1)) { var o = t[(a + 1) % t.length], l = x._getProjectionToSegment(s.x, s.y, o.x, o.y, e.x, e.y), h = l[0], c = l[1], f = l[2]; f < n && (r.x = h, r.y = c, n = f) } }), r }, _prepareArrayForTween(e, t, i) { var r, n = [], s = []; if (e.length > t.length) { var a = t; t = e, e = a } for (r = 0; r < e.length; r += 2)n.push({ x: e[r], y: e[r + 1] }); for (r = 0; r < t.length; r += 2)s.push({ x: t[r], y: t[r + 1] }); var o = []; return s.forEach(function (l) { var h = x._getProjectionToLine(l, n, i); o.push(h.x), o.push(h.y) }), o }, _prepareToStringify(e) { var t; e.visitedByCircularReferenceRemoval = !0; for (var i in e) if (e.hasOwnProperty(i) && e[i] && typeof e[i] == "object") { if (t = Object.getOwnPropertyDescriptor(e, i), e[i].visitedByCircularReferenceRemoval || x._isElement(e[i])) if (t.configurable) delete e[i]; else return null; else if (x._prepareToStringify(e[i]) === null) if (t.configurable) delete e[i]; else return null } return delete e.visitedByCircularReferenceRemoval, e }, _assign(e, t) { for (var i in t) e[i] = t[i]; return e }, _getFirstPointerId(e) { return e.touches ? e.changedTouches[0].identifier : e.pointerId || 999 }, releaseCanvas(...e) { X.releaseCanvasOnDestroy && e.forEach(t => { t.width = 0, t.height = 0 }) }, drawRoundedRectPath(e, t, i, r) { let n = 0, s = 0, a = 0, o = 0; typeof r == "number" ? n = s = a = o = Math.min(r, t / 2, i / 2) : (n = Math.min(r[0] || 0, t / 2, i / 2), s = Math.min(r[1] || 0, t / 2, i / 2), o = Math.min(r[2] || 0, t / 2, i / 2), a = Math.min(r[3] || 0, t / 2, i / 2)), e.moveTo(n, 0), e.lineTo(t - s, 0), e.arc(t - s, s, s, Math.PI * 3 / 2, 0, !1), e.lineTo(t, i - o), e.arc(t - o, i - o, o, 0, Math.PI / 2, !1), e.lineTo(a, i), e.arc(a, i - a, a, Math.PI / 2, Math.PI, !1), e.lineTo(0, n), e.arc(n, n, n, Math.PI, Math.PI * 3 / 2, !1) } }; function Be(e) { return x._isString(e) ? '"' + e + '"' : Object.prototype.toString.call(e) === "[object Number]" || x._isBoolean(e) ? e : Object.prototype.toString.call(e) } function hh(e) { return e > 255 ? 255 : e < 0 ? 0 : Math.round(e) } function W() { if (X.isUnminified) return function (e, t) { return x._isNumber(e) || x.warn(Be(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number.'), e } } function aa(e) { if (X.isUnminified) return function (t, i) { let r = x._isNumber(t), n = x._isArray(t) && t.length == e; return !r && !n && x.warn(Be(t) + ' is a not valid value for "' + i + '" attribute. The value should be a number or Array<number>(' + e + ")"), t } } function oa() { if (X.isUnminified) return function (e, t) { var i = x._isNumber(e), r = e === "auto"; return i || r || x.warn(Be(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number or "auto".'), e } } function Oi() { if (X.isUnminified) return function (e, t) { return x._isString(e) || x.warn(Be(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string.'), e } } function ch() { if (X.isUnminified) return function (e, t) { const i = x._isString(e), r = Object.prototype.toString.call(e) === "[object CanvasGradient]" || e && e.addColorStop; return i || r || x.warn(Be(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string or a native gradient.'), e } } function kd() { if (X.isUnminified) return function (e, t) { const i = Int8Array ? Object.getPrototypeOf(Int8Array) : null; return i && e instanceof i || (x._isArray(e) ? e.forEach(function (r) { x._isNumber(r) || x.warn('"' + t + '" attribute has non numeric element ' + r + ". Make sure that all elements are numbers.") }) : x.warn(Be(e) + ' is a not valid value for "' + t + '" attribute. The value should be a array of numbers.')), e } } function ae() { if (X.isUnminified) return function (e, t) { var i = e === !0 || e === !1; return i || x.warn(Be(e) + ' is a not valid value for "' + t + '" attribute. The value should be a boolean.'), e } } function Md(e) { if (X.isUnminified) return function (t, i) { return t == null || x.isObject(t) || x.warn(Be(t) + ' is a not valid value for "' + i + '" attribute. The value should be an object with properties ' + e), t } } var Gi = "get", Bi = "set"; const v = { addGetterSetter(e, t, i, r, n) { v.addGetter(e, t, i), v.addSetter(e, t, r, n), v.addOverloadedGetterSetter(e, t) }, addGetter(e, t, i) { var r = Gi + x._capitalize(t); e.prototype[r] = e.prototype[r] || function () { var n = this.attrs[t]; return n === void 0 ? i : n } }, addSetter(e, t, i, r) { var n = Bi + x._capitalize(t); e.prototype[n] || v.overWriteSetter(e, t, i, r) }, overWriteSetter(e, t, i, r) { var n = Bi + x._capitalize(t); e.prototype[n] = function (s) { return i && s !== void 0 && s !== null && (s = i.call(this, s, t)), this._setAttr(t, s), r && r.call(this), this } }, addComponentsGetterSetter(e, t, i, r, n) { var s = i.length, a = x._capitalize, o = Gi + a(t), l = Bi + a(t), h, c; e.prototype[o] = function () { var u = {}; for (h = 0; h < s; h++)c = i[h], u[c] = this.getAttr(t + a(c)); return u }; var f = Md(i); e.prototype[l] = function (u) { var g = this.attrs[t], d; r && (u = r.call(this, u)), f && f.call(this, u, t); for (d in u) u.hasOwnProperty(d) && this._setAttr(t + a(d), u[d]); return u || i.forEach(y => { this._setAttr(t + a(y), void 0) }), this._fireChangeEvent(t, g, u), n && n.call(this), this }, v.addOverloadedGetterSetter(e, t) }, addOverloadedGetterSetter(e, t) { var i = x._capitalize(t), r = Bi + i, n = Gi + i; e.prototype[t] = function () { return arguments.length ? (this[r](arguments[0]), this) : this[n]() } }, addDeprecatedGetterSetter(e, t, i, r) { x.error("Adding deprecated " + t); var n = Gi + x._capitalize(t), s = t + " property is deprecated and will be removed soon. Look at Konva change log for more information."; e.prototype[n] = function () { x.error(s); var a = this.attrs[t]; return a === void 0 ? i : a }, v.addSetter(e, t, r, function () { x.error(s) }), v.addOverloadedGetterSetter(e, t) }, backCompat(e, t) { x.each(t, function (i, r) { var n = e.prototype[r], s = Gi + x._capitalize(i), a = Bi + x._capitalize(i); function o() { n.apply(this, arguments), x.error('"' + i + '" method is deprecated and will be removed soon. Use ""' + r + '" instead.') } e.prototype[i] = o, e.prototype[s] = o, e.prototype[a] = o }) }, afterSetFilter() { this._filterUpToDate = !1 } }; function Rd(e) { var t = [], i = e.length, r = x, n, s; for (n = 0; n < i; n++)s = e[n], r._isNumber(s) ? s = Math.round(s * 1e3) / 1e3 : r._isString(s) || (s = s + ""), t.push(s); return t } var to = ",", Od = "(", Ld = ")", Id = "([", Dd = "])", Nd = ";", Fd = "()", Gd = "=", eo = ["arc", "arcTo", "beginPath", "bezierCurveTo", "clearRect", "clip", "closePath", "createLinearGradient", "createPattern", "createRadialGradient", "drawImage", "ellipse", "fill", "fillText", "getImageData", "createImageData", "lineTo", "moveTo", "putImageData", "quadraticCurveTo", "rect", "restore", "rotate", "save", "scale", "setLineDash", "setTransform", "stroke", "strokeText", "transform", "translate"], Bd = ["fillStyle", "strokeStyle", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "lineCap", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "font", "textAlign", "textBaseline", "globalAlpha", "globalCompositeOperation", "imageSmoothingEnabled"]; const Hd = 100; class Rn { constructor(t) { this.canvas = t, X.enableTrace && (this.traceArr = [], this._enableTrace()) } fillShape(t) { t.fillEnabled() && this._fill(t) } _fill(t) { } strokeShape(t) { t.hasStroke() && this._stroke(t) } _stroke(t) { } fillStrokeShape(t) { t.attrs.fillAfterStrokeEnabled ? (this.strokeShape(t), this.fillShape(t)) : (this.fillShape(t), this.strokeShape(t)) } getTrace(t, i) { var r = this.traceArr, n = r.length, s = "", a, o, l, h; for (a = 0; a < n; a++)o = r[a], l = o.method, l ? (h = o.args, s += l, t ? s += Fd : x._isArray(h[0]) ? s += Id + h.join(to) + Dd : (i && (h = h.map(c => typeof c == "number" ? Math.floor(c) : c)), s += Od + h.join(to) + Ld)) : (s += o.property, t || (s += Gd + o.val)), s += Nd; return s } clearTrace() { this.traceArr = [] } _trace(t) { var i = this.traceArr, r; i.push(t), r = i.length, r >= Hd && i.shift() } reset() { var t = this.getCanvas().getPixelRatio(); this.setTransform(1 * t, 0, 0, 1 * t, 0, 0) } getCanvas() { return this.canvas } clear(t) { var i = this.getCanvas(); t ? this.clearRect(t.x || 0, t.y || 0, t.width || 0, t.height || 0) : this.clearRect(0, 0, i.getWidth() / i.pixelRatio, i.getHeight() / i.pixelRatio) } _applyLineCap(t) { const i = t.attrs.lineCap; i && this.setAttr("lineCap", i) } _applyOpacity(t) { var i = t.getAbsoluteOpacity(); i !== 1 && this.setAttr("globalAlpha", i) } _applyLineJoin(t) { const i = t.attrs.lineJoin; i && this.setAttr("lineJoin", i) } setAttr(t, i) { this._context[t] = i } arc(t, i, r, n, s, a) { this._context.arc(t, i, r, n, s, a) } arcTo(t, i, r, n, s) { this._context.arcTo(t, i, r, n, s) } beginPath() { this._context.beginPath() } bezierCurveTo(t, i, r, n, s, a) { this._context.bezierCurveTo(t, i, r, n, s, a) } clearRect(t, i, r, n) { this._context.clearRect(t, i, r, n) } clip() { this._context.clip() } closePath() { this._context.closePath() } createImageData(t, i) { var r = arguments; if (r.length === 2) return this._context.createImageData(t, i); if (r.length === 1) return this._context.createImageData(t) } createLinearGradient(t, i, r, n) { return this._context.createLinearGradient(t, i, r, n) } createPattern(t, i) { return this._context.createPattern(t, i) } createRadialGradient(t, i, r, n, s, a) { return this._context.createRadialGradient(t, i, r, n, s, a) } drawImage(t, i, r, n, s, a, o, l, h) { var c = arguments, f = this._context; c.length === 3 ? f.drawImage(t, i, r) : c.length === 5 ? f.drawImage(t, i, r, n, s) : c.length === 9 && f.drawImage(t, i, r, n, s, a, o, l, h) } ellipse(t, i, r, n, s, a, o, l) { this._context.ellipse(t, i, r, n, s, a, o, l) } isPointInPath(t, i, r, n) { return r ? this._context.isPointInPath(r, t, i, n) : this._context.isPointInPath(t, i, n) } fill(t) { t ? this._context.fill(t) : this._context.fill() } fillRect(t, i, r, n) { this._context.fillRect(t, i, r, n) } strokeRect(t, i, r, n) { this._context.strokeRect(t, i, r, n) } fillText(t, i, r, n) { n ? this._context.fillText(t, i, r, n) : this._context.fillText(t, i, r) } measureText(t) { return this._context.measureText(t) } getImageData(t, i, r, n) { return this._context.getImageData(t, i, r, n) } lineTo(t, i) { this._context.lineTo(t, i) } moveTo(t, i) { this._context.moveTo(t, i) } rect(t, i, r, n) { this._context.rect(t, i, r, n) } putImageData(t, i, r) { this._context.putImageData(t, i, r) } quadraticCurveTo(t, i, r, n) { this._context.quadraticCurveTo(t, i, r, n) } restore() { this._context.restore() } rotate(t) { this._context.rotate(t) } save() { this._context.save() } scale(t, i) { this._context.scale(t, i) } setLineDash(t) { this._context.setLineDash ? this._context.setLineDash(t) : "mozDash" in this._context ? this._context.mozDash = t : "webkitLineDash" in this._context && (this._context.webkitLineDash = t) } getLineDash() { return this._context.getLineDash() } setTransform(t, i, r, n, s, a) { this._context.setTransform(t, i, r, n, s, a) } stroke(t) { t ? this._context.stroke(t) : this._context.stroke() } strokeText(t, i, r, n) { this._context.strokeText(t, i, r, n) } transform(t, i, r, n, s, a) { this._context.transform(t, i, r, n, s, a) } translate(t, i) { this._context.translate(t, i) } _enableTrace() { var t = this, i = eo.length, r = this.setAttr, n, s, a = function (o) { var l = t[o], h; t[o] = function () { return s = Rd(Array.prototype.slice.call(arguments, 0)), h = l.apply(t, arguments), t._trace({ method: o, args: s }), h } }; for (n = 0; n < i; n++)a(eo[n]); t.setAttr = function () { r.apply(t, arguments); var o = arguments[0], l = arguments[1]; (o === "shadowOffsetX" || o === "shadowOffsetY" || o === "shadowBlur") && (l = l / this.canvas.getPixelRatio()), t._trace({ property: o, val: l }) } } _applyGlobalCompositeOperation(t) { const i = t.attrs.globalCompositeOperation; var r = !i || i === "source-over"; r || this.setAttr("globalCompositeOperation", i) } } Bd.forEach(function (e) { Object.defineProperty(Rn.prototype, e, { get() { return this._context[e] }, set(t) { this._context[e] = t } }) }); class Ud extends Rn { constructor(t) { super(t), this._context = t._canvas.getContext("2d") } _fillColor(t) { var i = t.fill(); this.setAttr("fillStyle", i), t._fillFunc(this) } _fillPattern(t) { this.setAttr("fillStyle", t._getFillPattern()), t._fillFunc(this) } _fillLinearGradient(t) { var i = t._getLinearGradient(); i && (this.setAttr("fillStyle", i), t._fillFunc(this)) } _fillRadialGradient(t) { const i = t._getRadialGradient(); i && (this.setAttr("fillStyle", i), t._fillFunc(this)) } _fill(t) { const i = t.fill(), r = t.getFillPriority(); if (i && r === "color") { this._fillColor(t); return } const n = t.getFillPatternImage(); if (n && r === "pattern") { this._fillPattern(t); return } const s = t.getFillLinearGradientColorStops(); if (s && r === "linear-gradient") { this._fillLinearGradient(t); return } const a = t.getFillRadialGradientColorStops(); if (a && r === "radial-gradient") { this._fillRadialGradient(t); return } i ? this._fillColor(t) : n ? this._fillPattern(t) : s ? this._fillLinearGradient(t) : a && this._fillRadialGradient(t) } _strokeLinearGradient(t) { const i = t.getStrokeLinearGradientStartPoint(), r = t.getStrokeLinearGradientEndPoint(), n = t.getStrokeLinearGradientColorStops(), s = this.createLinearGradient(i.x, i.y, r.x, r.y); if (n) { for (var a = 0; a < n.length; a += 2)s.addColorStop(n[a], n[a + 1]); this.setAttr("strokeStyle", s) } } _stroke(t) { var i = t.dash(), r = t.getStrokeScaleEnabled(); if (t.hasStroke()) { if (!r) { this.save(); var n = this.getCanvas().getPixelRatio(); this.setTransform(n, 0, 0, n, 0, 0) } this._applyLineCap(t), i && t.dashEnabled() && (this.setLineDash(i), this.setAttr("lineDashOffset", t.dashOffset())), this.setAttr("lineWidth", t.strokeWidth()), t.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)"); var s = t.getStrokeLinearGradientColorStops(); s ? this._strokeLinearGradient(t) : this.setAttr("strokeStyle", t.stroke()), t._strokeFunc(this), r || this.restore() } } _applyShadow(t) { var i, r, n, s = (i = t.getShadowRGBA()) !== null && i !== void 0 ? i : "black", a = (r = t.getShadowBlur()) !== null && r !== void 0 ? r : 5, o = (n = t.getShadowOffset()) !== null && n !== void 0 ? n : { x: 0, y: 0 }, l = t.getAbsoluteScale(), h = this.canvas.getPixelRatio(), c = l.x * h, f = l.y * h; this.setAttr("shadowColor", s), this.setAttr("shadowBlur", a * Math.min(Math.abs(c), Math.abs(f))), this.setAttr("shadowOffsetX", o.x * c), this.setAttr("shadowOffsetY", o.y * f) } } class Wd extends Rn { constructor(t) { super(t), this._context = t._canvas.getContext("2d", { willReadFrequently: !0 }) } _fill(t) { this.save(), this.setAttr("fillStyle", t.colorKey), t._fillFuncHit(this), this.restore() } strokeShape(t) { t.hasHitStroke() && this._stroke(t) } _stroke(t) { if (t.hasHitStroke()) { const s = t.getStrokeScaleEnabled(); if (!s) { this.save(); var i = this.getCanvas().getPixelRatio(); this.setTransform(i, 0, 0, i, 0, 0) } this._applyLineCap(t); var r = t.hitStrokeWidth(), n = r === "auto" ? t.strokeWidth() : r; this.setAttr("lineWidth", n), this.setAttr("strokeStyle", t.colorKey), t._strokeFuncHit(this), s || this.restore() } } } var Fr; function jd() { if (Fr) return Fr; var e = x.createCanvasElement(), t = e.getContext("2d"); return Fr = function () { var i = X._global.devicePixelRatio || 1, r = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1; return i / r }(), x.releaseCanvas(e), Fr } class On { constructor(t) { this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1; var i = t || {}, r = i.pixelRatio || X.pixelRatio || jd(); this.pixelRatio = r, this._canvas = x.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0" } getContext() { return this.context } getPixelRatio() { return this.pixelRatio } setPixelRatio(t) { var i = this.pixelRatio; this.pixelRatio = t, this.setSize(this.getWidth() / i, this.getHeight() / i) } setWidth(t) { this.width = this._canvas.width = t * this.pixelRatio, this._canvas.style.width = t + "px"; var i = this.pixelRatio, r = this.getContext()._context; r.scale(i, i) } setHeight(t) { this.height = this._canvas.height = t * this.pixelRatio, this._canvas.style.height = t + "px"; var i = this.pixelRatio, r = this.getContext()._context; r.scale(i, i) } getWidth() { return this.width } getHeight() { return this.height } setSize(t, i) { this.setWidth(t || 0), this.setHeight(i || 0) } toDataURL(t, i) { try { return this._canvas.toDataURL(t, i) } catch { try { return this._canvas.toDataURL() } catch (n) { return x.error("Unable to get data URL. " + n.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), "" } } } } v.addGetterSetter(On, "pixelRatio", void 0, W()); class wi extends On { constructor(t = { width: 0, height: 0 }) { super(t), this.context = new Ud(this), this.setSize(t.width, t.height) } } class la extends On { constructor(t = { width: 0, height: 0 }) { super(t), this.hitCanvas = !0, this.context = new Wd(this), this.setSize(t.width, t.height) } } const ct = { get isDragging() { var e = !1; return ct._dragElements.forEach(t => { t.dragStatus === "dragging" && (e = !0) }), e }, justDragged: !1, get node() { var e; return ct._dragElements.forEach(t => { e = t.node }), e }, _dragElements: new Map, _drag(e) { const t = []; ct._dragElements.forEach((i, r) => { const { node: n } = i, s = n.getStage(); s.setPointersPositions(e), i.pointerId === void 0 && (i.pointerId = x._getFirstPointerId(e)); const a = s._changedPointerPositions.find(h => h.id === i.pointerId); if (a) { if (i.dragStatus !== "dragging") { var o = n.dragDistance(), l = Math.max(Math.abs(a.x - i.startPointerPos.x), Math.abs(a.y - i.startPointerPos.y)); if (l < o || (n.startDrag({ evt: e }), !n.isDragging())) return } n._setDragPosition(e, i), t.push(n) } }), t.forEach(i => { i.fire("dragmove", { type: "dragmove", target: i, evt: e }, !0) }) }, _endDragBefore(e) { const t = []; ct._dragElements.forEach(i => { const { node: r } = i, n = r.getStage(); if (e && n.setPointersPositions(e), !n._changedPointerPositions.find(o => o.id === i.pointerId)) return; (i.dragStatus === "dragging" || i.dragStatus === "stopped") && (ct.justDragged = !0, X._mouseListenClick = !1, X._touchListenClick = !1, X._pointerListenClick = !1, i.dragStatus = "stopped"); const a = i.node.getLayer() || i.node instanceof X.Stage && i.node; a && t.indexOf(a) === -1 && t.push(a) }), t.forEach(i => { i.draw() }) }, _endDragAfter(e) { ct._dragElements.forEach((t, i) => { t.dragStatus === "stopped" && t.node.fire("dragend", { type: "dragend", target: t.node, evt: e }, !0), t.dragStatus !== "dragging" && ct._dragElements.delete(i) }) } }; X.isBrowser && (window.addEventListener("mouseup", ct._endDragBefore, !0), window.addEventListener("touchend", ct._endDragBefore, !0), window.addEventListener("mousemove", ct._drag), window.addEventListener("touchmove", ct._drag), window.addEventListener("mouseup", ct._endDragAfter, !1), window.addEventListener("touchend", ct._endDragAfter, !1)); var Jr = "absoluteOpacity", Gr = "allEventListeners", pe = "absoluteTransform", io = "absoluteScale", ze = "canvas", zd = "Change", Yd = "children", Vd = "konva", vs = "listening", ro = "mouseenter", no = "mouseleave", so = "set", ao = "Shape", Qr = " ", oo = "stage", ke = "transform", Kd = "Stage", ms = "visible", Xd = ["xChange.konva", "yChange.konva", "scaleXChange.konva", "scaleYChange.konva", "skewXChange.konva", "skewYChange.konva", "rotationChange.konva", "offsetXChange.konva", "offsetYChange.konva", "transformsEnabledChange.konva"].join(Qr); let $d = 1; class U { constructor(t) { this._id = $d++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = new Map, this._attachedDepsListeners = new Map, this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(t), this._shouldFireChangeEvents = !0 } hasChildren() { return !1 } _clearCache(t) { (t === ke || t === pe) && this._cache.get(t) ? this._cache.get(t).dirty = !0 : t ? this._cache.delete(t) : this._cache.clear() } _getCache(t, i) { var r = this._cache.get(t), n = t === ke || t === pe, s = r === void 0 || n && r.dirty === !0; return s && (r = i.call(this), this._cache.set(t, r)), r } _calculate(t, i, r) { if (!this._attachedDepsListeners.get(t)) { const n = i.map(s => s + "Change.konva").join(Qr); this.on(n, () => { this._clearCache(t) }), this._attachedDepsListeners.set(t, !0) } return this._getCache(t, r) } _getCanvasCache() { return this._cache.get(ze) } _clearSelfAndDescendantCache(t) { this._clearCache(t), t === pe && this.fire("absoluteTransformChange") } clearCache() { if (this._cache.has(ze)) { const { scene: t, filter: i, hit: r } = this._cache.get(ze); x.releaseCanvas(t, i, r), this._cache.delete(ze) } return this._clearSelfAndDescendantCache(), this._requestDraw(), this } cache(t) { var i = t || {}, r = {}; (i.x === void 0 || i.y === void 0 || i.width === void 0 || i.height === void 0) && (r = this.getClientRect({ skipTransform: !0, relativeTo: this.getParent() })); var n = Math.ceil(i.width || r.width), s = Math.ceil(i.height || r.height), a = i.pixelRatio, o = i.x === void 0 ? Math.floor(r.x) : i.x, l = i.y === void 0 ? Math.floor(r.y) : i.y, h = i.offset || 0, c = i.drawBorder || !1, f = i.hitCanvasPixelRatio || 1; if (!n || !s) { x.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped."); return } n += h * 2 + 1, s += h * 2 + 1, o -= h, l -= h; var u = new wi({ pixelRatio: a, width: n, height: s }), g = new wi({ pixelRatio: a, width: 0, height: 0 }), d = new la({ pixelRatio: f, width: n, height: s }), y = u.getContext(), C = d.getContext(); return d.isCache = !0, u.isCache = !0, this._cache.delete(ze), this._filterUpToDate = !1, i.imageSmoothingEnabled === !1 && (u.getContext()._context.imageSmoothingEnabled = !1, g.getContext()._context.imageSmoothingEnabled = !1), y.save(), C.save(), y.translate(-o, -l), C.translate(-o, -l), this._isUnderCache = !0, this._clearSelfAndDescendantCache(Jr), this._clearSelfAndDescendantCache(io), this.drawScene(u, this), this.drawHit(d, this), this._isUnderCache = !1, y.restore(), C.restore(), c && (y.save(), y.beginPath(), y.rect(0, 0, n, s), y.closePath(), y.setAttr("strokeStyle", "red"), y.setAttr("lineWidth", 5), y.stroke(), y.restore()), this._cache.set(ze, { scene: u, filter: g, hit: d, x: o, y: l }), this._requestDraw(), this } isCached() { return this._cache.has(ze) } getClientRect(t) { throw new Error('abstract "getClientRect" method call') } _transformedRect(t, i) { var r = [{ x: t.x, y: t.y }, { x: t.x + t.width, y: t.y }, { x: t.x + t.width, y: t.y + t.height }, { x: t.x, y: t.y + t.height }], n, s, a, o, l = this.getAbsoluteTransform(i); return r.forEach(function (h) { var c = l.point(h); n === void 0 && (n = a = c.x, s = o = c.y), n = Math.min(n, c.x), s = Math.min(s, c.y), a = Math.max(a, c.x), o = Math.max(o, c.y) }), { x: n, y: s, width: a - n, height: o - s } } _drawCachedSceneCanvas(t) { t.save(), t._applyOpacity(this), t._applyGlobalCompositeOperation(this); const i = this._getCanvasCache(); t.translate(i.x, i.y); var r = this._getCachedSceneCanvas(), n = r.pixelRatio; t.drawImage(r._canvas, 0, 0, r.width / n, r.height / n), t.restore() } _drawCachedHitCanvas(t) { var i = this._getCanvasCache(), r = i.hit; t.save(), t.translate(i.x, i.y), t.drawImage(r._canvas, 0, 0, r.width / r.pixelRatio, r.height / r.pixelRatio), t.restore() } _getCachedSceneCanvas() { var t = this.filters(), i = this._getCanvasCache(), r = i.scene, n = i.filter, s = n.getContext(), a, o, l, h; if (t) { if (!this._filterUpToDate) { var c = r.pixelRatio; n.setSize(r.width / r.pixelRatio, r.height / r.pixelRatio); try { for (a = t.length, s.clear(), s.drawImage(r._canvas, 0, 0, r.getWidth() / c, r.getHeight() / c), o = s.getImageData(0, 0, n.getWidth(), n.getHeight()), l = 0; l < a; l++) { if (h = t[l], typeof h != "function") { x.error("Filter should be type of function, but got " + typeof h + " instead. Please check correct filters"); continue } h.call(this, o), s.putImageData(o, 0, 0) } } catch (f) { x.error("Unable to apply filter. " + f.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.") } this._filterUpToDate = !0 } return n } return r } on(t, i) { if (this._cache && this._cache.delete(Gr), arguments.length === 3) return this._delegate.apply(this, arguments); var r = t.split(Qr), n = r.length, s, a, o, l, h; for (s = 0; s < n; s++)a = r[s], o = a.split("."), l = o[0], h = o[1] || "", this.eventListeners[l] || (this.eventListeners[l] = []), this.eventListeners[l].push({ name: h, handler: i }); return this } off(t, i) { var r = (t || "").split(Qr), n = r.length, s, a, o, l, h, c; if (this._cache && this._cache.delete(Gr), !t) for (a in this.eventListeners) this._off(a); for (s = 0; s < n; s++)if (o = r[s], l = o.split("."), h = l[0], c = l[1], h) this.eventListeners[h] && this._off(h, c, i); else for (a in this.eventListeners) this._off(a, c, i); return this } dispatchEvent(t) { var i = { target: this, type: t.type, evt: t }; return this.fire(t.type, i), this } addEventListener(t, i) { return this.on(t, function (r) { i.call(this, r.evt) }), this } removeEventListener(t) { return this.off(t), this } _delegate(t, i, r) { var n = this; this.on(t, function (s) { for (var a = s.target.findAncestors(i, !0, n), o = 0; o < a.length; o++)s = x.cloneObject(s), s.currentTarget = a[o], r.call(a[o], s) }) } remove() { return this.isDragging() && this.stopDrag(), ct._dragElements.delete(this._id), this._remove(), this } _clearCaches() { this._clearSelfAndDescendantCache(pe), this._clearSelfAndDescendantCache(Jr), this._clearSelfAndDescendantCache(io), this._clearSelfAndDescendantCache(oo), this._clearSelfAndDescendantCache(ms), this._clearSelfAndDescendantCache(vs) } _remove() { this._clearCaches(); var t = this.getParent(); t && t.children && (t.children.splice(this.index, 1), t._setChildrenIndices(), this.parent = null) } destroy() { return this.remove(), this.clearCache(), this } getAttr(t) { var i = "get" + x._capitalize(t); return x._isFunction(this[i]) ? this[i]() : this.attrs[t] } getAncestors() { for (var t = this.getParent(), i = []; t;)i.push(t), t = t.getParent(); return i } getAttrs() { return this.attrs || {} } setAttrs(t) { return this._batchTransformChanges(() => { var i, r; if (!t) return this; for (i in t) i !== Yd && (r = so + x._capitalize(i), x._isFunction(this[r]) ? this[r](t[i]) : this._setAttr(i, t[i])) }), this } isListening() { return this._getCache(vs, this._isListening) } _isListening(t) { if (!this.listening()) return !1; const r = this.getParent(); return r && r !== t && this !== t ? r._isListening(t) : !0 } isVisible() { return this._getCache(ms, this._isVisible) } _isVisible(t) { if (!this.visible()) return !1; const r = this.getParent(); return r && r !== t && this !== t ? r._isVisible(t) : !0 } shouldDrawHit(t, i = !1) { if (t) return this._isVisible(t) && this._isListening(t); var r = this.getLayer(), n = !1; ct._dragElements.forEach(a => { a.dragStatus === "dragging" && (a.node.nodeType === "Stage" || a.node.getLayer() === r) && (n = !0) }); var s = !i && !X.hitOnDragEnabled && n; return this.isListening() && this.isVisible() && !s } show() { return this.visible(!0), this } hide() { return this.visible(!1), this } getZIndex() { return this.index || 0 } getAbsoluteZIndex() { var t = this.getDepth(), i = this, r = 0, n, s, a, o; function l(h) { for (n = [], s = h.length, a = 0; a < s; a++)o = h[a], r++, o.nodeType !== ao && (n = n.concat(o.getChildren().slice())), o._id === i._id && (a = s); n.length > 0 && n[0].getDepth() <= t && l(n) } return i.nodeType !== Kd && l(i.getStage().getChildren()), r } getDepth() { for (var t = 0, i = this.parent; i;)t++, i = i.parent; return t } _batchTransformChanges(t) { this._batchingTransformChange = !0, t(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(ke), this._clearSelfAndDescendantCache(pe)), this._needClearTransformCache = !1 } setPosition(t) { return this._batchTransformChanges(() => { this.x(t.x), this.y(t.y) }), this } getPosition() { return { x: this.x(), y: this.y() } } getRelativePointerPosition() { if (!this.getStage()) return null; var t = this.getStage().getPointerPosition(); if (!t) return null; var i = this.getAbsoluteTransform().copy(); return i.invert(), i.point(t) } getAbsolutePosition(t) { let i = !1, r = this.parent; for (; r;) { if (r.isCached()) { i = !0; break } r = r.parent } i && !t && (t = !0); var n = this.getAbsoluteTransform(t).getMatrix(), s = new $t, a = this.offset(); return s.m = n.slice(), s.translate(a.x, a.y), s.getTranslation() } setAbsolutePosition(t) { var i = this._clearTransform(); this.attrs.x = i.x, this.attrs.y = i.y, delete i.x, delete i.y, this._clearCache(ke); var r = this._getAbsoluteTransform().copy(); return r.invert(), r.translate(t.x, t.y), t = { x: this.attrs.x + r.getTranslation().x, y: this.attrs.y + r.getTranslation().y }, this._setTransform(i), this.setPosition({ x: t.x, y: t.y }), this._clearCache(ke), this._clearSelfAndDescendantCache(pe), this } _setTransform(t) { var i; for (i in t) this.attrs[i] = t[i] } _clearTransform() { var t = { x: this.x(), y: this.y(), rotation: this.rotation(), scaleX: this.scaleX(), scaleY: this.scaleY(), offsetX: this.offsetX(), offsetY: this.offsetY(), skewX: this.skewX(), skewY: this.skewY() }; return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, t } move(t) { var i = t.x, r = t.y, n = this.x(), s = this.y(); return i !== void 0 && (n += i), r !== void 0 && (s += r), this.setPosition({ x: n, y: s }), this } _eachAncestorReverse(t, i) { var r = [], n = this.getParent(), s, a; if (!(i && i._id === this._id)) { for (r.unshift(this); n && (!i || n._id !== i._id);)r.unshift(n), n = n.parent; for (s = r.length, a = 0; a < s; a++)t(r[a]) } } rotate(t) { return this.rotation(this.rotation() + t), this } moveToTop() { if (!this.parent) return x.warn("Node has no parent. moveToTop function is ignored."), !1; var t = this.index, i = this.parent.getChildren().length; return t < i - 1 ? (this.parent.children.splice(t, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1 } moveUp() { if (!this.parent) return x.warn("Node has no parent. moveUp function is ignored."), !1; var t = this.index, i = this.parent.getChildren().length; return t < i - 1 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1 } moveDown() { if (!this.parent) return x.warn("Node has no parent. moveDown function is ignored."), !1; var t = this.index; return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1 } moveToBottom() { if (!this.parent) return x.warn("Node has no parent. moveToBottom function is ignored."), !1; var t = this.index; return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1 } setZIndex(t) { if (!this.parent) return x.warn("Node has no parent. zIndex parameter is ignored."), this; (t < 0 || t >= this.parent.children.length) && x.warn("Unexpected value " + t + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + "."); var i = this.index; return this.parent.children.splice(i, 1), this.parent.children.splice(t, 0, this), this.parent._setChildrenIndices(), this } getAbsoluteOpacity() { return this._getCache(Jr, this._getAbsoluteOpacity) } _getAbsoluteOpacity() { var t = this.opacity(), i = this.getParent(); return i && !i._isUnderCache && (t *= i.getAbsoluteOpacity()), t } moveTo(t) { return this.getParent() !== t && (this._remove(), t.add(this)), this } toObject() { var t = {}, i = this.getAttrs(), r, n, s, a, o; t.attrs = {}; for (r in i) n = i[r], o = x.isObject(n) && !x._isPlainObject(n) && !x._isArray(n), !o && (s = typeof this[r] == "function" && this[r], delete i[r], a = s ? s.call(this) : null, i[r] = n, a !== n && (t.attrs[r] = n)); return t.className = this.getClassName(), x._prepareToStringify(t) } toJSON() { return JSON.stringify(this.toObject()) } getParent() { return this.parent } findAncestors(t, i, r) { var n = []; i && this._isMatch(t) && n.push(this); for (var s = this.parent; s;) { if (s === r) return n; s._isMatch(t) && n.push(s), s = s.parent } return n } isAncestorOf(t) { return !1 } findAncestor(t, i, r) { return this.findAncestors(t, i, r)[0] } _isMatch(t) { if (!t) return !1; if (typeof t == "function") return t(this); var i = t.replace(/ /g, "").split(","), r = i.length, n, s; for (n = 0; n < r; n++)if (s = i[n], x.isValidSelector(s) || (x.warn('Selector "' + s + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), x.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), x.warn("Konva is awesome, right?")), s.charAt(0) === "#") { if (this.id() === s.slice(1)) return !0 } else if (s.charAt(0) === ".") { if (this.hasName(s.slice(1))) return !0 } else if (this.className === s || this.nodeType === s) return !0; return !1 } getLayer() { var t = this.getParent(); return t ? t.getLayer() : null } getStage() { return this._getCache(oo, this._getStage) } _getStage() { var t = this.getParent(); if (t) return t.getStage() } fire(t, i = {}, r) { return i.target = i.target || this, r ? this._fireAndBubble(t, i) : this._fire(t, i), this } getAbsoluteTransform(t) { return t ? this._getAbsoluteTransform(t) : this._getCache(pe, this._getAbsoluteTransform) } _getAbsoluteTransform(t) { var i; if (t) return i = new $t, this._eachAncestorReverse(function (n) { var s = n.transformsEnabled(); s === "all" ? i.multiply(n.getTransform()) : s === "position" && i.translate(n.x() - n.offsetX(), n.y() - n.offsetY()) }, t), i; i = this._cache.get(pe) || new $t, this.parent ? this.parent.getAbsoluteTransform().copyInto(i) : i.reset(); var r = this.transformsEnabled(); if (r === "all") i.multiply(this.getTransform()); else if (r === "position") { const n = this.attrs.x || 0, s = this.attrs.y || 0, a = this.attrs.offsetX || 0, o = this.attrs.offsetY || 0; i.translate(n - a, s - o) } return i.dirty = !1, i } getAbsoluteScale(t) { for (var i = this; i;)i._isUnderCache && (t = i), i = i.getParent(); const n = this.getAbsoluteTransform(t).decompose(); return { x: n.scaleX, y: n.scaleY } } getAbsoluteRotation() { return this.getAbsoluteTransform().decompose().rotation } getTransform() { return this._getCache(ke, this._getTransform) } _getTransform() { var t, i, r = this._cache.get(ke) || new $t; r.reset(); var n = this.x(), s = this.y(), a = X.getAngle(this.rotation()), o = (t = this.attrs.scaleX) !== null && t !== void 0 ? t : 1, l = (i = this.attrs.scaleY) !== null && i !== void 0 ? i : 1, h = this.attrs.skewX || 0, c = this.attrs.skewY || 0, f = this.attrs.offsetX || 0, u = this.attrs.offsetY || 0; return (n !== 0 || s !== 0) && r.translate(n, s), a !== 0 && r.rotate(a), (h !== 0 || c !== 0) && r.skew(h, c), (o !== 1 || l !== 1) && r.scale(o, l), (f !== 0 || u !== 0) && r.translate(-1 * f, -1 * u), r.dirty = !1, r } clone(t) { var i = x.cloneObject(this.attrs), r, n, s, a, o; for (r in t) i[r] = t[r]; var l = new this.constructor(i); for (r in this.eventListeners) for (n = this.eventListeners[r], s = n.length, a = 0; a < s; a++)o = n[a], o.name.indexOf(Vd) < 0 && (l.eventListeners[r] || (l.eventListeners[r] = []), l.eventListeners[r].push(o)); return l } _toKonvaCanvas(t) { t = t || {}; var i = this.getClientRect(), r = this.getStage(), n = t.x !== void 0 ? t.x : Math.floor(i.x), s = t.y !== void 0 ? t.y : Math.floor(i.y), a = t.pixelRatio || 1, o = new wi({ width: t.width || Math.ceil(i.width) || (r ? r.width() : 0), height: t.height || Math.ceil(i.height) || (r ? r.height() : 0), pixelRatio: a }), l = o.getContext(); return t.imageSmoothingEnabled === !1 && (l._context.imageSmoothingEnabled = !1), l.save(), (n || s) && l.translate(-1 * n, -1 * s), this.drawScene(o), l.restore(), o } toCanvas(t) { return this._toKonvaCanvas(t)._canvas } toDataURL(t) { t = t || {}; var i = t.mimeType || null, r = t.quality || null, n = this._toKonvaCanvas(t).toDataURL(i, r); return t.callback && t.callback(n), n } toImage(t) { return new Promise((i, r) => { try { const n = t == null ? void 0 : t.callback; n && delete t.callback, x._urlToImage(this.toDataURL(t), function (s) { i(s), n == null || n(s) }) } catch (n) { r(n) } }) } toBlob(t) { return new Promise((i, r) => { try { const n = t == null ? void 0 : t.callback; n && delete t.callback, this.toCanvas(t).toBlob(s => { i(s), n == null || n(s) }) } catch (n) { r(n) } }) } setSize(t) { return this.width(t.width), this.height(t.height), this } getSize() { return { width: this.width(), height: this.height() } } getClassName() { return this.className || this.nodeType } getType() { return this.nodeType } getDragDistance() { return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : X.dragDistance } _off(t, i, r) { var n = this.eventListeners[t], s, a, o; for (s = 0; s < n.length; s++)if (a = n[s].name, o = n[s].handler, (a !== "konva" || i === "konva") && (!i || a === i) && (!r || r === o)) { if (n.splice(s, 1), n.length === 0) { delete this.eventListeners[t]; break } s-- } } _fireChangeEvent(t, i, r) { this._fire(t + zd, { oldVal: i, newVal: r }) } addName(t) { if (!this.hasName(t)) { var i = this.name(), r = i ? i + " " + t : t; this.name(r) } return this } hasName(t) { if (!t) return !1; const i = this.name(); if (!i) return !1; var r = (i || "").split(/\s/g); return r.indexOf(t) !== -1 } removeName(t) { var i = (this.name() || "").split(/\s/g), r = i.indexOf(t); return r !== -1 && (i.splice(r, 1), this.name(i.join(" "))), this } setAttr(t, i) { var r = this[so + x._capitalize(t)]; return x._isFunction(r) ? r.call(this, i) : this._setAttr(t, i), this } _requestDraw() { if (X.autoDrawEnabled) { const t = this.getLayer() || this.getStage(); t == null || t.batchDraw() } } _setAttr(t, i) { var r = this.attrs[t]; r === i && !x.isObject(i) || (i == null ? delete this.attrs[t] : this.attrs[t] = i, this._shouldFireChangeEvents && this._fireChangeEvent(t, r, i), this._requestDraw()) } _setComponentAttr(t, i, r) { var n; r !== void 0 && (n = this.attrs[t], n || (this.attrs[t] = this.getAttr(t)), this.attrs[t][i] = r, this._fireChangeEvent(t, n, r)) } _fireAndBubble(t, i, r) { i && this.nodeType === ao && (i.target = this); var n = (t === ro || t === no) && (r && (this === r || this.isAncestorOf && this.isAncestorOf(r)) || this.nodeType === "Stage" && !r); if (!n) { this._fire(t, i); var s = (t === ro || t === no) && r && r.isAncestorOf && r.isAncestorOf(this) && !r.isAncestorOf(this.parent); (i && !i.cancelBubble || !i) && this.parent && this.parent.isListening() && !s && (r && r.parent ? this._fireAndBubble.call(this.parent, t, i, r) : this._fireAndBubble.call(this.parent, t, i)) } } _getProtoListeners(t) { let i = this._cache.get(Gr); if (!i) { i = {}; let n = Object.getPrototypeOf(this); for (; n;) { if (!n.eventListeners) { n = Object.getPrototypeOf(n); continue } for (var r in n.eventListeners) { const s = n.eventListeners[r], a = i[r] || []; i[r] = s.concat(a) } n = Object.getPrototypeOf(n) } this._cache.set(Gr, i) } return i[t] } _fire(t, i) { i = i || {}, i.currentTarget = this, i.type = t; const r = this._getProtoListeners(t); if (r) for (var n = 0; n < r.length; n++)r[n].handler.call(this, i); const s = this.eventListeners[t]; if (s) for (var n = 0; n < s.length; n++)s[n].handler.call(this, i) } draw() { return this.drawScene(), this.drawHit(), this } _createDragElement(t) { var i = t ? t.pointerId : void 0, r = this.getStage(), n = this.getAbsolutePosition(), s = r._getPointerById(i) || r._changedPointerPositions[0] || n; ct._dragElements.set(this._id, { node: this, startPointerPos: s, offset: { x: s.x - n.x, y: s.y - n.y }, dragStatus: "ready", pointerId: i }) } startDrag(t, i = !0) { ct._dragElements.has(this._id) || this._createDragElement(t); const r = ct._dragElements.get(this._id); r.dragStatus = "dragging", this.fire("dragstart", { type: "dragstart", target: this, evt: t && t.evt }, i) } _setDragPosition(t, i) { const r = this.getStage()._getPointerById(i.pointerId); if (r) { var n = { x: r.x - i.offset.x, y: r.y - i.offset.y }, s = this.dragBoundFunc(); if (s !== void 0) { const a = s.call(this, n, t); a ? n = a : x.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.") } (!this._lastPos || this._lastPos.x !== n.x || this._lastPos.y !== n.y) && (this.setAbsolutePosition(n), this._requestDraw()), this._lastPos = n } } stopDrag(t) { const i = ct._dragElements.get(this._id); i && (i.dragStatus = "stopped"), ct._endDragBefore(t), ct._endDragAfter(t) } setDraggable(t) { this._setAttr("draggable", t), this._dragChange() } isDragging() { const t = ct._dragElements.get(this._id); return t ? t.dragStatus === "dragging" : !1 } _listenDrag() { this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function (t) { var i = t.evt.button !== void 0, r = !i || X.dragButtons.indexOf(t.evt.button) >= 0; if (r && !this.isDragging()) { var n = !1; ct._dragElements.forEach(s => { this.isAncestorOf(s.node) && (n = !0) }), n || this._createDragElement(t) } }) } _dragChange() { if (this.attrs.draggable) this._listenDrag(); else { this._dragCleanup(); var t = this.getStage(); if (!t) return; const i = ct._dragElements.get(this._id), r = i && i.dragStatus === "dragging", n = i && i.dragStatus === "ready"; r ? this.stopDrag() : n && ct._dragElements.delete(this._id) } } _dragCleanup() { this.off("mousedown.konva"), this.off("touchstart.konva") } isClientRectOnScreen(t = { x: 0, y: 0 }) { const i = this.getStage(); if (!i) return !1; const r = { x: -t.x, y: -t.y, width: i.width() + 2 * t.x, height: i.height() + 2 * t.y }; return x.haveIntersection(r, this.getClientRect()) } static create(t, i) { return x._isString(t) && (t = JSON.parse(t)), this._createNode(t, i) } static _createNode(t, i) { var r = U.prototype.getClassName.call(t), n = t.children, s, a, o; i && (t.attrs.container = i), X[r] || (x.warn('Can not find a node with class name "' + r + '". Fallback to "Shape".'), r = "Shape"); const l = X[r]; if (s = new l(t.attrs), n) for (a = n.length, o = 0; o < a; o++)s.add(U._createNode(n[o])); return s } } U.prototype.nodeType = "Node"; U.prototype._attrsAffectingSize = []; U.prototype.eventListeners = {}; U.prototype.on.call(U.prototype, Xd, function () { if (this._batchingTransformChange) { this._needClearTransformCache = !0; return } this._clearCache(ke), this._clearSelfAndDescendantCache(pe) }); U.prototype.on.call(U.prototype, "visibleChange.konva", function () { this._clearSelfAndDescendantCache(ms) }); U.prototype.on.call(U.prototype, "listeningChange.konva", function () { this._clearSelfAndDescendantCache(vs) }); U.prototype.on.call(U.prototype, "opacityChange.konva", function () { this._clearSelfAndDescendantCache(Jr) }); const mt = v.addGetterSetter; mt(U, "zIndex"); mt(U, "absolutePosition"); mt(U, "position"); mt(U, "x", 0, W()); mt(U, "y", 0, W()); mt(U, "globalCompositeOperation", "source-over", Oi()); mt(U, "opacity", 1, W()); mt(U, "name", "", Oi()); mt(U, "id", "", Oi()); mt(U, "rotation", 0, W()); v.addComponentsGetterSetter(U, "scale", ["x", "y"]); mt(U, "scaleX", 1, W()); mt(U, "scaleY", 1, W()); v.addComponentsGetterSetter(U, "skew", ["x", "y"]); mt(U, "skewX", 0, W()); mt(U, "skewY", 0, W()); v.addComponentsGetterSetter(U, "offset", ["x", "y"]); mt(U, "offsetX", 0, W()); mt(U, "offsetY", 0, W()); mt(U, "dragDistance", null, W()); mt(U, "width", 0, W()); mt(U, "height", 0, W()); mt(U, "listening", !0, ae()); mt(U, "preventDefault", !0, ae()); mt(U, "filters", null, function (e) { return this._filterUpToDate = !1, e }); mt(U, "visible", !0, ae()); mt(U, "transformsEnabled", "all", Oi()); mt(U, "size"); mt(U, "dragBoundFunc"); mt(U, "draggable", !1, ae()); v.backCompat(U, { rotateDeg: "rotate", setRotationDeg: "setRotation", getRotationDeg: "getRotation" }); class Jt extends U { constructor() { super(...arguments), this.children = [] } getChildren(t) { if (!t) return this.children || []; const i = this.children || []; var r = []; return i.forEach(function (n) { t(n) && r.push(n) }), r } hasChildren() { return this.getChildren().length > 0 } removeChildren() { return this.getChildren().forEach(t => { t.parent = null, t.index = 0, t.remove() }), this.children = [], this._requestDraw(), this } destroyChildren() { return this.getChildren().forEach(t => { t.parent = null, t.index = 0, t.destroy() }), this.children = [], this._requestDraw(), this } add(...t) { if (t.length === 0) return this; if (t.length > 1) { for (var i = 0; i < t.length; i++)this.add(t[i]); return this } const r = t[0]; return r.getParent() ? (r.moveTo(this), this) : (this._validateAdd(r), r.index = this.getChildren().length, r.parent = this, r._clearCaches(), this.getChildren().push(r), this._fire("add", { child: r }), this._requestDraw(), this) } destroy() { return this.hasChildren() && this.destroyChildren(), super.destroy(), this } find(t) { return this._generalFind(t, !1) } findOne(t) { var i = this._generalFind(t, !0); return i.length > 0 ? i[0] : void 0 } _generalFind(t, i) { var r = []; return this._descendants(n => { const s = n._isMatch(t); return s && r.push(n), !!(s && i) }), r } _descendants(t) { let i = !1; const r = this.getChildren(); for (const n of r) { if (i = t(n), i) return !0; if (n.hasChildren() && (i = n._descendants(t), i)) return !0 } return !1 } toObject() { var t = U.prototype.toObject.call(this); return t.children = [], this.getChildren().forEach(i => { t.children.push(i.toObject()) }), t } isAncestorOf(t) { for (var i = t.getParent(); i;) { if (i._id === this._id) return !0; i = i.getParent() } return !1 } clone(t) { var i = U.prototype.clone.call(this, t); return this.getChildren().forEach(function (r) { i.add(r.clone()) }), i } getAllIntersections(t) { var i = []; return this.find("Shape").forEach(function (r) { r.isVisible() && r.intersects(t) && i.push(r) }), i } _clearSelfAndDescendantCache(t) { var i; super._clearSelfAndDescendantCache(t), !this.isCached() && ((i = this.children) === null || i === void 0 || i.forEach(function (r) { r._clearSelfAndDescendantCache(t) })) } _setChildrenIndices() { var t; (t = this.children) === null || t === void 0 || t.forEach(function (i, r) { i.index = r }), this._requestDraw() } drawScene(t, i) { var r = this.getLayer(), n = t || r && r.getCanvas(), s = n && n.getContext(), a = this._getCanvasCache(), o = a && a.scene, l = n && n.isCache; if (!this.isVisible() && !l) return this; if (o) { s.save(); var h = this.getAbsoluteTransform(i).getMatrix(); s.transform(h[0], h[1], h[2], h[3], h[4], h[5]), this._drawCachedSceneCanvas(s), s.restore() } else this._drawChildren("drawScene", n, i); return this } drawHit(t, i) { if (!this.shouldDrawHit(i)) return this; var r = this.getLayer(), n = t || r && r.hitCanvas, s = n && n.getContext(), a = this._getCanvasCache(), o = a && a.hit; if (o) { s.save(); var l = this.getAbsoluteTransform(i).getMatrix(); s.transform(l[0], l[1], l[2], l[3], l[4], l[5]), this._drawCachedHitCanvas(s), s.restore() } else this._drawChildren("drawHit", n, i); return this } _drawChildren(t, i, r) { var n, s = i && i.getContext(), a = this.clipWidth(), o = this.clipHeight(), l = this.clipFunc(), h = a && o || l; const c = r === this; if (h) { s.save(); var f = this.getAbsoluteTransform(r), u = f.getMatrix(); if (s.transform(u[0], u[1], u[2], u[3], u[4], u[5]), s.beginPath(), l) l.call(this, s, this); else { var g = this.clipX(), d = this.clipY(); s.rect(g, d, a, o) } s.clip(), u = f.copy().invert().getMatrix(), s.transform(u[0], u[1], u[2], u[3], u[4], u[5]) } var y = !c && this.globalCompositeOperation() !== "source-over" && t === "drawScene"; y && (s.save(), s._applyGlobalCompositeOperation(this)), (n = this.children) === null || n === void 0 || n.forEach(function (C) { C[t](i, r) }), y && s.restore(), h && s.restore() } getClientRect(t) { var i; t = t || {}; var r = t.skipTransform, n = t.relativeTo, s, a, o, l, h = { x: 1 / 0, y: 1 / 0, width: 0, height: 0 }, c = this; (i = this.children) === null || i === void 0 || i.forEach(function (y) { if (y.visible()) { var C = y.getClientRect({ relativeTo: c, skipShadow: t.skipShadow, skipStroke: t.skipStroke }); C.width === 0 && C.height === 0 || (s === void 0 ? (s = C.x, a = C.y, o = C.x + C.width, l = C.y + C.height) : (s = Math.min(s, C.x), a = Math.min(a, C.y), o = Math.max(o, C.x + C.width), l = Math.max(l, C.y + C.height))) } }); for (var f = this.find("Shape"), u = !1, g = 0; g < f.length; g++) { var d = f[g]; if (d._isVisible(this)) { u = !0; break } } return u && s !== void 0 ? h = { x: s, y: a, width: o - s, height: l - a } : h = { x: 0, y: 0, width: 0, height: 0 }, r ? h : this._transformedRect(h, n) } } v.addComponentsGetterSetter(Jt, "clip", ["x", "y", "width", "height"]); v.addGetterSetter(Jt, "clipX", void 0, W()); v.addGetterSetter(Jt, "clipY", void 0, W()); v.addGetterSetter(Jt, "clipWidth", void 0, W()); v.addGetterSetter(Jt, "clipHeight", void 0, W()); v.addGetterSetter(Jt, "clipFunc"); const dr = new Map, fh = X._global.PointerEvent !== void 0; function zn(e) { return dr.get(e) } function ha(e) { return { evt: e, pointerId: e.pointerId } } function uh(e, t) { return dr.get(e) === t } function dh(e, t) { rr(e), t.getStage() && (dr.set(e, t), fh && t._fire("gotpointercapture", ha(new PointerEvent("gotpointercapture")))) } function rr(e, t) { const i = dr.get(e); if (!i) return; const r = i.getStage(); r && r.content, dr.delete(e), fh && i._fire("lostpointercapture", ha(new PointerEvent("lostpointercapture"))) } var qd = "Stage", Jd = "string", lo = "px", Qd = "mouseout", gh = "mouseleave", ph = "mouseover", vh = "mouseenter", mh = "mousemove", _h = "mousedown", yh = "mouseup", Yi = "pointermove", Vi = "pointerdown", vi = "pointerup", Ki = "pointercancel", Zd = "lostpointercapture", Br = "pointerout", Hr = "pointerleave", Ur = "pointerover", Wr = "pointerenter", _s = "contextmenu", bh = "touchstart", Ch = "touchend", Sh = "touchmove", wh = "touchcancel", ys = "wheel", tg = 5, eg = [[vh, "_pointerenter"], [_h, "_pointerdown"], [mh, "_pointermove"], [yh, "_pointerup"], [gh, "_pointerleave"], [bh, "_pointerdown"], [Sh, "_pointermove"], [Ch, "_pointerup"], [wh, "_pointercancel"], [ph, "_pointerover"], [ys, "_wheel"], [_s, "_contextmenu"], [Vi, "_pointerdown"], [Yi, "_pointermove"], [vi, "_pointerup"], [Ki, "_pointercancel"], [Zd, "_lostpointercapture"]]; const Yn = { mouse: { [Br]: Qd, [Hr]: gh, [Ur]: ph, [Wr]: vh, [Yi]: mh, [Vi]: _h, [vi]: yh, [Ki]: "mousecancel", pointerclick: "click", pointerdblclick: "dblclick" }, touch: { [Br]: "touchout", [Hr]: "touchleave", [Ur]: "touchover", [Wr]: "touchenter", [Yi]: Sh, [Vi]: bh, [vi]: Ch, [Ki]: wh, pointerclick: "tap", pointerdblclick: "dbltap" }, pointer: { [Br]: Br, [Hr]: Hr, [Ur]: Ur, [Wr]: Wr, [Yi]: Yi, [Vi]: Vi, [vi]: vi, [Ki]: Ki, pointerclick: "pointerclick", pointerdblclick: "pointerdblclick" } }, Xi = e => e.indexOf("pointer") >= 0 ? "pointer" : e.indexOf("touch") >= 0 ? "touch" : "mouse", di = e => { const t = Xi(e); if (t === "pointer") return X.pointerEventsEnabled && Yn.pointer; if (t === "touch") return Yn.touch; if (t === "mouse") return Yn.mouse }; function ho(e = {}) { return (e.clipFunc || e.clipWidth || e.clipHeight) && x.warn("Stage does not support clipping. Please use clip for Layers or Groups."), e } const ig = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);", Zr = []; class Ln extends Jt { constructor(t) { super(ho(t)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), Zr.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => { ho(this.attrs) }), this._checkVisibility() } _validateAdd(t) { const i = t.getType() === "Layer", r = t.getType() === "FastLayer"; i || r || x.throw("You may only add layers to the stage.") } _checkVisibility() { if (!this.content) return; const t = this.visible() ? "" : "none"; this.content.style.display = t } setContainer(t) { if (typeof t === Jd) { if (t.charAt(0) === ".") { var i = t.slice(1); t = document.getElementsByClassName(i)[0] } else { var r; t.charAt(0) !== "#" ? r = t : r = t.slice(1), t = document.getElementById(r) } if (!t) throw "Can not find container in document with id " + r } return this._setAttr("container", t), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), t.appendChild(this.content)), this } shouldDrawHit() { return !0 } clear() { var t = this.children, i = t.length, r; for (r = 0; r < i; r++)t[r].clear(); return this } clone(t) { return t || (t = {}), t.container = typeof document < "u" && document.createElement("div"), Jt.prototype.clone.call(this, t) } destroy() { super.destroy(); var t = this.content; t && x._isInDocument(t) && this.container().removeChild(t); var i = Zr.indexOf(this); return i > -1 && Zr.splice(i, 1), x.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this } getPointerPosition() { const t = this._pointerPositions[0] || this._changedPointerPositions[0]; return t ? { x: t.x, y: t.y } : (x.warn(ig), null) } _getPointerById(t) { return this._pointerPositions.find(i => i.id === t) } getPointersPositions() { return this._pointerPositions } getStage() { return this } getContent() { return this.content } _toKonvaCanvas(t) { t = t || {}, t.x = t.x || 0, t.y = t.y || 0, t.width = t.width || this.width(), t.height = t.height || this.height(); var i = new wi({ width: t.width, height: t.height, pixelRatio: t.pixelRatio || 1 }), r = i.getContext()._context, n = this.children; return (t.x || t.y) && r.translate(-1 * t.x, -1 * t.y), n.forEach(function (s) { if (s.isVisible()) { var a = s._toKonvaCanvas(t); r.drawImage(a._canvas, t.x, t.y, a.getWidth() / a.getPixelRatio(), a.getHeight() / a.getPixelRatio()) } }), i } getIntersection(t) { if (!t) return null; var i = this.children, r = i.length, n = r - 1, s; for (s = n; s >= 0; s--) { const a = i[s].getIntersection(t); if (a) return a } return null } _resizeDOM() { var t = this.width(), i = this.height(); this.content && (this.content.style.width = t + lo, this.content.style.height = i + lo), this.bufferCanvas.setSize(t, i), this.bufferHitCanvas.setSize(t, i), this.children.forEach(r => { r.setSize({ width: t, height: i }), r.draw() }) } add(t, ...i) { if (arguments.length > 1) { for (var r = 0; r < arguments.length; r++)this.add(arguments[r]); return this } super.add(t); var n = this.children.length; return n > tg && x.warn("The stage has " + n + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), t.setSize({ width: this.width(), height: this.height() }), t.draw(), X.isBrowser && this.content.appendChild(t.canvas._canvas), this } getParent() { return null } getLayer() { return null } hasPointerCapture(t) { return uh(t, this) } setPointerCapture(t) { dh(t, this) } releaseCapture(t) { rr(t) } getLayers() { return this.children } _bindContentEvents() { X.isBrowser && eg.forEach(([t, i]) => { this.content.addEventListener(t, r => { this[i](r) }, { passive: !1 }) }) } _pointerenter(t) { this.setPointersPositions(t); const i = di(t.type); this._fire(i.pointerenter, { evt: t, target: this, currentTarget: this }) } _pointerover(t) { this.setPointersPositions(t); const i = di(t.type); this._fire(i.pointerover, { evt: t, target: this, currentTarget: this }) } _getTargetShape(t) { let i = this[t + "targetShape"]; return i && !i.getStage() && (i = null), i } _pointerleave(t) { const i = di(t.type), r = Xi(t.type); if (i) { this.setPointersPositions(t); var n = this._getTargetShape(r), s = !ct.isDragging || X.hitOnDragEnabled; n && s ? (n._fireAndBubble(i.pointerout, { evt: t }), n._fireAndBubble(i.pointerleave, { evt: t }), this._fire(i.pointerleave, { evt: t, target: this, currentTarget: this }), this[r + "targetShape"] = null) : s && (this._fire(i.pointerleave, { evt: t, target: this, currentTarget: this }), this._fire(i.pointerout, { evt: t, target: this, currentTarget: this })), this.pointerPos = void 0, this._pointerPositions = [] } } _pointerdown(t) { const i = di(t.type), r = Xi(t.type); if (i) { this.setPointersPositions(t); var n = !1; this._changedPointerPositions.forEach(s => { var a = this.getIntersection(s); if (ct.justDragged = !1, X["_" + r + "ListenClick"] = !0, !(a && a.isListening())) return; X.capturePointerEventsEnabled && a.setPointerCapture(s.id), this[r + "ClickStartShape"] = a, a._fireAndBubble(i.pointerdown, { evt: t, pointerId: s.id }), n = !0; const l = t.type.indexOf("touch") >= 0; a.preventDefault() && t.cancelable && l && t.preventDefault() }), n || this._fire(i.pointerdown, { evt: t, target: this, currentTarget: this, pointerId: this._pointerPositions[0].id }) } } _pointermove(t) { const i = di(t.type), r = Xi(t.type); if (!i) return; ct.isDragging && ct.node.preventDefault() && t.cancelable && t.preventDefault(), this.setPointersPositions(t); var n = !ct.isDragging || X.hitOnDragEnabled; if (!n) return; var s = {}; let a = !1; var o = this._getTargetShape(r); this._changedPointerPositions.forEach(l => { const h = zn(l.id) || this.getIntersection(l), c = l.id, f = { evt: t, pointerId: c }; var u = o !== h; if (u && o && (o._fireAndBubble(i.pointerout, Object.assign({}, f), h), o._fireAndBubble(i.pointerleave, Object.assign({}, f), h)), h) { if (s[h._id]) return; s[h._id] = !0 } h && h.isListening() ? (a = !0, u && (h._fireAndBubble(i.pointerover, Object.assign({}, f), o), h._fireAndBubble(i.pointerenter, Object.assign({}, f), o), this[r + "targetShape"] = h), h._fireAndBubble(i.pointermove, Object.assign({}, f))) : o && (this._fire(i.pointerover, { evt: t, target: this, currentTarget: this, pointerId: c }), this[r + "targetShape"] = null) }), a || this._fire(i.pointermove, { evt: t, target: this, currentTarget: this, pointerId: this._changedPointerPositions[0].id }) } _pointerup(t) { const i = di(t.type), r = Xi(t.type); if (!i) return; this.setPointersPositions(t); const n = this[r + "ClickStartShape"], s = this[r + "ClickEndShape"]; var a = {}; let o = !1; this._changedPointerPositions.forEach(l => { const h = zn(l.id) || this.getIntersection(l); if (h) { if (h.releaseCapture(l.id), a[h._id]) return; a[h._id] = !0 } const c = l.id, f = { evt: t, pointerId: c }; let u = !1; X["_" + r + "InDblClickWindow"] ? (u = !0, clearTimeout(this[r + "DblTimeout"])) : ct.justDragged || (X["_" + r + "InDblClickWindow"] = !0, clearTimeout(this[r + "DblTimeout"])), this[r + "DblTimeout"] = setTimeout(function () { X["_" + r + "InDblClickWindow"] = !1 }, X.dblClickWindow), h && h.isListening() ? (o = !0, this[r + "ClickEndShape"] = h, h._fireAndBubble(i.pointerup, Object.assign({}, f)), X["_" + r + "ListenClick"] && n && n === h && (h._fireAndBubble(i.pointerclick, Object.assign({}, f)), u && s && s === h && h._fireAndBubble(i.pointerdblclick, Object.assign({}, f)))) : (this[r + "ClickEndShape"] = null, X["_" + r + "ListenClick"] && this._fire(i.pointerclick, { evt: t, target: this, currentTarget: this, pointerId: c }), u && this._fire(i.pointerdblclick, { evt: t, target: this, currentTarget: this, pointerId: c })) }), o || this._fire(i.pointerup, { evt: t, target: this, currentTarget: this, pointerId: this._changedPointerPositions[0].id }), X["_" + r + "ListenClick"] = !1, t.cancelable && r !== "touch" && t.preventDefault() } _contextmenu(t) { this.setPointersPositions(t); var i = this.getIntersection(this.getPointerPosition()); i && i.isListening() ? i._fireAndBubble(_s, { evt: t }) : this._fire(_s, { evt: t, target: this, currentTarget: this }) } _wheel(t) { this.setPointersPositions(t); var i = this.getIntersection(this.getPointerPosition()); i && i.isListening() ? i._fireAndBubble(ys, { evt: t }) : this._fire(ys, { evt: t, target: this, currentTarget: this }) } _pointercancel(t) { this.setPointersPositions(t); const i = zn(t.pointerId) || this.getIntersection(this.getPointerPosition()); i && i._fireAndBubble(vi, ha(t)), rr(t.pointerId) } _lostpointercapture(t) { rr(t.pointerId) } setPointersPositions(t) { var i = this._getContentPosition(), r = null, n = null; t = t || window.event, t.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(t.touches, s => { this._pointerPositions.push({ id: s.identifier, x: (s.clientX - i.left) / i.scaleX, y: (s.clientY - i.top) / i.scaleY }) }), Array.prototype.forEach.call(t.changedTouches || t.touches, s => { this._changedPointerPositions.push({ id: s.identifier, x: (s.clientX - i.left) / i.scaleX, y: (s.clientY - i.top) / i.scaleY }) })) : (r = (t.clientX - i.left) / i.scaleX, n = (t.clientY - i.top) / i.scaleY, this.pointerPos = { x: r, y: n }, this._pointerPositions = [{ x: r, y: n, id: x._getFirstPointerId(t) }], this._changedPointerPositions = [{ x: r, y: n, id: x._getFirstPointerId(t) }]) } _setPointerPosition(t) { x.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(t) } _getContentPosition() { if (!this.content || !this.content.getBoundingClientRect) return { top: 0, left: 0, scaleX: 1, scaleY: 1 }; var t = this.content.getBoundingClientRect(); return { top: t.top, left: t.left, scaleX: t.width / this.content.clientWidth || 1, scaleY: t.height / this.content.clientHeight || 1 } } _buildDOM() { if (this.bufferCanvas = new wi({ width: this.width(), height: this.height() }), this.bufferHitCanvas = new la({ pixelRatio: 1, width: this.width(), height: this.height() }), !!X.isBrowser) { var t = this.container(); if (!t) throw "Stage has no container. A container is required."; t.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), t.appendChild(this.content), this._resizeDOM() } } cache() { return x.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this } clearCache() { return this } batchDraw() { return this.getChildren().forEach(function (t) { t.batchDraw() }), this } } Ln.prototype.nodeType = qd; St(Ln); v.addGetterSetter(Ln, "container"); var xh = "hasShadow", Eh = "shadowRGBA", Th = "patternImage", Ph = "linearGradient", Ah = "radialGradient"; let jr; function Vn() { return jr || (jr = x.createCanvasElement().getContext("2d"), jr) } const nr = {}; function rg(e) { e.fill() } function ng(e) { e.stroke() } function sg(e) { e.fill() } function ag(e) { e.stroke() } function og() { this._clearCache(xh) } function lg() { this._clearCache(Eh) } function hg() { this._clearCache(Th) } function cg() { this._clearCache(Ph) } function fg() { this._clearCache(Ah) } class G extends U { constructor(t) { super(t); let i; for (; i = x.getRandomColor(), !(i && !(i in nr));); this.colorKey = i, nr[i] = this } getContext() { return x.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext() } getCanvas() { return x.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas() } getSceneFunc() { return this.attrs.sceneFunc || this._sceneFunc } getHitFunc() { return this.attrs.hitFunc || this._hitFunc } hasShadow() { return this._getCache(xh, this._hasShadow) } _hasShadow() { return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY()) } _getFillPattern() { return this._getCache(Th, this.__getFillPattern) } __getFillPattern() { if (this.fillPatternImage()) { var t = Vn(); const i = t.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat"); if (i && i.setTransform) { const r = new $t; r.translate(this.fillPatternX(), this.fillPatternY()), r.rotate(X.getAngle(this.fillPatternRotation())), r.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), r.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY()); const n = r.getMatrix(), s = typeof DOMMatrix > "u" ? { a: n[0], b: n[1], c: n[2], d: n[3], e: n[4], f: n[5] } : new DOMMatrix(n); i.setTransform(s) } return i } } _getLinearGradient() { return this._getCache(Ph, this.__getLinearGradient) } __getLinearGradient() { var t = this.fillLinearGradientColorStops(); if (t) { for (var i = Vn(), r = this.fillLinearGradientStartPoint(), n = this.fillLinearGradientEndPoint(), s = i.createLinearGradient(r.x, r.y, n.x, n.y), a = 0; a < t.length; a += 2)s.addColorStop(t[a], t[a + 1]); return s } } _getRadialGradient() { return this._getCache(Ah, this.__getRadialGradient) } __getRadialGradient() { var t = this.fillRadialGradientColorStops(); if (t) { for (var i = Vn(), r = this.fillRadialGradientStartPoint(), n = this.fillRadialGradientEndPoint(), s = i.createRadialGradient(r.x, r.y, this.fillRadialGradientStartRadius(), n.x, n.y, this.fillRadialGradientEndRadius()), a = 0; a < t.length; a += 2)s.addColorStop(t[a], t[a + 1]); return s } } getShadowRGBA() { return this._getCache(Eh, this._getShadowRGBA) } _getShadowRGBA() { if (this.hasShadow()) { var t = x.colorToRGBA(this.shadowColor()); if (t) return "rgba(" + t.r + "," + t.g + "," + t.b + "," + t.a * (this.shadowOpacity() || 1) + ")" } } hasFill() { return this._calculate("hasFill", ["fillEnabled", "fill", "fillPatternImage", "fillLinearGradientColorStops", "fillRadialGradientColorStops"], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops())) } hasStroke() { return this._calculate("hasStroke", ["strokeEnabled", "strokeWidth", "stroke", "strokeLinearGradientColorStops"], () => this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops())) } hasHitStroke() { const t = this.hitStrokeWidth(); return t === "auto" ? this.hasStroke() : this.strokeEnabled() && !!t } intersects(t) { var i = this.getStage(), r = i.bufferHitCanvas, n; return r.getContext().clear(), this.drawHit(r, null, !0), n = r.context.getImageData(Math.round(t.x), Math.round(t.y), 1, 1).data, n[3] > 0 } destroy() { return U.prototype.destroy.call(this), delete nr[this.colorKey], delete this.colorKey, this } _useBufferCanvas(t) { var i; if (!this.getStage() || !((i = this.attrs.perfectDrawEnabled) !== null && i !== void 0 ? i : !0)) return !1; const n = t || this.hasFill(), s = this.hasStroke(), a = this.getAbsoluteOpacity() !== 1; if (n && s && a) return !0; const o = this.hasShadow(), l = this.shadowForStrokeEnabled(); return !!(n && s && o && l) } setStrokeHitEnabled(t) { x.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), t ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0) } getStrokeHitEnabled() { return this.hitStrokeWidth() !== 0 } getSelfRect() { var t = this.size(); return { x: this._centroid ? -t.width / 2 : 0, y: this._centroid ? -t.height / 2 : 0, width: t.width, height: t.height } } getClientRect(t = {}) { const i = t.skipTransform, r = t.relativeTo, n = this.getSelfRect(), a = !t.skipStroke && this.hasStroke() && this.strokeWidth() || 0, o = n.width + a, l = n.height + a, h = !t.skipShadow && this.hasShadow(), c = h ? this.shadowOffsetX() : 0, f = h ? this.shadowOffsetY() : 0, u = o + Math.abs(c), g = l + Math.abs(f), d = h && this.shadowBlur() || 0, y = u + d * 2, C = g + d * 2, b = { width: y, height: C, x: -(a / 2 + d) + Math.min(c, 0) + n.x, y: -(a / 2 + d) + Math.min(f, 0) + n.y }; return i ? b : this._transformedRect(b, r) } drawScene(t, i) { var r = this.getLayer(), n = t || r.getCanvas(), s = n.getContext(), a = this._getCanvasCache(), o = this.getSceneFunc(), l = this.hasShadow(), h, c, f, u = n.isCache, g = i === this; if (!this.isVisible() && !g) return this; if (a) { s.save(); var d = this.getAbsoluteTransform(i).getMatrix(); return s.transform(d[0], d[1], d[2], d[3], d[4], d[5]), this._drawCachedSceneCanvas(s), s.restore(), this } if (!o) return this; if (s.save(), this._useBufferCanvas() && !u) { h = this.getStage(), c = h.bufferCanvas, f = c.getContext(), f.clear(), f.save(), f._applyLineJoin(this); var y = this.getAbsoluteTransform(i).getMatrix(); f.transform(y[0], y[1], y[2], y[3], y[4], y[5]), o.call(this, f, this), f.restore(); var C = c.pixelRatio; l && s._applyShadow(this), s._applyOpacity(this), s._applyGlobalCompositeOperation(this), s.drawImage(c._canvas, 0, 0, c.width / C, c.height / C) } else { if (s._applyLineJoin(this), !g) { var y = this.getAbsoluteTransform(i).getMatrix(); s.transform(y[0], y[1], y[2], y[3], y[4], y[5]), s._applyOpacity(this), s._applyGlobalCompositeOperation(this) } l && s._applyShadow(this), o.call(this, s, this) } return s.restore(), this } drawHit(t, i, r = !1) { if (!this.shouldDrawHit(i, r)) return this; var n = this.getLayer(), s = t || n.hitCanvas, a = s && s.getContext(), o = this.hitFunc() || this.sceneFunc(), l = this._getCanvasCache(), h = l && l.hit; if (this.colorKey || x.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), h) { a.save(); var c = this.getAbsoluteTransform(i).getMatrix(); return a.transform(c[0], c[1], c[2], c[3], c[4], c[5]), this._drawCachedHitCanvas(a), a.restore(), this } if (!o) return this; if (a.save(), a._applyLineJoin(this), !(this === i)) { var u = this.getAbsoluteTransform(i).getMatrix(); a.transform(u[0], u[1], u[2], u[3], u[4], u[5]) } return o.call(this, a, this), a.restore(), this } drawHitFromCache(t = 0) { var i = this._getCanvasCache(), r = this._getCachedSceneCanvas(), n = i.hit, s = n.getContext(), a = n.getWidth(), o = n.getHeight(), l, h, c, f, u, g; s.clear(), s.drawImage(r._canvas, 0, 0, a, o); try { for (l = s.getImageData(0, 0, a, o), h = l.data, c = h.length, f = x._hexToRgb(this.colorKey), u = 0; u < c; u += 4)g = h[u + 3], g > t ? (h[u] = f.r, h[u + 1] = f.g, h[u + 2] = f.b, h[u + 3] = 255) : h[u + 3] = 0; s.putImageData(l, 0, 0) } catch (d) { x.error("Unable to draw hit graph from cached scene canvas. " + d.message) } return this } hasPointerCapture(t) { return uh(t, this) } setPointerCapture(t) { dh(t, this) } releaseCapture(t) { rr(t) } } G.prototype._fillFunc = rg; G.prototype._strokeFunc = ng; G.prototype._fillFuncHit = sg; G.prototype._strokeFuncHit = ag; G.prototype._centroid = !1; G.prototype.nodeType = "Shape"; St(G); G.prototype.eventListeners = {}; G.prototype.on.call(G.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", og); G.prototype.on.call(G.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", lg); G.prototype.on.call(G.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", hg); G.prototype.on.call(G.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", cg); G.prototype.on.call(G.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", fg); v.addGetterSetter(G, "stroke", void 0, ch()); v.addGetterSetter(G, "strokeWidth", 2, W()); v.addGetterSetter(G, "fillAfterStrokeEnabled", !1); v.addGetterSetter(G, "hitStrokeWidth", "auto", oa()); v.addGetterSetter(G, "strokeHitEnabled", !0, ae()); v.addGetterSetter(G, "perfectDrawEnabled", !0, ae()); v.addGetterSetter(G, "shadowForStrokeEnabled", !0, ae()); v.addGetterSetter(G, "lineJoin"); v.addGetterSetter(G, "lineCap"); v.addGetterSetter(G, "sceneFunc"); v.addGetterSetter(G, "hitFunc"); v.addGetterSetter(G, "dash"); v.addGetterSetter(G, "dashOffset", 0, W()); v.addGetterSetter(G, "shadowColor", void 0, Oi()); v.addGetterSetter(G, "shadowBlur", 0, W()); v.addGetterSetter(G, "shadowOpacity", 1, W()); v.addComponentsGetterSetter(G, "shadowOffset", ["x", "y"]); v.addGetterSetter(G, "shadowOffsetX", 0, W()); v.addGetterSetter(G, "shadowOffsetY", 0, W()); v.addGetterSetter(G, "fillPatternImage"); v.addGetterSetter(G, "fill", void 0, ch()); v.addGetterSetter(G, "fillPatternX", 0, W()); v.addGetterSetter(G, "fillPatternY", 0, W()); v.addGetterSetter(G, "fillLinearGradientColorStops"); v.addGetterSetter(G, "strokeLinearGradientColorStops"); v.addGetterSetter(G, "fillRadialGradientStartRadius", 0); v.addGetterSetter(G, "fillRadialGradientEndRadius", 0); v.addGetterSetter(G, "fillRadialGradientColorStops"); v.addGetterSetter(G, "fillPatternRepeat", "repeat"); v.addGetterSetter(G, "fillEnabled", !0); v.addGetterSetter(G, "strokeEnabled", !0); v.addGetterSetter(G, "shadowEnabled", !0); v.addGetterSetter(G, "dashEnabled", !0); v.addGetterSetter(G, "strokeScaleEnabled", !0); v.addGetterSetter(G, "fillPriority", "color"); v.addComponentsGetterSetter(G, "fillPatternOffset", ["x", "y"]); v.addGetterSetter(G, "fillPatternOffsetX", 0, W()); v.addGetterSetter(G, "fillPatternOffsetY", 0, W()); v.addComponentsGetterSetter(G, "fillPatternScale", ["x", "y"]); v.addGetterSetter(G, "fillPatternScaleX", 1, W()); v.addGetterSetter(G, "fillPatternScaleY", 1, W()); v.addComponentsGetterSetter(G, "fillLinearGradientStartPoint", ["x", "y"]); v.addComponentsGetterSetter(G, "strokeLinearGradientStartPoint", ["x", "y"]); v.addGetterSetter(G, "fillLinearGradientStartPointX", 0); v.addGetterSetter(G, "strokeLinearGradientStartPointX", 0); v.addGetterSetter(G, "fillLinearGradientStartPointY", 0); v.addGetterSetter(G, "strokeLinearGradientStartPointY", 0); v.addComponentsGetterSetter(G, "fillLinearGradientEndPoint", ["x", "y"]); v.addComponentsGetterSetter(G, "strokeLinearGradientEndPoint", ["x", "y"]); v.addGetterSetter(G, "fillLinearGradientEndPointX", 0); v.addGetterSetter(G, "strokeLinearGradientEndPointX", 0); v.addGetterSetter(G, "fillLinearGradientEndPointY", 0); v.addGetterSetter(G, "strokeLinearGradientEndPointY", 0); v.addComponentsGetterSetter(G, "fillRadialGradientStartPoint", ["x", "y"]); v.addGetterSetter(G, "fillRadialGradientStartPointX", 0); v.addGetterSetter(G, "fillRadialGradientStartPointY", 0); v.addComponentsGetterSetter(G, "fillRadialGradientEndPoint", ["x", "y"]); v.addGetterSetter(G, "fillRadialGradientEndPointX", 0); v.addGetterSetter(G, "fillRadialGradientEndPointY", 0); v.addGetterSetter(G, "fillPatternRotation", 0); v.backCompat(G, { dashArray: "dash", getDashArray: "getDash", setDashArray: "getDash", drawFunc: "sceneFunc", getDrawFunc: "getSceneFunc", setDrawFunc: "setSceneFunc", drawHitFunc: "hitFunc", getDrawHitFunc: "getHitFunc", setDrawHitFunc: "setHitFunc" }); var ug = "#", dg = "beforeDraw", gg = "draw", kh = [{ x: 0, y: 0 }, { x: -1, y: -1 }, { x: 1, y: -1 }, { x: 1, y: 1 }, { x: -1, y: 1 }], pg = kh.length; class ai extends Jt { constructor(t) { super(t), this.canvas = new wi, this.hitCanvas = new la({ pixelRatio: 1 }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled() } createPNGStream() { return this.canvas._canvas.createPNGStream() } getCanvas() { return this.canvas } getNativeCanvasElement() { return this.canvas._canvas } getHitCanvas() { return this.hitCanvas } getContext() { return this.getCanvas().getContext() } clear(t) { return this.getContext().clear(t), this.getHitCanvas().getContext().clear(t), this } setZIndex(t) { super.setZIndex(t); var i = this.getStage(); return i && i.content && (i.content.removeChild(this.getNativeCanvasElement()), t < i.children.length - 1 ? i.content.insertBefore(this.getNativeCanvasElement(), i.children[t + 1].getCanvas()._canvas) : i.content.appendChild(this.getNativeCanvasElement())), this } moveToTop() { U.prototype.moveToTop.call(this); var t = this.getStage(); return t && t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.appendChild(this.getNativeCanvasElement())), !0 } moveUp() { var t = U.prototype.moveUp.call(this); if (!t) return !1; var i = this.getStage(); return !i || !i.content ? !1 : (i.content.removeChild(this.getNativeCanvasElement()), this.index < i.children.length - 1 ? i.content.insertBefore(this.getNativeCanvasElement(), i.children[this.index + 1].getCanvas()._canvas) : i.content.appendChild(this.getNativeCanvasElement()), !0) } moveDown() { if (U.prototype.moveDown.call(this)) { var t = this.getStage(); if (t) { var i = t.children; t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), i[this.index + 1].getCanvas()._canvas)) } return !0 } return !1 } moveToBottom() { if (U.prototype.moveToBottom.call(this)) { var t = this.getStage(); if (t) { var i = t.children; t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), i[1].getCanvas()._canvas)) } return !0 } return !1 } getLayer() { return this } remove() { var t = this.getNativeCanvasElement(); return U.prototype.remove.call(this), t && t.parentNode && x._isInDocument(t) && t.parentNode.removeChild(t), this } getStage() { return this.parent } setSize({ width: t, height: i }) { return this.canvas.setSize(t, i), this.hitCanvas.setSize(t, i), this._setSmoothEnabled(), this } _validateAdd(t) { var i = t.getType(); i !== "Group" && i !== "Shape" && x.throw("You may only add groups and shapes to a layer.") } _toKonvaCanvas(t) { return t = t || {}, t.width = t.width || this.getWidth(), t.height = t.height || this.getHeight(), t.x = t.x !== void 0 ? t.x : this.x(), t.y = t.y !== void 0 ? t.y : this.y(), U.prototype._toKonvaCanvas.call(this, t) } _checkVisibility() { this.visible() ? this.canvas._canvas.style.display = "block" : this.canvas._canvas.style.display = "none" } _setSmoothEnabled() { this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled() } getWidth() { if (this.parent) return this.parent.width() } setWidth() { x.warn('Can not change width of layer. Use "stage.width(value)" function instead.') } getHeight() { if (this.parent) return this.parent.height() } setHeight() { x.warn('Can not change height of layer. Use "stage.height(value)" function instead.') } batchDraw() { return this._waitingForDraw || (this._waitingForDraw = !0, x.requestAnimFrame(() => { this.draw(), this._waitingForDraw = !1 })), this } getIntersection(t) { if (!this.isListening() || !this.isVisible()) return null; for (var i = 1, r = !1; ;) { for (let n = 0; n < pg; n++) { const s = kh[n], a = this._getIntersection({ x: t.x + s.x * i, y: t.y + s.y * i }), o = a.shape; if (o) return o; if (r = !!a.antialiased, !a.antialiased) break } if (r) i += 1; else return null } } _getIntersection(t) { const i = this.hitCanvas.pixelRatio, r = this.hitCanvas.context.getImageData(Math.round(t.x * i), Math.round(t.y * i), 1, 1).data, n = r[3]; if (n === 255) { const s = x._rgbToHex(r[0], r[1], r[2]), a = nr[ug + s]; return a ? { shape: a } : { antialiased: !0 } } else if (n > 0) return { antialiased: !0 }; return {} } drawScene(t, i) { var r = this.getLayer(), n = t || r && r.getCanvas(); return this._fire(dg, { node: this }), this.clearBeforeDraw() && n.getContext().clear(), Jt.prototype.drawScene.call(this, n, i), this._fire(gg, { node: this }), this } drawHit(t, i) { var r = this.getLayer(), n = t || r && r.hitCanvas; return r && r.clearBeforeDraw() && r.getHitCanvas().getContext().clear(), Jt.prototype.drawHit.call(this, n, i), this } enableHitGraph() { return this.hitGraphEnabled(!0), this } disableHitGraph() { return this.hitGraphEnabled(!1), this } setHitGraphEnabled(t) { x.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(t) } getHitGraphEnabled(t) { return x.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening() } toggleHitCanvas() { if (!(!this.parent || !this.parent.content)) { var t = this.parent, i = !!this.hitCanvas._canvas.parentNode; i ? t.content.removeChild(this.hitCanvas._canvas) : t.content.appendChild(this.hitCanvas._canvas) } } destroy() { return x.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy() } } ai.prototype.nodeType = "Layer"; St(ai); v.addGetterSetter(ai, "imageSmoothingEnabled", !0); v.addGetterSetter(ai, "clearBeforeDraw", !0); v.addGetterSetter(ai, "hitGraphEnabled", !0, ae()); class ca extends ai { constructor(t) { super(t), this.listening(!1), x.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.') } } ca.prototype.nodeType = "FastLayer"; St(ca); class Ai extends Jt { _validateAdd(t) { var i = t.getType(); i !== "Group" && i !== "Shape" && x.throw("You may only add groups and shapes to groups.") } } Ai.prototype.nodeType = "Group"; St(Ai); var Kn = function () { return Si.performance && Si.performance.now ? function () { return Si.performance.now() } : function () { return new Date().getTime() } }(); class te { constructor(t, i) { this.id = te.animIdCounter++, this.frame = { time: 0, timeDiff: 0, lastTime: Kn(), frameRate: 0 }, this.func = t, this.setLayers(i) } setLayers(t) { var i = []; return t ? t.length > 0 ? i = t : i = [t] : i = [], this.layers = i, this } getLayers() { return this.layers } addLayer(t) { var i = this.layers, r = i.length, n; for (n = 0; n < r; n++)if (i[n]._id === t._id) return !1; return this.layers.push(t), !0 } isRunning() { var t = te, i = t.animations, r = i.length, n; for (n = 0; n < r; n++)if (i[n].id === this.id) return !0; return !1 } start() { return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = Kn(), te._addAnimation(this), this } stop() { return te._removeAnimation(this), this } _updateFrameObject(t) { this.frame.timeDiff = t - this.frame.lastTime, this.frame.lastTime = t, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff } static _addAnimation(t) { this.animations.push(t), this._handleAnimation() } static _removeAnimation(t) { var i = t.id, r = this.animations, n = r.length, s; for (s = 0; s < n; s++)if (r[s].id === i) { this.animations.splice(s, 1); break } } static _runFrames() { var t = {}, i = this.animations, r, n, s, a, o, l, h, c, f; for (a = 0; a < i.length; a++)if (r = i[a], n = r.layers, s = r.func, r._updateFrameObject(Kn()), l = n.length, s ? f = s.call(r, r.frame) !== !1 : f = !0, !!f) for (o = 0; o < l; o++)h = n[o], h._id !== void 0 && (t[h._id] = h); for (c in t) t.hasOwnProperty(c) && t[c].batchDraw() } static _animationLoop() { var t = te; t.animations.length ? (t._runFrames(), x.requestAnimFrame(t._animationLoop)) : t.animRunning = !1 } static _handleAnimation() { this.animRunning || (this.animRunning = !0, x.requestAnimFrame(this._animationLoop)) } } te.animations = []; te.animIdCounter = 0; te.animRunning = !1; var vg = { node: 1, duration: 1, easing: 1, onFinish: 1, yoyo: 1 }, mg = 1, co = 2, fo = 3, _g = 0, uo = ["fill", "stroke", "shadowColor"]; class yg { constructor(t, i, r, n, s, a, o) { this.prop = t, this.propFunc = i, this.begin = n, this._pos = n, this.duration = a, this._change = 0, this.prevPos = 0, this.yoyo = o, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = r, this._change = s - this.begin, this.pause() } fire(t) { var i = this[t]; i && i() } setTime(t) { t > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : t < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = t, this.update()) } getTime() { return this._time } setPosition(t) { this.prevPos = this._pos, this.propFunc(t), this._pos = t } getPosition(t) { return t === void 0 && (t = this._time), this.func(t, this.begin, this._change, this.duration) } play() { this.state = co, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay") } reverse() { this.state = fo, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse") } seek(t) { this.pause(), this._time = t, this.update(), this.fire("onSeek") } reset() { this.pause(), this._time = 0, this.update(), this.fire("onReset") } finish() { this.pause(), this._time = this.duration, this.update(), this.fire("onFinish") } update() { this.setPosition(this.getPosition(this._time)), this.fire("onUpdate") } onEnterFrame() { var t = this.getTimer() - this._startTime; this.state === co ? this.setTime(t) : this.state === fo && this.setTime(this.duration - t) } pause() { this.state = mg, this.fire("onPause") } getTimer() { return new Date().getTime() } } class Pt { constructor(t) { var i = this, r = t.node, n = r._id, s, a = t.easing || sr.Linear, o = !!t.yoyo, l; typeof t.duration > "u" ? s = .3 : t.duration === 0 ? s = .001 : s = t.duration, this.node = r, this._id = _g++; var h = r.getLayer() || (r instanceof X.Stage ? r.getLayers() : null); h || x.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new te(function () { i.tween.onEnterFrame() }, h), this.tween = new yg(l, function (c) { i._tweenFunc(c) }, a, 0, 1, s * 1e3, o), this._addListeners(), Pt.attrs[n] || (Pt.attrs[n] = {}), Pt.attrs[n][this._id] || (Pt.attrs[n][this._id] = {}), Pt.tweens[n] || (Pt.tweens[n] = {}); for (l in t) vg[l] === void 0 && this._addAttr(l, t[l]); this.reset(), this.onFinish = t.onFinish, this.onReset = t.onReset, this.onUpdate = t.onUpdate } _addAttr(t, i) { var r = this.node, n = r._id, s, a, o, l, h, c, f, u; if (o = Pt.tweens[n][t], o && delete Pt.attrs[n][o][t], s = r.getAttr(t), x._isArray(i)) if (a = [], h = Math.max(i.length, s.length), t === "points" && i.length !== s.length && (i.length > s.length ? (f = s, s = x._prepareArrayForTween(s, i, r.closed())) : (c = i, i = x._prepareArrayForTween(i, s, r.closed()))), t.indexOf("fill") === 0) for (l = 0; l < h; l++)if (l % 2 === 0) a.push(i[l] - s[l]); else { var g = x.colorToRGBA(s[l]); u = x.colorToRGBA(i[l]), s[l] = g, a.push({ r: u.r - g.r, g: u.g - g.g, b: u.b - g.b, a: u.a - g.a }) } else for (l = 0; l < h; l++)a.push(i[l] - s[l]); else uo.indexOf(t) !== -1 ? (s = x.colorToRGBA(s), u = x.colorToRGBA(i), a = { r: u.r - s.r, g: u.g - s.g, b: u.b - s.b, a: u.a - s.a }) : a = i - s; Pt.attrs[n][this._id][t] = { start: s, diff: a, end: i, trueEnd: c, trueStart: f }, Pt.tweens[n][t] = this._id } _tweenFunc(t) { var i = this.node, r = Pt.attrs[i._id][this._id], n, s, a, o, l, h, c, f; for (n in r) { if (s = r[n], a = s.start, o = s.diff, f = s.end, x._isArray(a)) if (l = [], c = Math.max(a.length, f.length), n.indexOf("fill") === 0) for (h = 0; h < c; h++)h % 2 === 0 ? l.push((a[h] || 0) + o[h] * t) : l.push("rgba(" + Math.round(a[h].r + o[h].r * t) + "," + Math.round(a[h].g + o[h].g * t) + "," + Math.round(a[h].b + o[h].b * t) + "," + (a[h].a + o[h].a * t) + ")"); else for (h = 0; h < c; h++)l.push((a[h] || 0) + o[h] * t); else uo.indexOf(n) !== -1 ? l = "rgba(" + Math.round(a.r + o.r * t) + "," + Math.round(a.g + o.g * t) + "," + Math.round(a.b + o.b * t) + "," + (a.a + o.a * t) + ")" : l = a + o * t; i.setAttr(n, l) } } _addListeners() { this.tween.onPlay = () => { this.anim.start() }, this.tween.onReverse = () => { this.anim.start() }, this.tween.onPause = () => { this.anim.stop() }, this.tween.onFinish = () => { var t = this.node, i = Pt.attrs[t._id][this._id]; i.points && i.points.trueEnd && t.setAttr("points", i.points.trueEnd), this.onFinish && this.onFinish.call(this) }, this.tween.onReset = () => { var t = this.node, i = Pt.attrs[t._id][this._id]; i.points && i.points.trueStart && t.points(i.points.trueStart), this.onReset && this.onReset() }, this.tween.onUpdate = () => { this.onUpdate && this.onUpdate.call(this) } } play() { return this.tween.play(), this } reverse() { return this.tween.reverse(), this } reset() { return this.tween.reset(), this } seek(t) { return this.tween.seek(t * 1e3), this } pause() { return this.tween.pause(), this } finish() { return this.tween.finish(), this } destroy() { var t = this.node._id, i = this._id, r = Pt.tweens[t], n; this.pause(); for (n in r) delete Pt.tweens[t][n]; delete Pt.attrs[t][i] } } Pt.attrs = {}; Pt.tweens = {}; U.prototype.to = function (e) { var t = e.onFinish; e.node = this, e.onFinish = function () { this.destroy(), t && t() }; var i = new Pt(e); i.play() }; const sr = { BackEaseIn(e, t, i, r) { var n = 1.70158; return i * (e /= r) * e * ((n + 1) * e - n) + t }, BackEaseOut(e, t, i, r) { var n = 1.70158; return i * ((e = e / r - 1) * e * ((n + 1) * e + n) + 1) + t }, BackEaseInOut(e, t, i, r) { var n = 1.70158; return (e /= r / 2) < 1 ? i / 2 * (e * e * (((n *= 1.525) + 1) * e - n)) + t : i / 2 * ((e -= 2) * e * (((n *= 1.525) + 1) * e + n) + 2) + t }, ElasticEaseIn(e, t, i, r, n, s) { var a = 0; return e === 0 ? t : (e /= r) === 1 ? t + i : (s || (s = r * .3), !n || n < Math.abs(i) ? (n = i, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(i / n), -(n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * r - a) * (2 * Math.PI) / s)) + t) }, ElasticEaseOut(e, t, i, r, n, s) { var a = 0; return e === 0 ? t : (e /= r) === 1 ? t + i : (s || (s = r * .3), !n || n < Math.abs(i) ? (n = i, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(i / n), n * Math.pow(2, -10 * e) * Math.sin((e * r - a) * (2 * Math.PI) / s) + i + t) }, ElasticEaseInOut(e, t, i, r, n, s) { var a = 0; return e === 0 ? t : (e /= r / 2) === 2 ? t + i : (s || (s = r * (.3 * 1.5)), !n || n < Math.abs(i) ? (n = i, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(i / n), e < 1 ? -.5 * (n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * r - a) * (2 * Math.PI) / s)) + t : n * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * r - a) * (2 * Math.PI) / s) * .5 + i + t) }, BounceEaseOut(e, t, i, r) { return (e /= r) < 1 / 2.75 ? i * (7.5625 * e * e) + t : e < 2 / 2.75 ? i * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + t : e < 2.5 / 2.75 ? i * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + t : i * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + t }, BounceEaseIn(e, t, i, r) { return i - sr.BounceEaseOut(r - e, 0, i, r) + t }, BounceEaseInOut(e, t, i, r) { return e < r / 2 ? sr.BounceEaseIn(e * 2, 0, i, r) * .5 + t : sr.BounceEaseOut(e * 2 - r, 0, i, r) * .5 + i * .5 + t }, EaseIn(e, t, i, r) { return i * (e /= r) * e + t }, EaseOut(e, t, i, r) { return -i * (e /= r) * (e - 2) + t }, EaseInOut(e, t, i, r) { return (e /= r / 2) < 1 ? i / 2 * e * e + t : -i / 2 * (--e * (e - 2) - 1) + t }, StrongEaseIn(e, t, i, r) { return i * (e /= r) * e * e * e * e + t }, StrongEaseOut(e, t, i, r) { return i * ((e = e / r - 1) * e * e * e * e + 1) + t }, StrongEaseInOut(e, t, i, r) { return (e /= r / 2) < 1 ? i / 2 * e * e * e * e * e + t : i / 2 * ((e -= 2) * e * e * e * e + 2) + t }, Linear(e, t, i, r) { return i * e / r + t } }, go = x._assign(X, { Util: x, Transform: $t, Node: U, Container: Jt, Stage: Ln, stages: Zr, Layer: ai, FastLayer: ca, Group: Ai, DD: ct, Shape: G, shapes: nr, Animation: te, Tween: Pt, Easings: sr, Context: Rn, Canvas: On }); class Se extends G { _sceneFunc(t) { var i = X.getAngle(this.angle()), r = this.clockwise(); t.beginPath(), t.arc(0, 0, this.outerRadius(), 0, i, r), t.arc(0, 0, this.innerRadius(), i, 0, !r), t.closePath(), t.fillStrokeShape(this) } getWidth() { return this.outerRadius() * 2 } getHeight() { return this.outerRadius() * 2 } setWidth(t) { this.outerRadius(t / 2) } setHeight(t) { this.outerRadius(t / 2) } getSelfRect() { const t = this.innerRadius(), i = this.outerRadius(), r = this.clockwise(), n = X.getAngle(r ? 360 - this.angle() : this.angle()), s = Math.cos(Math.min(n, Math.PI)), a = 1, o = Math.sin(Math.min(Math.max(Math.PI, n), 3 * Math.PI / 2)), l = Math.sin(Math.min(n, Math.PI / 2)), h = s * (s > 0 ? t : i), c = a * i, f = o * (o > 0 ? t : i), u = l * (l > 0 ? i : t); return { x: h, y: r ? -1 * u : f, width: c - h, height: u - f } } } Se.prototype._centroid = !0; Se.prototype.className = "Arc"; Se.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"]; St(Se); v.addGetterSetter(Se, "innerRadius", 0, W()); v.addGetterSetter(Se, "outerRadius", 0, W()); v.addGetterSetter(Se, "angle", 0, W()); v.addGetterSetter(Se, "clockwise", !1, ae()); function bs(e, t, i, r, n, s, a) { var o = Math.sqrt(Math.pow(i - e, 2) + Math.pow(r - t, 2)), l = Math.sqrt(Math.pow(n - i, 2) + Math.pow(s - r, 2)), h = a * o / (o + l), c = a * l / (o + l), f = i - h * (n - e), u = r - h * (s - t), g = i + c * (n - e), d = r + c * (s - t); return [f, u, g, d] } function po(e, t) { var i = e.length, r = [], n, s; for (n = 2; n < i - 2; n += 2)s = bs(e[n - 2], e[n - 1], e[n], e[n + 1], e[n + 2], e[n + 3], t), !isNaN(s[0]) && (r.push(s[0]), r.push(s[1]), r.push(e[n]), r.push(e[n + 1]), r.push(s[2]), r.push(s[3])); return r } let we = class extends G { constructor(t) { super(t), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function () { this._clearCache("tensionPoints") }) } _sceneFunc(t) { var i = this.points(), r = i.length, n = this.tension(), s = this.closed(), a = this.bezier(), o, l, h; if (r) { if (t.beginPath(), t.moveTo(i[0], i[1]), n !== 0 && r > 4) { for (o = this.getTensionPoints(), l = o.length, h = s ? 0 : 4, s || t.quadraticCurveTo(o[0], o[1], o[2], o[3]); h < l - 2;)t.bezierCurveTo(o[h++], o[h++], o[h++], o[h++], o[h++], o[h++]); s || t.quadraticCurveTo(o[l - 2], o[l - 1], i[r - 2], i[r - 1]) } else if (a) for (h = 2; h < r;)t.bezierCurveTo(i[h++], i[h++], i[h++], i[h++], i[h++], i[h++]); else for (h = 2; h < r; h += 2)t.lineTo(i[h], i[h + 1]); s ? (t.closePath(), t.fillStrokeShape(this)) : t.strokeShape(this) } } getTensionPoints() { return this._getCache("tensionPoints", this._getTensionPoints) } _getTensionPoints() { return this.closed() ? this._getTensionPointsClosed() : po(this.points(), this.tension()) } _getTensionPointsClosed() { var t = this.points(), i = t.length, r = this.tension(), n = bs(t[i - 2], t[i - 1], t[0], t[1], t[2], t[3], r), s = bs(t[i - 4], t[i - 3], t[i - 2], t[i - 1], t[0], t[1], r), a = po(t, r), o = [n[2], n[3]].concat(a).concat([s[0], s[1], t[i - 2], t[i - 1], s[2], s[3], n[0], n[1], t[0], t[1]]); return o } getWidth() { return this.getSelfRect().width } getHeight() { return this.getSelfRect().height } getSelfRect() { var t = this.points(); if (t.length < 4) return { x: t[0] || 0, y: t[1] || 0, width: 0, height: 0 }; this.tension() !== 0 ? t = [t[0], t[1], ...this._getTensionPoints(), t[t.length - 2], t[t.length - 1]] : t = this.points(); for (var i = t[0], r = t[0], n = t[1], s = t[1], a, o, l = 0; l < t.length / 2; l++)a = t[l * 2], o = t[l * 2 + 1], i = Math.min(i, a), r = Math.max(r, a), n = Math.min(n, o), s = Math.max(s, o); return { x: i, y: n, width: r - i, height: s - n } } }; we.prototype.className = "Line"; we.prototype._attrsAffectingSize = ["points", "bezier", "tension"]; St(we); v.addGetterSetter(we, "closed", !1); v.addGetterSetter(we, "bezier", !1); v.addGetterSetter(we, "tension", 0, W()); v.addGetterSetter(we, "points", [], kd()); class gt extends G { constructor(t) { super(t), this.dataArray = [], this.pathLength = 0, this.dataArray = gt.parsePathData(this.data()), this.pathLength = 0; for (var i = 0; i < this.dataArray.length; ++i)this.pathLength += this.dataArray[i].pathLength; this.on("dataChange.konva", function () { this.dataArray = gt.parsePathData(this.data()), this.pathLength = 0; for (var r = 0; r < this.dataArray.length; ++r)this.pathLength += this.dataArray[r].pathLength }) } _sceneFunc(t) { var i = this.dataArray; t.beginPath(); for (var r = !1, n = 0; n < i.length; n++) { var s = i[n].command, a = i[n].points; switch (s) { case "L": t.lineTo(a[0], a[1]); break; case "M": t.moveTo(a[0], a[1]); break; case "C": t.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]); break; case "Q": t.quadraticCurveTo(a[0], a[1], a[2], a[3]); break; case "A": var o = a[0], l = a[1], h = a[2], c = a[3], f = a[4], u = a[5], g = a[6], d = a[7], y = h > c ? h : c, C = h > c ? 1 : h / c, b = h > c ? c / h : 1; t.translate(o, l), t.rotate(g), t.scale(C, b), t.arc(0, 0, y, f, f + u, 1 - d), t.scale(1 / C, 1 / b), t.rotate(-g), t.translate(-o, -l); break; case "z": r = !0, t.closePath(); break } } !r && !this.hasFill() ? t.strokeShape(this) : t.fillStrokeShape(this) } getSelfRect() { var t = []; this.dataArray.forEach(function (h) { if (h.command === "A") { var c = h.points[4], f = h.points[5], u = h.points[4] + f, g = Math.PI / 180; if (Math.abs(c - u) < g && (g = Math.abs(c - u)), f < 0) for (let d = c - g; d > u; d -= g) { const y = gt.getPointOnEllipticalArc(h.points[0], h.points[1], h.points[2], h.points[3], d, 0); t.push(y.x, y.y) } else for (let d = c + g; d < u; d += g) { const y = gt.getPointOnEllipticalArc(h.points[0], h.points[1], h.points[2], h.points[3], d, 0); t.push(y.x, y.y) } } else if (h.command === "C") for (let d = 0; d <= 1; d += .01) { const y = gt.getPointOnCubicBezier(d, h.start.x, h.start.y, h.points[0], h.points[1], h.points[2], h.points[3], h.points[4], h.points[5]); t.push(y.x, y.y) } else t = t.concat(h.points) }); for (var i = t[0], r = t[0], n = t[1], s = t[1], a, o, l = 0; l < t.length / 2; l++)a = t[l * 2], o = t[l * 2 + 1], isNaN(a) || (i = Math.min(i, a), r = Math.max(r, a)), isNaN(o) || (n = Math.min(n, o), s = Math.max(s, o)); return { x: i, y: n, width: r - i, height: s - n } } getLength() { return this.pathLength } getPointAtLength(t) { var i, r = 0, n = this.dataArray.length; if (!n) return null; for (; r < n && t > this.dataArray[r].pathLength;)t -= this.dataArray[r].pathLength, ++r; if (r === n) return i = this.dataArray[r - 1].points.slice(-2), { x: i[0], y: i[1] }; if (t < .01) return i = this.dataArray[r].points.slice(0, 2), { x: i[0], y: i[1] }; var s = this.dataArray[r], a = s.points; switch (s.command) { case "L": return gt.getPointOnLine(t, s.start.x, s.start.y, a[0], a[1]); case "C": return gt.getPointOnCubicBezier(t / s.pathLength, s.start.x, s.start.y, a[0], a[1], a[2], a[3], a[4], a[5]); case "Q": return gt.getPointOnQuadraticBezier(t / s.pathLength, s.start.x, s.start.y, a[0], a[1], a[2], a[3]); case "A": var o = a[0], l = a[1], h = a[2], c = a[3], f = a[4], u = a[5], g = a[6]; return f += u * t / s.pathLength, gt.getPointOnEllipticalArc(o, l, h, c, f, g) }return null } static getLineLength(t, i, r, n) { return Math.sqrt((r - t) * (r - t) + (n - i) * (n - i)) } static getPointOnLine(t, i, r, n, s, a, o) { a === void 0 && (a = i), o === void 0 && (o = r); var l = (s - r) / (n - i + 1e-8), h = Math.sqrt(t * t / (1 + l * l)); n < i && (h *= -1); var c = l * h, f; if (n === i) f = { x: a, y: o + c }; else if ((o - r) / (a - i + 1e-8) === l) f = { x: a + h, y: o + c }; else { var u, g, d = this.getLineLength(i, r, n, s), y = (a - i) * (n - i) + (o - r) * (s - r); y = y / (d * d), u = i + y * (n - i), g = r + y * (s - r); var C = this.getLineLength(a, o, u, g), b = Math.sqrt(t * t - C * C); h = Math.sqrt(b * b / (1 + l * l)), n < i && (h *= -1), c = l * h, f = { x: u + h, y: g + c } } return f } static getPointOnCubicBezier(t, i, r, n, s, a, o, l, h) { function c(C) { return C * C * C } function f(C) { return 3 * C * C * (1 - C) } function u(C) { return 3 * C * (1 - C) * (1 - C) } function g(C) { return (1 - C) * (1 - C) * (1 - C) } var d = l * c(t) + a * f(t) + n * u(t) + i * g(t), y = h * c(t) + o * f(t) + s * u(t) + r * g(t); return { x: d, y } } static getPointOnQuadraticBezier(t, i, r, n, s, a, o) { function l(g) { return g * g } function h(g) { return 2 * g * (1 - g) } function c(g) { return (1 - g) * (1 - g) } var f = a * l(t) + n * h(t) + i * c(t), u = o * l(t) + s * h(t) + r * c(t); return { x: f, y: u } } static getPointOnEllipticalArc(t, i, r, n, s, a) { var o = Math.cos(a), l = Math.sin(a), h = { x: r * Math.cos(s), y: n * Math.sin(s) }; return { x: t + (h.x * o - h.y * l), y: i + (h.x * l + h.y * o) } } static parsePathData(t) { if (!t) return []; var i = t, r = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"]; i = i.replace(new RegExp(" ", "g"), ","); for (var n = 0; n < r.length; n++)i = i.replace(new RegExp(r[n], "g"), "|" + r[n]); var s = i.split("|"), a = [], o = [], l = 0, h = 0, c = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi, f; for (n = 1; n < s.length; n++) { var u = s[n], g = u.charAt(0); for (u = u.slice(1), o.length = 0; f = c.exec(u);)o.push(f[0]); for (var d = [], y = 0, C = o.length; y < C; y++) { if (o[y] === "00") { d.push(0, 0); continue } var b = parseFloat(o[y]); isNaN(b) ? d.push(0) : d.push(b) } for (; d.length > 0 && !isNaN(d[0]);) { var p = null, m = [], w = l, A = h, T, R, E, L, O, I, D, k, P, V; switch (g) { case "l": l += d.shift(), h += d.shift(), p = "L", m.push(l, h); break; case "L": l = d.shift(), h = d.shift(), m.push(l, h); break; case "m": var H = d.shift(), $ = d.shift(); if (l += H, h += $, p = "M", a.length > 2 && a[a.length - 1].command === "z") { for (var Z = a.length - 2; Z >= 0; Z--)if (a[Z].command === "M") { l = a[Z].points[0] + H, h = a[Z].points[1] + $; break } } m.push(l, h), g = "l"; break; case "M": l = d.shift(), h = d.shift(), p = "M", m.push(l, h), g = "L"; break; case "h": l += d.shift(), p = "L", m.push(l, h); break; case "H": l = d.shift(), p = "L", m.push(l, h); break; case "v": h += d.shift(), p = "L", m.push(l, h); break; case "V": h = d.shift(), p = "L", m.push(l, h); break; case "C": m.push(d.shift(), d.shift(), d.shift(), d.shift()), l = d.shift(), h = d.shift(), m.push(l, h); break; case "c": m.push(l + d.shift(), h + d.shift(), l + d.shift(), h + d.shift()), l += d.shift(), h += d.shift(), p = "C", m.push(l, h); break; case "S": R = l, E = h, T = a[a.length - 1], T.command === "C" && (R = l + (l - T.points[2]), E = h + (h - T.points[3])), m.push(R, E, d.shift(), d.shift()), l = d.shift(), h = d.shift(), p = "C", m.push(l, h); break; case "s": R = l, E = h, T = a[a.length - 1], T.command === "C" && (R = l + (l - T.points[2]), E = h + (h - T.points[3])), m.push(R, E, l + d.shift(), h + d.shift()), l += d.shift(), h += d.shift(), p = "C", m.push(l, h); break; case "Q": m.push(d.shift(), d.shift()), l = d.shift(), h = d.shift(), m.push(l, h); break; case "q": m.push(l + d.shift(), h + d.shift()), l += d.shift(), h += d.shift(), p = "Q", m.push(l, h); break; case "T": R = l, E = h, T = a[a.length - 1], T.command === "Q" && (R = l + (l - T.points[0]), E = h + (h - T.points[1])), l = d.shift(), h = d.shift(), p = "Q", m.push(R, E, l, h); break; case "t": R = l, E = h, T = a[a.length - 1], T.command === "Q" && (R = l + (l - T.points[0]), E = h + (h - T.points[1])), l += d.shift(), h += d.shift(), p = "Q", m.push(R, E, l, h); break; case "A": L = d.shift(), O = d.shift(), I = d.shift(), D = d.shift(), k = d.shift(), P = l, V = h, l = d.shift(), h = d.shift(), p = "A", m = this.convertEndpointToCenterParameterization(P, V, l, h, D, k, L, O, I); break; case "a": L = d.shift(), O = d.shift(), I = d.shift(), D = d.shift(), k = d.shift(), P = l, V = h, l += d.shift(), h += d.shift(), p = "A", m = this.convertEndpointToCenterParameterization(P, V, l, h, D, k, L, O, I); break }a.push({ command: p || g, points: m, start: { x: w, y: A }, pathLength: this.calcLength(w, A, p || g, m) }) } (g === "z" || g === "Z") && a.push({ command: "z", points: [], start: void 0, pathLength: 0 }) } return a } static calcLength(t, i, r, n) { var s, a, o, l, h = gt; switch (r) { case "L": return h.getLineLength(t, i, n[0], n[1]); case "C": for (s = 0, a = h.getPointOnCubicBezier(0, t, i, n[0], n[1], n[2], n[3], n[4], n[5]), l = .01; l <= 1; l += .01)o = h.getPointOnCubicBezier(l, t, i, n[0], n[1], n[2], n[3], n[4], n[5]), s += h.getLineLength(a.x, a.y, o.x, o.y), a = o; return s; case "Q": for (s = 0, a = h.getPointOnQuadraticBezier(0, t, i, n[0], n[1], n[2], n[3]), l = .01; l <= 1; l += .01)o = h.getPointOnQuadraticBezier(l, t, i, n[0], n[1], n[2], n[3]), s += h.getLineLength(a.x, a.y, o.x, o.y), a = o; return s; case "A": s = 0; var c = n[4], f = n[5], u = n[4] + f, g = Math.PI / 180; if (Math.abs(c - u) < g && (g = Math.abs(c - u)), a = h.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], c, 0), f < 0) for (l = c - g; l > u; l -= g)o = h.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], l, 0), s += h.getLineLength(a.x, a.y, o.x, o.y), a = o; else for (l = c + g; l < u; l += g)o = h.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], l, 0), s += h.getLineLength(a.x, a.y, o.x, o.y), a = o; return o = h.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], u, 0), s += h.getLineLength(a.x, a.y, o.x, o.y), s }return 0 } static convertEndpointToCenterParameterization(t, i, r, n, s, a, o, l, h) { var c = h * (Math.PI / 180), f = Math.cos(c) * (t - r) / 2 + Math.sin(c) * (i - n) / 2, u = -1 * Math.sin(c) * (t - r) / 2 + Math.cos(c) * (i - n) / 2, g = f * f / (o * o) + u * u / (l * l); g > 1 && (o *= Math.sqrt(g), l *= Math.sqrt(g)); var d = Math.sqrt((o * o * (l * l) - o * o * (u * u) - l * l * (f * f)) / (o * o * (u * u) + l * l * (f * f))); s === a && (d *= -1), isNaN(d) && (d = 0); var y = d * o * u / l, C = d * -l * f / o, b = (t + r) / 2 + Math.cos(c) * y - Math.sin(c) * C, p = (i + n) / 2 + Math.sin(c) * y + Math.cos(c) * C, m = function (O) { return Math.sqrt(O[0] * O[0] + O[1] * O[1]) }, w = function (O, I) { return (O[0] * I[0] + O[1] * I[1]) / (m(O) * m(I)) }, A = function (O, I) { return (O[0] * I[1] < O[1] * I[0] ? -1 : 1) * Math.acos(w(O, I)) }, T = A([1, 0], [(f - y) / o, (u - C) / l]), R = [(f - y) / o, (u - C) / l], E = [(-1 * f - y) / o, (-1 * u - C) / l], L = A(R, E); return w(R, E) <= -1 && (L = Math.PI), w(R, E) >= 1 && (L = 0), a === 0 && L > 0 && (L = L - 2 * Math.PI), a === 1 && L < 0 && (L = L + 2 * Math.PI), [b, p, o, l, T, L, c, a] } } gt.prototype.className = "Path"; gt.prototype._attrsAffectingSize = ["data"]; St(gt); v.addGetterSetter(gt, "data"); class oi extends we { _sceneFunc(t) { super._sceneFunc(t); var i = Math.PI * 2, r = this.points(), n = r, s = this.tension() !== 0 && r.length > 4; s && (n = this.getTensionPoints()); var a = this.pointerLength(), o = r.length, l, h; if (s) { const u = [n[n.length - 4], n[n.length - 3], n[n.length - 2], n[n.length - 1], r[o - 2], r[o - 1]], g = gt.calcLength(n[n.length - 4], n[n.length - 3], "C", u), d = gt.getPointOnQuadraticBezier(Math.min(1, 1 - a / g), u[0], u[1], u[2], u[3], u[4], u[5]); l = r[o - 2] - d.x, h = r[o - 1] - d.y } else l = r[o - 2] - r[o - 4], h = r[o - 1] - r[o - 3]; var c = (Math.atan2(h, l) + i) % i, f = this.pointerWidth(); this.pointerAtEnding() && (t.save(), t.beginPath(), t.translate(r[o - 2], r[o - 1]), t.rotate(c), t.moveTo(0, 0), t.lineTo(-a, f / 2), t.lineTo(-a, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t)), this.pointerAtBeginning() && (t.save(), t.beginPath(), t.translate(r[0], r[1]), s ? (l = (n[0] + n[2]) / 2 - r[0], h = (n[1] + n[3]) / 2 - r[1]) : (l = r[2] - r[0], h = r[3] - r[1]), t.rotate((Math.atan2(-h, -l) + i) % i), t.moveTo(0, 0), t.lineTo(-a, f / 2), t.lineTo(-a, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t)) } __fillStroke(t) { var i = this.dashEnabled(); i && (this.attrs.dashEnabled = !1, t.setLineDash([])), t.fillStrokeShape(this), i && (this.attrs.dashEnabled = !0) } getSelfRect() { const t = super.getSelfRect(), i = this.pointerWidth() / 2; return { x: t.x - i, y: t.y - i, width: t.width + i * 2, height: t.height + i * 2 } } } oi.prototype.className = "Arrow"; St(oi); v.addGetterSetter(oi, "pointerLength", 10, W()); v.addGetterSetter(oi, "pointerWidth", 10, W()); v.addGetterSetter(oi, "pointerAtBeginning", !1); v.addGetterSetter(oi, "pointerAtEnding", !0); class Li extends G { _sceneFunc(t) { t.beginPath(), t.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, !1), t.closePath(), t.fillStrokeShape(this) } getWidth() { return this.radius() * 2 } getHeight() { return this.radius() * 2 } setWidth(t) { this.radius() !== t / 2 && this.radius(t / 2) } setHeight(t) { this.radius() !== t / 2 && this.radius(t / 2) } } Li.prototype._centroid = !0; Li.prototype.className = "Circle"; Li.prototype._attrsAffectingSize = ["radius"]; St(Li); v.addGetterSetter(Li, "radius", 0, W()); class He extends G { _sceneFunc(t) { var i = this.radiusX(), r = this.radiusY(); t.beginPath(), t.save(), i !== r && t.scale(1, r / i), t.arc(0, 0, i, 0, Math.PI * 2, !1), t.restore(), t.closePath(), t.fillStrokeShape(this) } getWidth() { return this.radiusX() * 2 } getHeight() { return this.radiusY() * 2 } setWidth(t) { this.radiusX(t / 2) } setHeight(t) { this.radiusY(t / 2) } } He.prototype.className = "Ellipse"; He.prototype._centroid = !0; He.prototype._attrsAffectingSize = ["radiusX", "radiusY"]; St(He); v.addComponentsGetterSetter(He, "radius", ["x", "y"]); v.addGetterSetter(He, "radiusX", 0, W()); v.addGetterSetter(He, "radiusY", 0, W()); let ue = class Mh extends G { constructor(t) { super(t), this.on("imageChange.konva", () => { this._setImageLoad() }), this._setImageLoad() } _setImageLoad() { const t = this.image(); t && t.complete || t && t.readyState === 4 || t && t.addEventListener && t.addEventListener("load", () => { this._requestDraw() }) } _useBufferCanvas() { return super._useBufferCanvas(!0) } _sceneFunc(t) { const i = this.getWidth(), r = this.getHeight(), n = this.cornerRadius(), s = this.attrs.image; let a; if (s) { const o = this.attrs.cropWidth, l = this.attrs.cropHeight; o && l ? a = [s, this.cropX(), this.cropY(), o, l, 0, 0, i, r] : a = [s, 0, 0, i, r] } (this.hasFill() || this.hasStroke() || n) && (t.beginPath(), n ? x.drawRoundedRectPath(t, i, r, n) : t.rect(0, 0, i, r), t.closePath(), t.fillStrokeShape(this)), s && (n && t.clip(), t.drawImage.apply(t, a)) } _hitFunc(t) { var i = this.width(), r = this.height(), n = this.cornerRadius(); t.beginPath(), n ? x.drawRoundedRectPath(t, i, r, n) : t.rect(0, 0, i, r), t.closePath(), t.fillStrokeShape(this) } getWidth() { var t, i; return (t = this.attrs.width) !== null && t !== void 0 ? t : (i = this.image()) === null || i === void 0 ? void 0 : i.width } getHeight() { var t, i; return (t = this.attrs.height) !== null && t !== void 0 ? t : (i = this.image()) === null || i === void 0 ? void 0 : i.height } static fromURL(t, i, r = null) { var n = x.createImageElement(); n.onload = function () { var s = new Mh({ image: n }); i(s) }, n.onerror = r, n.crossOrigin = "Anonymous", n.src = t } }; ue.prototype.className = "Image"; St(ue); v.addGetterSetter(ue, "cornerRadius", 0, aa(4)); v.addGetterSetter(ue, "image"); v.addComponentsGetterSetter(ue, "crop", ["x", "y", "width", "height"]); v.addGetterSetter(ue, "cropX", 0, W()); v.addGetterSetter(ue, "cropY", 0, W()); v.addGetterSetter(ue, "cropWidth", 0, W()); v.addGetterSetter(ue, "cropHeight", 0, W()); var Rh = ["fontFamily", "fontSize", "fontStyle", "padding", "lineHeight", "text", "width", "height", "pointerDirection", "pointerWidth", "pointerHeight"], bg = "Change.konva", Cg = "none", Cs = "up", Ss = "right", ws = "down", xs = "left", Sg = Rh.length; class fa extends Ai { constructor(t) { super(t), this.on("add.konva", function (i) { this._addListeners(i.child), this._sync() }) } getText() { return this.find("Text")[0] } getTag() { return this.find("Tag")[0] } _addListeners(t) { var i = this, r, n = function () { i._sync() }; for (r = 0; r < Sg; r++)t.on(Rh[r] + bg, n) } getWidth() { return this.getText().width() } getHeight() { return this.getText().height() } _sync() { var t = this.getText(), i = this.getTag(), r, n, s, a, o, l, h; if (t && i) { switch (r = t.width(), n = t.height(), s = i.pointerDirection(), a = i.pointerWidth(), h = i.pointerHeight(), o = 0, l = 0, s) { case Cs: o = r / 2, l = -1 * h; break; case Ss: o = r + a, l = n / 2; break; case ws: o = r / 2, l = n + h; break; case xs: o = -1 * a, l = n / 2; break }i.setAttrs({ x: -1 * o, y: -1 * l, width: r, height: n }), t.setAttrs({ x: -1 * o, y: -1 * l }) } } } fa.prototype.className = "Label"; St(fa); class li extends G { _sceneFunc(t) { var i = this.width(), r = this.height(), n = this.pointerDirection(), s = this.pointerWidth(), a = this.pointerHeight(), o = this.cornerRadius(); let l = 0, h = 0, c = 0, f = 0; typeof o == "number" ? l = h = c = f = Math.min(o, i / 2, r / 2) : (l = Math.min(o[0] || 0, i / 2, r / 2), h = Math.min(o[1] || 0, i / 2, r / 2), f = Math.min(o[2] || 0, i / 2, r / 2), c = Math.min(o[3] || 0, i / 2, r / 2)), t.beginPath(), t.moveTo(l, 0), n === Cs && (t.lineTo((i - s) / 2, 0), t.lineTo(i / 2, -1 * a), t.lineTo((i + s) / 2, 0)), t.lineTo(i - h, 0), t.arc(i - h, h, h, Math.PI * 3 / 2, 0, !1), n === Ss && (t.lineTo(i, (r - a) / 2), t.lineTo(i + s, r / 2), t.lineTo(i, (r + a) / 2)), t.lineTo(i, r - f), t.arc(i - f, r - f, f, 0, Math.PI / 2, !1), n === ws && (t.lineTo((i + s) / 2, r), t.lineTo(i / 2, r + a), t.lineTo((i - s) / 2, r)), t.lineTo(c, r), t.arc(c, r - c, c, Math.PI / 2, Math.PI, !1), n === xs && (t.lineTo(0, (r + a) / 2), t.lineTo(-1 * s, r / 2), t.lineTo(0, (r - a) / 2)), t.lineTo(0, l), t.arc(l, l, l, Math.PI, Math.PI * 3 / 2, !1), t.closePath(), t.fillStrokeShape(this) } getSelfRect() { var t = 0, i = 0, r = this.pointerWidth(), n = this.pointerHeight(), s = this.pointerDirection(), a = this.width(), o = this.height(); return s === Cs ? (i -= n, o += n) : s === ws ? o += n : s === xs ? (t -= r * 1.5, a += r) : s === Ss && (a += r * 1.5), { x: t, y: i, width: a, height: o } } } li.prototype.className = "Tag"; St(li); v.addGetterSetter(li, "pointerDirection", Cg); v.addGetterSetter(li, "pointerWidth", 0, W()); v.addGetterSetter(li, "pointerHeight", 0, W()); v.addGetterSetter(li, "cornerRadius", 0, aa(4)); class wr extends G { _sceneFunc(t) { var i = this.cornerRadius(), r = this.width(), n = this.height(); t.beginPath(), i ? x.drawRoundedRectPath(t, r, n, i) : t.rect(0, 0, r, n), t.closePath(), t.fillStrokeShape(this) } } wr.prototype.className = "Rect"; St(wr); v.addGetterSetter(wr, "cornerRadius", 0, aa(4)); class hi extends G { _sceneFunc(t) { const i = this._getPoints(); t.beginPath(), t.moveTo(i[0].x, i[0].y); for (var r = 1; r < i.length; r++)t.lineTo(i[r].x, i[r].y); t.closePath(), t.fillStrokeShape(this) } _getPoints() { const t = this.attrs.sides, i = this.attrs.radius || 0, r = []; for (var n = 0; n < t; n++)r.push({ x: i * Math.sin(n * 2 * Math.PI / t), y: -1 * i * Math.cos(n * 2 * Math.PI / t) }); return r } getSelfRect() { const t = this._getPoints(); var i = t[0].x, r = t[0].y, n = t[0].x, s = t[0].y; return t.forEach(a => { i = Math.min(i, a.x), r = Math.max(r, a.x), n = Math.min(n, a.y), s = Math.max(s, a.y) }), { x: i, y: n, width: r - i, height: s - n } } getWidth() { return this.radius() * 2 } getHeight() { return this.radius() * 2 } setWidth(t) { this.radius(t / 2) } setHeight(t) { this.radius(t / 2) } } hi.prototype.className = "RegularPolygon"; hi.prototype._centroid = !0; hi.prototype._attrsAffectingSize = ["radius"]; St(hi); v.addGetterSetter(hi, "radius", 0, W()); v.addGetterSetter(hi, "sides", 0, W()); var vo = Math.PI * 2; class ci extends G { _sceneFunc(t) { t.beginPath(), t.arc(0, 0, this.innerRadius(), 0, vo, !1), t.moveTo(this.outerRadius(), 0), t.arc(0, 0, this.outerRadius(), vo, 0, !0), t.closePath(), t.fillStrokeShape(this) } getWidth() { return this.outerRadius() * 2 } getHeight() { return this.outerRadius() * 2 } setWidth(t) { this.outerRadius(t / 2) } setHeight(t) { this.outerRadius(t / 2) } } ci.prototype.className = "Ring"; ci.prototype._centroid = !0; ci.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"]; St(ci); v.addGetterSetter(ci, "innerRadius", 0, W()); v.addGetterSetter(ci, "outerRadius", 0, W()); class de extends G { constructor(t) { super(t), this._updated = !0, this.anim = new te(() => { var i = this._updated; return this._updated = !1, i }), this.on("animationChange.konva", function () { this.frameIndex(0) }), this.on("frameIndexChange.konva", function () { this._updated = !0 }), this.on("frameRateChange.konva", function () { this.anim.isRunning() && (clearInterval(this.interval), this._setInterval()) }) } _sceneFunc(t) { var i = this.animation(), r = this.frameIndex(), n = r * 4, s = this.animations()[i], a = this.frameOffsets(), o = s[n + 0], l = s[n + 1], h = s[n + 2], c = s[n + 3], f = this.image(); if ((this.hasFill() || this.hasStroke()) && (t.beginPath(), t.rect(0, 0, h, c), t.closePath(), t.fillStrokeShape(this)), f) if (a) { var u = a[i], g = r * 2; t.drawImage(f, o, l, h, c, u[g + 0], u[g + 1], h, c) } else t.drawImage(f, o, l, h, c, 0, 0, h, c) } _hitFunc(t) { var i = this.animation(), r = this.frameIndex(), n = r * 4, s = this.animations()[i], a = this.frameOffsets(), o = s[n + 2], l = s[n + 3]; if (t.beginPath(), a) { var h = a[i], c = r * 2; t.rect(h[c + 0], h[c + 1], o, l) } else t.rect(0, 0, o, l); t.closePath(), t.fillShape(this) } _useBufferCanvas() { return super._useBufferCanvas(!0) } _setInterval() { var t = this; this.interval = setInterval(function () { t._updateIndex() }, 1e3 / this.frameRate()) } start() { if (!this.isRunning()) { var t = this.getLayer(); this.anim.setLayers(t), this._setInterval(), this.anim.start() } } stop() { this.anim.stop(), clearInterval(this.interval) } isRunning() { return this.anim.isRunning() } _updateIndex() { var t = this.frameIndex(), i = this.animation(), r = this.animations(), n = r[i], s = n.length / 4; t < s - 1 ? this.frameIndex(t + 1) : this.frameIndex(0) } } de.prototype.className = "Sprite"; St(de); v.addGetterSetter(de, "animation"); v.addGetterSetter(de, "animations"); v.addGetterSetter(de, "frameOffsets"); v.addGetterSetter(de, "image"); v.addGetterSetter(de, "frameIndex", 0, W()); v.addGetterSetter(de, "frameRate", 17, W()); v.backCompat(de, { index: "frameIndex", getIndex: "getFrameIndex", setIndex: "setFrameIndex" }); class Ue extends G { _sceneFunc(t) { var i = this.innerRadius(), r = this.outerRadius(), n = this.numPoints(); t.beginPath(), t.moveTo(0, 0 - r); for (var s = 1; s < n * 2; s++) { var a = s % 2 === 0 ? r : i, o = a * Math.sin(s * Math.PI / n), l = -1 * a * Math.cos(s * Math.PI / n); t.lineTo(o, l) } t.closePath(), t.fillStrokeShape(this) } getWidth() { return this.outerRadius() * 2 } getHeight() { return this.outerRadius() * 2 } setWidth(t) { this.outerRadius(t / 2) } setHeight(t) { this.outerRadius(t / 2) } } Ue.prototype.className = "Star"; Ue.prototype._centroid = !0; Ue.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"]; St(Ue); v.addGetterSetter(Ue, "numPoints", 5, W()); v.addGetterSetter(Ue, "innerRadius", 0, W()); v.addGetterSetter(Ue, "outerRadius", 0, W()); function Oh(e) { return Array.from(e) } var gi = "auto", wg = "center", Hi = "justify", xg = "Change.konva", Eg = "2d", mo = "-", Lh = "left", Tg = "text", Pg = "Text", Ag = "top", kg = "bottom", _o = "middle", Ih = "normal", Mg = "px ", zr = " ", Rg = "right", Og = "word", Lg = "char", yo = "none", Xn = "", Dh = ["fontFamily", "fontSize", "fontStyle", "fontVariant", "padding", "align", "verticalAlign", "lineHeight", "text", "width", "height", "wrap", "ellipsis", "letterSpacing"], Ig = Dh.length; function Dg(e) { return e.split(",").map(t => { t = t.trim(); const i = t.indexOf(" ") >= 0, r = t.indexOf('"') >= 0 || t.indexOf("'") >= 0; return i && !r && (t = `"${t}"`), t }).join(", ") } var Yr; function $n() { return Yr || (Yr = x.createCanvasElement().getContext(Eg), Yr) } function Ng(e) { e.fillText(this._partialText, this._partialTextX, this._partialTextY) } function Fg(e) { e.strokeText(this._partialText, this._partialTextX, this._partialTextY) } function Gg(e) { return e = e || {}, !e.fillLinearGradientColorStops && !e.fillRadialGradientColorStops && !e.fillPatternImage && (e.fill = e.fill || "black"), e } class Ct extends G {
  constructor(t) { super(Gg(t)), this._partialTextX = 0, this._partialTextY = 0; for (var i = 0; i < Ig; i++)this.on(Dh[i] + xg, this._setTextData); this._setTextData() } _sceneFunc(t) { var i = this.textArr, r = i.length; if (this.text()) { var n = this.padding(), s = this.fontSize(), a = this.lineHeight() * s, o = this.verticalAlign(), l = 0, h = this.align(), c = this.getWidth(), f = this.letterSpacing(), u = this.fill(), g = this.textDecoration(), d = g.indexOf("underline") !== -1, y = g.indexOf("line-through") !== -1, C, b = 0, b = a / 2, p = 0, m = 0; for (t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", _o), t.setAttr("textAlign", Lh), o === _o ? l = (this.getHeight() - r * a - n * 2) / 2 : o === kg && (l = this.getHeight() - r * a - n * 2), t.translate(n, l + n), C = 0; C < r; C++) { var p = 0, m = 0, w = i[C], A = w.text, T = w.width, R = w.lastInParagraph, E, L, O; if (t.save(), h === Rg ? p += c - T - n * 2 : h === wg && (p += (c - T - n * 2) / 2), d) { t.save(), t.beginPath(), t.moveTo(p, b + m + Math.round(s / 2)), E = A.split(" ").length - 1, L = E === 0, O = h === Hi && !R ? c - n * 2 : T, t.lineTo(p + Math.round(O), b + m + Math.round(s / 2)), t.lineWidth = s / 15; const H = this._getLinearGradient(); t.strokeStyle = H || u, t.stroke(), t.restore() } if (y) { t.save(), t.beginPath(), t.moveTo(p, b + m), E = A.split(" ").length - 1, L = E === 0, O = h === Hi && R && !L ? c - n * 2 : T, t.lineTo(p + Math.round(O), b + m), t.lineWidth = s / 15; const H = this._getLinearGradient(); t.strokeStyle = H || u, t.stroke(), t.restore() } if (f !== 0 || h === Hi) { E = A.split(" ").length - 1; for (var I = Oh(A), D = 0; D < I.length; D++) { var k = I[D]; k === " " && !R && h === Hi && (p += (c - n * 2 - T) / E), this._partialTextX = p, this._partialTextY = b + m, this._partialText = k, t.fillStrokeShape(this), p += this.measureSize(k).width + f } } else this._partialTextX = p, this._partialTextY = b + m, this._partialText = A, t.fillStrokeShape(this); t.restore(), r > 1 && (b += a) } } } _hitFunc(t) { var i = this.getWidth(), r = this.getHeight(); t.beginPath(), t.rect(0, 0, i, r), t.closePath(), t.fillStrokeShape(this) } setText(t) { var i = x._isString(t) ? t : t == null ? "" : t + ""; return this._setAttr(Tg, i), this } getWidth() { var t = this.attrs.width === gi || this.attrs.width === void 0; return t ? this.getTextWidth() + this.padding() * 2 : this.attrs.width } getHeight() { var t = this.attrs.height === gi || this.attrs.height === void 0; return t ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height } getTextWidth() { return this.textWidth } getTextHeight() { return x.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight } measureSize(t) { var i = $n(), r = this.fontSize(), n; return i.save(), i.font = this._getContextFont(), n = i.measureText(t), i.restore(), { width: n.width, height: r } } _getContextFont() { return this.fontStyle() + zr + this.fontVariant() + zr + (this.fontSize() + Mg) + Dg(this.fontFamily()) } _addTextLine(t) { this.align() === Hi && (t = t.trim()); var r = this._getTextWidth(t); return this.textArr.push({ text: t, width: r, lastInParagraph: !1 }) } _getTextWidth(t) { var i = this.letterSpacing(), r = t.length; return $n().measureText(t).width + (r ? i * (r - 1) : 0) } _setTextData() {
    var t = this.text().split(`
`), i = +this.fontSize(), r = 0, n = this.lineHeight() * i, s = this.attrs.width, a = this.attrs.height, o = s !== gi && s !== void 0, l = a !== gi && a !== void 0, h = this.padding(), c = s - h * 2, f = a - h * 2, u = 0, g = this.wrap(), d = g !== yo, y = g !== Lg && d, C = this.ellipsis(); this.textArr = [], $n().font = this._getContextFont(); for (var b = C ? this._getTextWidth(Xn) : 0, p = 0, m = t.length; p < m; ++p) { var w = t[p], A = this._getTextWidth(w); if (o && A > c) for (; w.length > 0;) { for (var T = 0, R = w.length, E = "", L = 0; T < R;) { var O = T + R >>> 1, I = w.slice(0, O + 1), D = this._getTextWidth(I) + b; D <= c ? (T = O + 1, E = I, L = D) : R = O } if (E) { if (y) { var k, P = w[E.length], V = P === zr || P === mo; V && L <= c ? k = E.length : k = Math.max(E.lastIndexOf(zr), E.lastIndexOf(mo)) + 1, k > 0 && (T = k, E = E.slice(0, T), L = this._getTextWidth(E)) } E = E.trimRight(), this._addTextLine(E), r = Math.max(r, L), u += n; var H = this._shouldHandleEllipsis(u); if (H) { this._tryToAddEllipsisToLastLine(); break } if (w = w.slice(T), w = w.trimLeft(), w.length > 0 && (A = this._getTextWidth(w), A <= c)) { this._addTextLine(w), u += n, r = Math.max(r, A); break } } else break } else this._addTextLine(w), u += n, r = Math.max(r, A), this._shouldHandleEllipsis(u) && p < m - 1 && this._tryToAddEllipsisToLastLine(); if (this.textArr[this.textArr.length - 1] && (this.textArr[this.textArr.length - 1].lastInParagraph = !0), l && u + n > f) break } this.textHeight = i, this.textWidth = r
  } _shouldHandleEllipsis(t) { var i = +this.fontSize(), r = this.lineHeight() * i, n = this.attrs.height, s = n !== gi && n !== void 0, a = this.padding(), o = n - a * 2, l = this.wrap(), h = l !== yo; return !h || s && t + r > o } _tryToAddEllipsisToLastLine() { var t = this.attrs.width, i = t !== gi && t !== void 0, r = this.padding(), n = t - r * 2, s = this.ellipsis(), a = this.textArr[this.textArr.length - 1]; if (!(!a || !s)) { if (i) { var o = this._getTextWidth(a.text + Xn) < n; o || (a.text = a.text.slice(0, a.text.length - 3)) } this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(a.text + Xn) } } getStrokeScaleEnabled() { return !0 }
} Ct.prototype._fillFunc = Ng; Ct.prototype._strokeFunc = Fg; Ct.prototype.className = Pg; Ct.prototype._attrsAffectingSize = ["text", "fontSize", "padding", "wrap", "lineHeight", "letterSpacing"]; St(Ct); v.overWriteSetter(Ct, "width", oa()); v.overWriteSetter(Ct, "height", oa()); v.addGetterSetter(Ct, "fontFamily", "Arial"); v.addGetterSetter(Ct, "fontSize", 12, W()); v.addGetterSetter(Ct, "fontStyle", Ih); v.addGetterSetter(Ct, "fontVariant", Ih); v.addGetterSetter(Ct, "padding", 0, W()); v.addGetterSetter(Ct, "align", Lh); v.addGetterSetter(Ct, "verticalAlign", Ag); v.addGetterSetter(Ct, "lineHeight", 1, W()); v.addGetterSetter(Ct, "wrap", Og); v.addGetterSetter(Ct, "ellipsis", !1, ae()); v.addGetterSetter(Ct, "letterSpacing", 0, W()); v.addGetterSetter(Ct, "text", "", Oi()); v.addGetterSetter(Ct, "textDecoration", ""); var Bg = "", Nh = "normal"; function Fh(e) { e.fillText(this.partialText, 0, 0) } function Gh(e) { e.strokeText(this.partialText, 0, 0) } class Mt extends G { constructor(t) { super(t), this.dummyCanvas = x.createCanvasElement(), this.dataArray = [], this.dataArray = gt.parsePathData(this.attrs.data), this.on("dataChange.konva", function () { this.dataArray = gt.parsePathData(this.attrs.data), this._setTextData() }), this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData), this._setTextData() } _sceneFunc(t) { t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", this.textBaseline()), t.setAttr("textAlign", "left"), t.save(); var i = this.textDecoration(), r = this.fill(), n = this.fontSize(), s = this.glyphInfo; i === "underline" && t.beginPath(); for (var a = 0; a < s.length; a++) { t.save(); var o = s[a].p0; t.translate(o.x, o.y), t.rotate(s[a].rotation), this.partialText = s[a].text, t.fillStrokeShape(this), i === "underline" && (a === 0 && t.moveTo(0, n / 2 + 1), t.lineTo(n, n / 2 + 1)), t.restore() } i === "underline" && (t.strokeStyle = r, t.lineWidth = n / 20, t.stroke()), t.restore() } _hitFunc(t) { t.beginPath(); var i = this.glyphInfo; if (i.length >= 1) { var r = i[0].p0; t.moveTo(r.x, r.y) } for (var n = 0; n < i.length; n++) { var s = i[n].p1; t.lineTo(s.x, s.y) } t.setAttr("lineWidth", this.fontSize()), t.setAttr("strokeStyle", this.colorKey), t.stroke() } getTextWidth() { return this.textWidth } getTextHeight() { return x.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight } setText(t) { return Ct.prototype.setText.call(this, t) } _getContextFont() { return Ct.prototype._getContextFont.call(this) } _getTextSize(t) { var i = this.dummyCanvas, r = i.getContext("2d"); r.save(), r.font = this._getContextFont(); var n = r.measureText(t); return r.restore(), { width: n.width, height: parseInt(this.attrs.fontSize, 10) } } _setTextData() { var t = this, i = this._getTextSize(this.attrs.text), r = this.letterSpacing(), n = this.align(), s = this.kerningFunc(); this.textWidth = i.width, this.textHeight = i.height; var a = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * r, 0); this.glyphInfo = []; for (var o = 0, l = 0; l < t.dataArray.length; l++)t.dataArray[l].pathLength > 0 && (o += t.dataArray[l].pathLength); var h = 0; n === "center" && (h = Math.max(0, o / 2 - a / 2)), n === "right" && (h = Math.max(0, o - a)); for (var c = Oh(this.text()), f = this.text().split(" ").length - 1, u, g, d, y = -1, C = 0, b = function () { C = 0; for (var D = t.dataArray, k = y + 1; k < D.length; k++) { if (D[k].pathLength > 0) return y = k, D[k]; D[k].command === "M" && (u = { x: D[k].points[0], y: D[k].points[1] }) } return {} }, p = function (D) { var k = t._getTextSize(D).width + r; D === " " && n === "justify" && (k += (o - a) / f); var P = 0, V = 0; for (g = void 0; Math.abs(k - P) / k > .01 && V < 20;) { V++; for (var H = P; d === void 0;)d = b(), d && H + d.pathLength < k && (H += d.pathLength, d = void 0); if (Object.keys(d).length === 0 || u === void 0) return; var $ = !1; switch (d.command) { case "L": gt.getLineLength(u.x, u.y, d.points[0], d.points[1]) > k ? g = gt.getPointOnLine(k, u.x, u.y, d.points[0], d.points[1], u.x, u.y) : d = void 0; break; case "A": var Z = d.points[4], st = d.points[5], q = d.points[4] + st; C === 0 ? C = Z + 1e-8 : k > P ? C += Math.PI / 180 * st / Math.abs(st) : C -= Math.PI / 360 * st / Math.abs(st), (st < 0 && C < q || st >= 0 && C > q) && (C = q, $ = !0), g = gt.getPointOnEllipticalArc(d.points[0], d.points[1], d.points[2], d.points[3], C, d.points[6]); break; case "C": C === 0 ? k > d.pathLength ? C = 1e-8 : C = k / d.pathLength : k > P ? C += (k - P) / d.pathLength / 2 : C = Math.max(C - (P - k) / d.pathLength / 2, 0), C > 1 && (C = 1, $ = !0), g = gt.getPointOnCubicBezier(C, d.start.x, d.start.y, d.points[0], d.points[1], d.points[2], d.points[3], d.points[4], d.points[5]); break; case "Q": C === 0 ? C = k / d.pathLength : k > P ? C += (k - P) / d.pathLength : C -= (P - k) / d.pathLength, C > 1 && (C = 1, $ = !0), g = gt.getPointOnQuadraticBezier(C, d.start.x, d.start.y, d.points[0], d.points[1], d.points[2], d.points[3]); break }g !== void 0 && (P = gt.getLineLength(u.x, u.y, g.x, g.y)), $ && ($ = !1, d = void 0) } }, m = "C", w = t._getTextSize(m).width + r, A = h / w - 1, T = 0; T < A && (p(m), !(u === void 0 || g === void 0)); T++)u = g; for (var R = 0; R < c.length && (p(c[R]), !(u === void 0 || g === void 0)); R++) { var E = gt.getLineLength(u.x, u.y, g.x, g.y), L = 0; if (s) try { L = s(c[R - 1], c[R]) * this.fontSize() } catch { L = 0 } u.x += L, g.x += L, this.textWidth += L; var O = gt.getPointOnLine(L + E / 2, u.x, u.y, g.x, g.y), I = Math.atan2(g.y - u.y, g.x - u.x); this.glyphInfo.push({ transposeX: O.x, transposeY: O.y, text: c[R], rotation: I, p0: u, p1: g }), u = g } } getSelfRect() { if (!this.glyphInfo.length) return { x: 0, y: 0, width: 0, height: 0 }; var t = []; this.glyphInfo.forEach(function (c) { t.push(c.p0.x), t.push(c.p0.y), t.push(c.p1.x), t.push(c.p1.y) }); for (var i = t[0] || 0, r = t[0] || 0, n = t[1] || 0, s = t[1] || 0, a, o, l = 0; l < t.length / 2; l++)a = t[l * 2], o = t[l * 2 + 1], i = Math.min(i, a), r = Math.max(r, a), n = Math.min(n, o), s = Math.max(s, o); var h = this.fontSize(); return { x: i - h / 2, y: n - h / 2, width: r - i + h, height: s - n + h } } destroy() { return x.releaseCanvas(this.dummyCanvas), super.destroy() } } Mt.prototype._fillFunc = Fh; Mt.prototype._strokeFunc = Gh; Mt.prototype._fillFuncHit = Fh; Mt.prototype._strokeFuncHit = Gh; Mt.prototype.className = "TextPath"; Mt.prototype._attrsAffectingSize = ["text", "fontSize", "data"]; St(Mt); v.addGetterSetter(Mt, "data"); v.addGetterSetter(Mt, "fontFamily", "Arial"); v.addGetterSetter(Mt, "fontSize", 12, W()); v.addGetterSetter(Mt, "fontStyle", Nh); v.addGetterSetter(Mt, "align", "left"); v.addGetterSetter(Mt, "letterSpacing", 0, W()); v.addGetterSetter(Mt, "textBaseline", "middle"); v.addGetterSetter(Mt, "fontVariant", Nh); v.addGetterSetter(Mt, "text", Bg); v.addGetterSetter(Mt, "textDecoration", null); v.addGetterSetter(Mt, "kerningFunc", null); var Bh = "tr-konva", Hg = ["resizeEnabledChange", "rotateAnchorOffsetChange", "rotateEnabledChange", "enabledAnchorsChange", "anchorSizeChange", "borderEnabledChange", "borderStrokeChange", "borderStrokeWidthChange", "borderDashChange", "anchorStrokeChange", "anchorStrokeWidthChange", "anchorFillChange", "anchorCornerRadiusChange", "ignoreStrokeChange"].map(e => e + `.${Bh}`).join(" "), bo = "nodesRect", Ug = ["widthChange", "heightChange", "scaleXChange", "scaleYChange", "skewXChange", "skewYChange", "rotationChange", "offsetXChange", "offsetYChange", "transformsEnabledChange", "strokeWidthChange"], Wg = { "top-left": -45, "top-center": 0, "top-right": 45, "middle-right": -90, "middle-left": 90, "bottom-left": -135, "bottom-center": 180, "bottom-right": 135 }; const jg = "ontouchstart" in X._global; function zg(e, t) { if (e === "rotater") return "crosshair"; t += x.degToRad(Wg[e] || 0); var i = (x.radToDeg(t) % 360 + 360) % 360; return x._inRange(i, 315 + 22.5, 360) || x._inRange(i, 0, 22.5) ? "ns-resize" : x._inRange(i, 45 - 22.5, 45 + 22.5) ? "nesw-resize" : x._inRange(i, 90 - 22.5, 90 + 22.5) ? "ew-resize" : x._inRange(i, 135 - 22.5, 135 + 22.5) ? "nwse-resize" : x._inRange(i, 180 - 22.5, 180 + 22.5) ? "ns-resize" : x._inRange(i, 225 - 22.5, 225 + 22.5) ? "nesw-resize" : x._inRange(i, 270 - 22.5, 270 + 22.5) ? "ew-resize" : x._inRange(i, 315 - 22.5, 315 + 22.5) ? "nwse-resize" : (x.error("Transformer has unknown angle for cursor detection: " + i), "pointer") } var cn = ["top-left", "top-center", "top-right", "middle-right", "middle-left", "bottom-left", "bottom-center", "bottom-right"], Co = 1e8; function Yg(e) { return { x: e.x + e.width / 2 * Math.cos(e.rotation) + e.height / 2 * Math.sin(-e.rotation), y: e.y + e.height / 2 * Math.cos(e.rotation) + e.width / 2 * Math.sin(e.rotation) } } function Hh(e, t, i) { const r = i.x + (e.x - i.x) * Math.cos(t) - (e.y - i.y) * Math.sin(t), n = i.y + (e.x - i.x) * Math.sin(t) + (e.y - i.y) * Math.cos(t); return Object.assign(Object.assign({}, e), { rotation: e.rotation + t, x: r, y: n }) } function Vg(e, t) { const i = Yg(e); return Hh(e, t, i) } function Kg(e, t, i) { let r = t; for (let n = 0; n < e.length; n++) { const s = X.getAngle(e[n]), a = Math.abs(s - t) % (Math.PI * 2); Math.min(a, Math.PI * 2 - a) < i && (r = s) } return r } class ft extends Ai { constructor(t) { super(t), this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(Hg, this.update), this.getNode() && this.update() } attachTo(t) { return this.setNode(t), this } setNode(t) { return x.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([t]) } getNode() { return this._nodes && this._nodes[0] } _getEventNamespace() { return Bh + this._id } setNodes(t = []) { this._nodes && this._nodes.length && this.detach(); const i = t.filter(n => n.isAncestorOf(this) ? (x.error("Konva.Transformer cannot be an a child of the node you are trying to attach"), !1) : !0); this._nodes = t = i, t.length === 1 && this.useSingleNodeRotation() ? this.rotation(t[0].getAbsoluteRotation()) : this.rotation(0), this._nodes.forEach(n => { const s = () => { this.nodes().length === 1 && this.useSingleNodeRotation() && this.rotation(this.nodes()[0].getAbsoluteRotation()), this._resetTransformCache(), !this._transforming && !this.isDragging() && this.update() }, a = n._attrsAffectingSize.map(o => o + "Change." + this._getEventNamespace()).join(" "); n.on(a, s), n.on(Ug.map(o => o + `.${this._getEventNamespace()}`).join(" "), s), n.on(`absoluteTransformChange.${this._getEventNamespace()}`, s), this._proxyDrag(n) }), this._resetTransformCache(); var r = !!this.findOne(".top-left"); return r && this.update(), this } _proxyDrag(t) { let i; t.on(`dragstart.${this._getEventNamespace()}`, r => { i = t.getAbsolutePosition(), !this.isDragging() && t !== this.findOne(".back") && this.startDrag(r, !1) }), t.on(`dragmove.${this._getEventNamespace()}`, r => { if (!i) return; const n = t.getAbsolutePosition(), s = n.x - i.x, a = n.y - i.y; this.nodes().forEach(o => { if (o === t || o.isDragging()) return; const l = o.getAbsolutePosition(); o.setAbsolutePosition({ x: l.x + s, y: l.y + a }), o.startDrag(r) }), i = null }) } getNodes() { return this._nodes || [] } getActiveAnchor() { return this._movingAnchorName } detach() { this._nodes && this._nodes.forEach(t => { t.off("." + this._getEventNamespace()) }), this._nodes = [], this._resetTransformCache() } _resetTransformCache() { this._clearCache(bo), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform") } _getNodeRect() { return this._getCache(bo, this.__getNodeRect) } __getNodeShape(t, i = this.rotation(), r) { var n = t.getClientRect({ skipTransform: !0, skipShadow: !0, skipStroke: this.ignoreStroke() }), s = t.getAbsoluteScale(r), a = t.getAbsolutePosition(r), o = n.x * s.x - t.offsetX() * s.x, l = n.y * s.y - t.offsetY() * s.y; const h = (X.getAngle(t.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2), c = { x: a.x + o * Math.cos(h) + l * Math.sin(-h), y: a.y + l * Math.cos(h) + o * Math.sin(h), width: n.width * s.x, height: n.height * s.y, rotation: h }; return Hh(c, -X.getAngle(i), { x: 0, y: 0 }) } __getNodeRect() { var t = this.getNode(); if (!t) return { x: -Co, y: -Co, width: 0, height: 0, rotation: 0 }; const i = []; this.nodes().map(h => { const c = h.getClientRect({ skipTransform: !0, skipShadow: !0, skipStroke: this.ignoreStroke() }); var f = [{ x: c.x, y: c.y }, { x: c.x + c.width, y: c.y }, { x: c.x + c.width, y: c.y + c.height }, { x: c.x, y: c.y + c.height }], u = h.getAbsoluteTransform(); f.forEach(function (g) { var d = u.point(g); i.push(d) }) }); const r = new $t; r.rotate(-X.getAngle(this.rotation())); var n, s, a, o; i.forEach(function (h) { var c = r.point(h); n === void 0 && (n = a = c.x, s = o = c.y), n = Math.min(n, c.x), s = Math.min(s, c.y), a = Math.max(a, c.x), o = Math.max(o, c.y) }), r.invert(); const l = r.point({ x: n, y: s }); return { x: l.x, y: l.y, width: a - n, height: o - s, rotation: X.getAngle(this.rotation()) } } getX() { return this._getNodeRect().x } getY() { return this._getNodeRect().y } getWidth() { return this._getNodeRect().width } getHeight() { return this._getNodeRect().height } _createElements() { this._createBack(), cn.forEach(function (t) { this._createAnchor(t) }.bind(this)), this._createAnchor("rotater") } _createAnchor(t) { var i = new wr({ stroke: "rgb(0, 161, 255)", fill: "white", strokeWidth: 1, name: t + " _anchor", dragDistance: 0, draggable: !0, hitStrokeWidth: jg ? 10 : "auto" }), r = this; i.on("mousedown touchstart", function (n) { r._handleMouseDown(n) }), i.on("dragstart", n => { i.stopDrag(), n.cancelBubble = !0 }), i.on("dragend", n => { n.cancelBubble = !0 }), i.on("mouseenter", () => { var n = X.getAngle(this.rotation()), s = zg(t, n); i.getStage().content && (i.getStage().content.style.cursor = s), this._cursorChange = !0 }), i.on("mouseout", () => { i.getStage().content && (i.getStage().content.style.cursor = ""), this._cursorChange = !1 }), this.add(i) } _createBack() { var t = new G({ name: "back", width: 0, height: 0, draggable: !0, sceneFunc(i) { var r = this.getParent(), n = r.padding(); i.beginPath(), i.rect(-n, -n, this.width() + n * 2, this.height() + n * 2), i.moveTo(this.width() / 2, -n), r.rotateEnabled() && i.lineTo(this.width() / 2, -r.rotateAnchorOffset() * x._sign(this.height()) - n), i.fillStrokeShape(this) }, hitFunc: (i, r) => { if (this.shouldOverdrawWholeArea()) { var n = this.padding(); i.beginPath(), i.rect(-n, -n, r.width() + n * 2, r.height() + n * 2), i.fillStrokeShape(r) } } }); this.add(t), this._proxyDrag(t), t.on("dragstart", i => { i.cancelBubble = !0 }), t.on("dragmove", i => { i.cancelBubble = !0 }), t.on("dragend", i => { i.cancelBubble = !0 }), this.on("dragmove", i => { this.update() }) } _handleMouseDown(t) { this._movingAnchorName = t.target.name().split(" ")[0]; var i = this._getNodeRect(), r = i.width, n = i.height, s = Math.sqrt(Math.pow(r, 2) + Math.pow(n, 2)); this.sin = Math.abs(n / s), this.cos = Math.abs(r / s), typeof window < "u" && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0; var a = t.target.getAbsolutePosition(), o = t.target.getStage().getPointerPosition(); this._anchorDragOffset = { x: o.x - a.x, y: o.y - a.y }, this._fire("transformstart", { evt: t.evt, target: this.getNode() }), this._nodes.forEach(l => { l._fire("transformstart", { evt: t.evt, target: l }) }) } _handleMouseMove(t) { var i, r, n, s = this.findOne("." + this._movingAnchorName), a = s.getStage(); a.setPointersPositions(t); const o = a.getPointerPosition(); let l = { x: o.x - this._anchorDragOffset.x, y: o.y - this._anchorDragOffset.y }; const h = s.getAbsolutePosition(); this.anchorDragBoundFunc() && (l = this.anchorDragBoundFunc()(h, l, t)), s.setAbsolutePosition(l); const c = s.getAbsolutePosition(); if (!(h.x === c.x && h.y === c.y)) { if (this._movingAnchorName === "rotater") { var f = this._getNodeRect(); i = s.x() - f.width / 2, r = -s.y() + f.height / 2; let D = Math.atan2(-r, i) + Math.PI / 2; f.height < 0 && (D -= Math.PI); var u = X.getAngle(this.rotation()); const k = u + D, P = X.getAngle(this.rotationSnapTolerance()), H = Kg(this.rotationSnaps(), k, P) - f.rotation, $ = Vg(f, H); this._fitNodesInto($, t); return } var g = this.keepRatio() || t.shiftKey, p = this.centeredScaling() || t.altKey; if (this._movingAnchorName === "top-left") { if (g) { var d = p ? { x: this.width() / 2, y: this.height() / 2 } : { x: this.findOne(".bottom-right").x(), y: this.findOne(".bottom-right").y() }; n = Math.sqrt(Math.pow(d.x - s.x(), 2) + Math.pow(d.y - s.y(), 2)); var y = this.findOne(".top-left").x() > d.x ? -1 : 1, C = this.findOne(".top-left").y() > d.y ? -1 : 1; i = n * this.cos * y, r = n * this.sin * C, this.findOne(".top-left").x(d.x - i), this.findOne(".top-left").y(d.y - r) } } else if (this._movingAnchorName === "top-center") this.findOne(".top-left").y(s.y()); else if (this._movingAnchorName === "top-right") { if (g) { var d = p ? { x: this.width() / 2, y: this.height() / 2 } : { x: this.findOne(".bottom-left").x(), y: this.findOne(".bottom-left").y() }; n = Math.sqrt(Math.pow(s.x() - d.x, 2) + Math.pow(d.y - s.y(), 2)); var y = this.findOne(".top-right").x() < d.x ? -1 : 1, C = this.findOne(".top-right").y() > d.y ? -1 : 1; i = n * this.cos * y, r = n * this.sin * C, this.findOne(".top-right").x(d.x + i), this.findOne(".top-right").y(d.y - r) } var b = s.position(); this.findOne(".top-left").y(b.y), this.findOne(".bottom-right").x(b.x) } else if (this._movingAnchorName === "middle-left") this.findOne(".top-left").x(s.x()); else if (this._movingAnchorName === "middle-right") this.findOne(".bottom-right").x(s.x()); else if (this._movingAnchorName === "bottom-left") { if (g) { var d = p ? { x: this.width() / 2, y: this.height() / 2 } : { x: this.findOne(".top-right").x(), y: this.findOne(".top-right").y() }; n = Math.sqrt(Math.pow(d.x - s.x(), 2) + Math.pow(s.y() - d.y, 2)); var y = d.x < s.x() ? -1 : 1, C = s.y() < d.y ? -1 : 1; i = n * this.cos * y, r = n * this.sin * C, s.x(d.x - i), s.y(d.y + r) } b = s.position(), this.findOne(".top-left").x(b.x), this.findOne(".bottom-right").y(b.y) } else if (this._movingAnchorName === "bottom-center") this.findOne(".bottom-right").y(s.y()); else if (this._movingAnchorName === "bottom-right") { if (g) { var d = p ? { x: this.width() / 2, y: this.height() / 2 } : { x: this.findOne(".top-left").x(), y: this.findOne(".top-left").y() }; n = Math.sqrt(Math.pow(s.x() - d.x, 2) + Math.pow(s.y() - d.y, 2)); var y = this.findOne(".bottom-right").x() < d.x ? -1 : 1, C = this.findOne(".bottom-right").y() < d.y ? -1 : 1; i = n * this.cos * y, r = n * this.sin * C, this.findOne(".bottom-right").x(d.x + i), this.findOne(".bottom-right").y(d.y + r) } } else console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName)); var p = this.centeredScaling() || t.altKey; if (p) { var m = this.findOne(".top-left"), w = this.findOne(".bottom-right"), A = m.x(), T = m.y(), R = this.getWidth() - w.x(), E = this.getHeight() - w.y(); w.move({ x: -A, y: -T }), m.move({ x: R, y: E }) } var L = this.findOne(".top-left").getAbsolutePosition(); i = L.x, r = L.y; var O = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(), I = this.findOne(".bottom-right").y() - this.findOne(".top-left").y(); this._fitNodesInto({ x: i, y: r, width: O, height: I, rotation: X.getAngle(this.rotation()) }, t) } } _handleMouseUp(t) { this._removeEvents(t) } getAbsoluteTransform() { return this.getTransform() } _removeEvents(t) { if (this._transforming) { this._transforming = !1, typeof window < "u" && (window.removeEventListener("mousemove", this._handleMouseMove), window.removeEventListener("touchmove", this._handleMouseMove), window.removeEventListener("mouseup", this._handleMouseUp, !0), window.removeEventListener("touchend", this._handleMouseUp, !0)); var i = this.getNode(); this._fire("transformend", { evt: t, target: i }), i && this._nodes.forEach(r => { r._fire("transformend", { evt: t, target: r }) }), this._movingAnchorName = null } } _fitNodesInto(t, i) { var r = this._getNodeRect(); const n = 1; if (x._inRange(t.width, -this.padding() * 2 - n, n)) { this.update(); return } if (x._inRange(t.height, -this.padding() * 2 - n, n)) { this.update(); return } const s = this.flipEnabled(); var a = new $t; if (a.rotate(X.getAngle(this.rotation())), this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("left") >= 0) { const f = a.point({ x: -this.padding() * 2, y: 0 }); if (t.x += f.x, t.y += f.y, t.width += this.padding() * 2, this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, !s) { this.update(); return } } else if (this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("right") >= 0) { const f = a.point({ x: this.padding() * 2, y: 0 }); if (this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.width += this.padding() * 2, !s) { this.update(); return } } if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("top") >= 0) { const f = a.point({ x: 0, y: -this.padding() * 2 }); if (t.x += f.x, t.y += f.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !s) { this.update(); return } } else if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) { const f = a.point({ x: 0, y: this.padding() * 2 }); if (this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !s) { this.update(); return } } if (this.boundBoxFunc()) { const f = this.boundBoxFunc()(r, t); f ? t = f : x.warn("boundBoxFunc returned falsy. You should return new bound rect from it!") } const o = 1e7, l = new $t; l.translate(r.x, r.y), l.rotate(r.rotation), l.scale(r.width / o, r.height / o); const h = new $t; h.translate(t.x, t.y), h.rotate(t.rotation), h.scale(t.width / o, t.height / o); const c = h.multiply(l.invert()); this._nodes.forEach(f => { var u; const g = f.getParent().getAbsoluteTransform(), d = f.getTransform().copy(); d.translate(f.offsetX(), f.offsetY()); const y = new $t; y.multiply(g.copy().invert()).multiply(c).multiply(g).multiply(d); const C = y.decompose(); f.setAttrs(C), this._fire("transform", { evt: i, target: f }), f._fire("transform", { evt: i, target: f }), (u = f.getLayer()) === null || u === void 0 || u.batchDraw() }), this.rotation(x._getRotation(t.rotation)), this._resetTransformCache(), this.update(), this.getLayer().batchDraw() } forceUpdate() { this._resetTransformCache(), this.update() } _batchChangeChild(t, i) { this.findOne(t).setAttrs(i) } update() { var t, i = this._getNodeRect(); this.rotation(x._getRotation(i.rotation)); var r = i.width, n = i.height, s = this.enabledAnchors(), a = this.resizeEnabled(), o = this.padding(), l = this.anchorSize(); this.find("._anchor").forEach(h => { h.setAttrs({ width: l, height: l, offsetX: l / 2, offsetY: l / 2, stroke: this.anchorStroke(), strokeWidth: this.anchorStrokeWidth(), fill: this.anchorFill(), cornerRadius: this.anchorCornerRadius() }) }), this._batchChangeChild(".top-left", { x: 0, y: 0, offsetX: l / 2 + o, offsetY: l / 2 + o, visible: a && s.indexOf("top-left") >= 0 }), this._batchChangeChild(".top-center", { x: r / 2, y: 0, offsetY: l / 2 + o, visible: a && s.indexOf("top-center") >= 0 }), this._batchChangeChild(".top-right", { x: r, y: 0, offsetX: l / 2 - o, offsetY: l / 2 + o, visible: a && s.indexOf("top-right") >= 0 }), this._batchChangeChild(".middle-left", { x: 0, y: n / 2, offsetX: l / 2 + o, visible: a && s.indexOf("middle-left") >= 0 }), this._batchChangeChild(".middle-right", { x: r, y: n / 2, offsetX: l / 2 - o, visible: a && s.indexOf("middle-right") >= 0 }), this._batchChangeChild(".bottom-left", { x: 0, y: n, offsetX: l / 2 + o, offsetY: l / 2 - o, visible: a && s.indexOf("bottom-left") >= 0 }), this._batchChangeChild(".bottom-center", { x: r / 2, y: n, offsetY: l / 2 - o, visible: a && s.indexOf("bottom-center") >= 0 }), this._batchChangeChild(".bottom-right", { x: r, y: n, offsetX: l / 2 - o, offsetY: l / 2 - o, visible: a && s.indexOf("bottom-right") >= 0 }), this._batchChangeChild(".rotater", { x: r / 2, y: -this.rotateAnchorOffset() * x._sign(n) - o, visible: this.rotateEnabled() }), this._batchChangeChild(".back", { width: r, height: n, visible: this.borderEnabled(), stroke: this.borderStroke(), strokeWidth: this.borderStrokeWidth(), dash: this.borderDash(), x: 0, y: 0 }), (t = this.getLayer()) === null || t === void 0 || t.batchDraw() } isTransforming() { return this._transforming } stopTransform() { if (this._transforming) { this._removeEvents(); var t = this.findOne("." + this._movingAnchorName); t && t.stopDrag() } } destroy() { return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), Ai.prototype.destroy.call(this), this.detach(), this._removeEvents(), this } toObject() { return U.prototype.toObject.call(this) } clone(t) { var i = U.prototype.clone.call(this, t); return i } getClientRect() { return this.nodes().length > 0 ? super.getClientRect() : { x: 0, y: 0, width: 0, height: 0 } } } function Xg(e) { return e instanceof Array || x.warn("enabledAnchors value should be an array"), e instanceof Array && e.forEach(function (t) { cn.indexOf(t) === -1 && x.warn("Unknown anchor name: " + t + ". Available names are: " + cn.join(", ")) }), e || [] } ft.prototype.className = "Transformer"; St(ft); v.addGetterSetter(ft, "enabledAnchors", cn, Xg); v.addGetterSetter(ft, "flipEnabled", !0, ae()); v.addGetterSetter(ft, "resizeEnabled", !0); v.addGetterSetter(ft, "anchorSize", 10, W()); v.addGetterSetter(ft, "rotateEnabled", !0); v.addGetterSetter(ft, "rotationSnaps", []); v.addGetterSetter(ft, "rotateAnchorOffset", 50, W()); v.addGetterSetter(ft, "rotationSnapTolerance", 5, W()); v.addGetterSetter(ft, "borderEnabled", !0); v.addGetterSetter(ft, "anchorStroke", "rgb(0, 161, 255)"); v.addGetterSetter(ft, "anchorStrokeWidth", 1, W()); v.addGetterSetter(ft, "anchorFill", "white"); v.addGetterSetter(ft, "anchorCornerRadius", 0, W()); v.addGetterSetter(ft, "borderStroke", "rgb(0, 161, 255)"); v.addGetterSetter(ft, "borderStrokeWidth", 1, W()); v.addGetterSetter(ft, "borderDash"); v.addGetterSetter(ft, "keepRatio", !0); v.addGetterSetter(ft, "centeredScaling", !1); v.addGetterSetter(ft, "ignoreStroke", !1); v.addGetterSetter(ft, "padding", 0, W()); v.addGetterSetter(ft, "node"); v.addGetterSetter(ft, "nodes"); v.addGetterSetter(ft, "boundBoxFunc"); v.addGetterSetter(ft, "anchorDragBoundFunc"); v.addGetterSetter(ft, "shouldOverdrawWholeArea", !1); v.addGetterSetter(ft, "useSingleNodeRotation", !0); v.backCompat(ft, { lineEnabled: "borderEnabled", rotateHandlerOffset: "rotateAnchorOffset", enabledHandlers: "enabledAnchors" }); class xe extends G { _sceneFunc(t) { t.beginPath(), t.arc(0, 0, this.radius(), 0, X.getAngle(this.angle()), this.clockwise()), t.lineTo(0, 0), t.closePath(), t.fillStrokeShape(this) } getWidth() { return this.radius() * 2 } getHeight() { return this.radius() * 2 } setWidth(t) { this.radius(t / 2) } setHeight(t) { this.radius(t / 2) } } xe.prototype.className = "Wedge"; xe.prototype._centroid = !0; xe.prototype._attrsAffectingSize = ["radius"]; St(xe); v.addGetterSetter(xe, "radius", 0, W()); v.addGetterSetter(xe, "angle", 0, W()); v.addGetterSetter(xe, "clockwise", !1); v.backCompat(xe, { angleDeg: "angle", getAngleDeg: "getAngle", setAngleDeg: "setAngle" }); function So() { this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null } var $g = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], qg = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24]; function Jg(e, t) { var i = e.data, r = e.width, n = e.height, s, a, o, l, h, c, f, u, g, d, y, C, b, p, m, w, A, T, R, E, L, O, I, D, k = t + t + 1, P = r - 1, V = n - 1, H = t + 1, $ = H * (H + 1) / 2, Z = new So, st = null, q = Z, nt = null, ot = null, ut = $g[t], Gt = qg[t]; for (o = 1; o < k; o++)q = q.next = new So, o === H && (st = q); for (q.next = Z, f = c = 0, a = 0; a < n; a++) { for (w = A = T = R = u = g = d = y = 0, C = H * (E = i[c]), b = H * (L = i[c + 1]), p = H * (O = i[c + 2]), m = H * (I = i[c + 3]), u += $ * E, g += $ * L, d += $ * O, y += $ * I, q = Z, o = 0; o < H; o++)q.r = E, q.g = L, q.b = O, q.a = I, q = q.next; for (o = 1; o < H; o++)l = c + ((P < o ? P : o) << 2), u += (q.r = E = i[l]) * (D = H - o), g += (q.g = L = i[l + 1]) * D, d += (q.b = O = i[l + 2]) * D, y += (q.a = I = i[l + 3]) * D, w += E, A += L, T += O, R += I, q = q.next; for (nt = Z, ot = st, s = 0; s < r; s++)i[c + 3] = I = y * ut >> Gt, I !== 0 ? (I = 255 / I, i[c] = (u * ut >> Gt) * I, i[c + 1] = (g * ut >> Gt) * I, i[c + 2] = (d * ut >> Gt) * I) : i[c] = i[c + 1] = i[c + 2] = 0, u -= C, g -= b, d -= p, y -= m, C -= nt.r, b -= nt.g, p -= nt.b, m -= nt.a, l = f + ((l = s + t + 1) < P ? l : P) << 2, w += nt.r = i[l], A += nt.g = i[l + 1], T += nt.b = i[l + 2], R += nt.a = i[l + 3], u += w, g += A, d += T, y += R, nt = nt.next, C += E = ot.r, b += L = ot.g, p += O = ot.b, m += I = ot.a, w -= E, A -= L, T -= O, R -= I, ot = ot.next, c += 4; f += r } for (s = 0; s < r; s++) { for (A = T = R = w = g = d = y = u = 0, c = s << 2, C = H * (E = i[c]), b = H * (L = i[c + 1]), p = H * (O = i[c + 2]), m = H * (I = i[c + 3]), u += $ * E, g += $ * L, d += $ * O, y += $ * I, q = Z, o = 0; o < H; o++)q.r = E, q.g = L, q.b = O, q.a = I, q = q.next; for (h = r, o = 1; o <= t; o++)c = h + s << 2, u += (q.r = E = i[c]) * (D = H - o), g += (q.g = L = i[c + 1]) * D, d += (q.b = O = i[c + 2]) * D, y += (q.a = I = i[c + 3]) * D, w += E, A += L, T += O, R += I, q = q.next, o < V && (h += r); for (c = s, nt = Z, ot = st, a = 0; a < n; a++)l = c << 2, i[l + 3] = I = y * ut >> Gt, I > 0 ? (I = 255 / I, i[l] = (u * ut >> Gt) * I, i[l + 1] = (g * ut >> Gt) * I, i[l + 2] = (d * ut >> Gt) * I) : i[l] = i[l + 1] = i[l + 2] = 0, u -= C, g -= b, d -= p, y -= m, C -= nt.r, b -= nt.g, p -= nt.b, m -= nt.a, l = s + ((l = a + H) < V ? l : V) * r << 2, u += w += nt.r = i[l], g += A += nt.g = i[l + 1], d += T += nt.b = i[l + 2], y += R += nt.a = i[l + 3], nt = nt.next, C += E = ot.r, b += L = ot.g, p += O = ot.b, m += I = ot.a, w -= E, A -= L, T -= O, R -= I, ot = ot.next, c += r } } const Qg = function (t) { var i = Math.round(this.blurRadius()); i > 0 && Jg(t, i) }; v.addGetterSetter(U, "blurRadius", 0, W(), v.afterSetFilter); const Zg = function (e) { var t = this.brightness() * 255, i = e.data, r = i.length, n; for (n = 0; n < r; n += 4)i[n] += t, i[n + 1] += t, i[n + 2] += t }; v.addGetterSetter(U, "brightness", 0, W(), v.afterSetFilter); const tp = function (e) { var t = Math.pow((this.contrast() + 100) / 100, 2), i = e.data, r = i.length, n = 150, s = 150, a = 150, o; for (o = 0; o < r; o += 4)n = i[o], s = i[o + 1], a = i[o + 2], n /= 255, n -= .5, n *= t, n += .5, n *= 255, s /= 255, s -= .5, s *= t, s += .5, s *= 255, a /= 255, a -= .5, a *= t, a += .5, a *= 255, n = n < 0 ? 0 : n > 255 ? 255 : n, s = s < 0 ? 0 : s > 255 ? 255 : s, a = a < 0 ? 0 : a > 255 ? 255 : a, i[o] = n, i[o + 1] = s, i[o + 2] = a }; v.addGetterSetter(U, "contrast", 0, W(), v.afterSetFilter); const ep = function (e) { var t = this.embossStrength() * 10, i = this.embossWhiteLevel() * 255, r = this.embossDirection(), n = this.embossBlend(), s = 0, a = 0, o = e.data, l = e.width, h = e.height, c = l * 4, f = h; switch (r) { case "top-left": s = -1, a = -1; break; case "top": s = -1, a = 0; break; case "top-right": s = -1, a = 1; break; case "right": s = 0, a = 1; break; case "bottom-right": s = 1, a = 1; break; case "bottom": s = 1, a = 0; break; case "bottom-left": s = 1, a = -1; break; case "left": s = 0, a = -1; break; default: x.error("Unknown emboss direction: " + r) }do { var u = (f - 1) * c, g = s; f + g < 1 && (g = 0), f + g > h && (g = 0); var d = (f - 1 + g) * l * 4, y = l; do { var C = u + (y - 1) * 4, b = a; y + b < 1 && (b = 0), y + b > l && (b = 0); var p = d + (y - 1 + b) * 4, m = o[C] - o[p], w = o[C + 1] - o[p + 1], A = o[C + 2] - o[p + 2], T = m, R = T > 0 ? T : -T, E = w > 0 ? w : -w, L = A > 0 ? A : -A; if (E > R && (T = w), L > R && (T = A), T *= t, n) { var O = o[C] + T, I = o[C + 1] + T, D = o[C + 2] + T; o[C] = O > 255 ? 255 : O < 0 ? 0 : O, o[C + 1] = I > 255 ? 255 : I < 0 ? 0 : I, o[C + 2] = D > 255 ? 255 : D < 0 ? 0 : D } else { var k = i - T; k < 0 ? k = 0 : k > 255 && (k = 255), o[C] = o[C + 1] = o[C + 2] = k } } while (--y) } while (--f) }; v.addGetterSetter(U, "embossStrength", .5, W(), v.afterSetFilter); v.addGetterSetter(U, "embossWhiteLevel", .5, W(), v.afterSetFilter); v.addGetterSetter(U, "embossDirection", "top-left", null, v.afterSetFilter); v.addGetterSetter(U, "embossBlend", !1, null, v.afterSetFilter); function qn(e, t, i, r, n) { var s = i - t, a = n - r, o; return s === 0 ? r + a / 2 : a === 0 ? r : (o = (e - t) / s, o = a * o + r, o) } const ip = function (e) { var t = e.data, i = t.length, r = t[0], n = r, s, a = t[1], o = a, l, h = t[2], c = h, f, u, g = this.enhance(); if (g !== 0) { for (u = 0; u < i; u += 4)s = t[u + 0], s < r ? r = s : s > n && (n = s), l = t[u + 1], l < a ? a = l : l > o && (o = l), f = t[u + 2], f < h ? h = f : f > c && (c = f); n === r && (n = 255, r = 0), o === a && (o = 255, a = 0), c === h && (c = 255, h = 0); var d, y, C, b, p, m, w, A, T; for (g > 0 ? (y = n + g * (255 - n), C = r - g * (r - 0), p = o + g * (255 - o), m = a - g * (a - 0), A = c + g * (255 - c), T = h - g * (h - 0)) : (d = (n + r) * .5, y = n + g * (n - d), C = r + g * (r - d), b = (o + a) * .5, p = o + g * (o - b), m = a + g * (a - b), w = (c + h) * .5, A = c + g * (c - w), T = h + g * (h - w)), u = 0; u < i; u += 4)t[u + 0] = qn(t[u + 0], r, n, C, y), t[u + 1] = qn(t[u + 1], a, o, m, p), t[u + 2] = qn(t[u + 2], h, c, T, A) } }; v.addGetterSetter(U, "enhance", 0, W(), v.afterSetFilter); const rp = function (e) { var t = e.data, i = t.length, r, n; for (r = 0; r < i; r += 4)n = .34 * t[r] + .5 * t[r + 1] + .16 * t[r + 2], t[r] = n, t[r + 1] = n, t[r + 2] = n }; v.addGetterSetter(U, "hue", 0, W(), v.afterSetFilter); v.addGetterSetter(U, "saturation", 0, W(), v.afterSetFilter); v.addGetterSetter(U, "luminance", 0, W(), v.afterSetFilter); const np = function (e) { var t = e.data, i = t.length, r = 1, n = Math.pow(2, this.saturation()), s = Math.abs(this.hue() + 360) % 360, a = this.luminance() * 127, o, l = r * n * Math.cos(s * Math.PI / 180), h = r * n * Math.sin(s * Math.PI / 180), c = .299 * r + .701 * l + .167 * h, f = .587 * r - .587 * l + .33 * h, u = .114 * r - .114 * l - .497 * h, g = .299 * r - .299 * l - .328 * h, d = .587 * r + .413 * l + .035 * h, y = .114 * r - .114 * l + .293 * h, C = .299 * r - .3 * l + 1.25 * h, b = .587 * r - .586 * l - 1.05 * h, p = .114 * r + .886 * l - .2 * h, m, w, A, T; for (o = 0; o < i; o += 4)m = t[o + 0], w = t[o + 1], A = t[o + 2], T = t[o + 3], t[o + 0] = c * m + f * w + u * A + a, t[o + 1] = g * m + d * w + y * A + a, t[o + 2] = C * m + b * w + p * A + a, t[o + 3] = T }, sp = function (e) { var t = e.data, i = t.length, r = Math.pow(2, this.value()), n = Math.pow(2, this.saturation()), s = Math.abs(this.hue() + 360) % 360, a, o = r * n * Math.cos(s * Math.PI / 180), l = r * n * Math.sin(s * Math.PI / 180), h = .299 * r + .701 * o + .167 * l, c = .587 * r - .587 * o + .33 * l, f = .114 * r - .114 * o - .497 * l, u = .299 * r - .299 * o - .328 * l, g = .587 * r + .413 * o + .035 * l, d = .114 * r - .114 * o + .293 * l, y = .299 * r - .3 * o + 1.25 * l, C = .587 * r - .586 * o - 1.05 * l, b = .114 * r + .886 * o - .2 * l, p, m, w, A; for (a = 0; a < i; a += 4)p = t[a + 0], m = t[a + 1], w = t[a + 2], A = t[a + 3], t[a + 0] = h * p + c * m + f * w, t[a + 1] = u * p + g * m + d * w, t[a + 2] = y * p + C * m + b * w, t[a + 3] = A }; v.addGetterSetter(U, "hue", 0, W(), v.afterSetFilter); v.addGetterSetter(U, "saturation", 0, W(), v.afterSetFilter); v.addGetterSetter(U, "value", 0, W(), v.afterSetFilter); const ap = function (e) { var t = e.data, i = t.length, r; for (r = 0; r < i; r += 4)t[r] = 255 - t[r], t[r + 1] = 255 - t[r + 1], t[r + 2] = 255 - t[r + 2] }; var op = function (e, t, i) { var r = e.data, n = t.data, s = e.width, a = e.height, o = i.polarCenterX || s / 2, l = i.polarCenterY || a / 2, h, c, f, u = 0, g = 0, d = 0, y = 0, C, b = Math.sqrt(o * o + l * l); c = s - o, f = a - l, C = Math.sqrt(c * c + f * f), b = C > b ? C : b; var p = a, m = s, w, A, T = 360 / m * Math.PI / 180, R, E; for (A = 0; A < m; A += 1)for (R = Math.sin(A * T), E = Math.cos(A * T), w = 0; w < p; w += 1)c = Math.floor(o + b * w / p * E), f = Math.floor(l + b * w / p * R), h = (f * s + c) * 4, u = r[h + 0], g = r[h + 1], d = r[h + 2], y = r[h + 3], h = (A + w * s) * 4, n[h + 0] = u, n[h + 1] = g, n[h + 2] = d, n[h + 3] = y }, lp = function (e, t, i) { var r = e.data, n = t.data, s = e.width, a = e.height, o = i.polarCenterX || s / 2, l = i.polarCenterY || a / 2, h, c, f, u, g, d = 0, y = 0, C = 0, b = 0, p, m = Math.sqrt(o * o + l * l); c = s - o, f = a - l, p = Math.sqrt(c * c + f * f), m = p > m ? p : m; var w = a, A = s, T, R, E = i.polarRotation || 0, L, O; for (c = 0; c < s; c += 1)for (f = 0; f < a; f += 1)u = c - o, g = f - l, T = Math.sqrt(u * u + g * g) * w / m, R = (Math.atan2(g, u) * 180 / Math.PI + 360 + E) % 360, R = R * A / 360, L = Math.floor(R), O = Math.floor(T), h = (O * s + L) * 4, d = r[h + 0], y = r[h + 1], C = r[h + 2], b = r[h + 3], h = (f * s + c) * 4, n[h + 0] = d, n[h + 1] = y, n[h + 2] = C, n[h + 3] = b }; const hp = function (e) { var t = e.width, i = e.height, r, n, s, a, o, l, h, c, f, u, g = Math.round(this.kaleidoscopePower()), d = Math.round(this.kaleidoscopeAngle()), y = Math.floor(t * (d % 360) / 360); if (!(g < 1)) { var C = x.createCanvasElement(); C.width = t, C.height = i; var b = C.getContext("2d").getImageData(0, 0, t, i); x.releaseCanvas(C), op(e, b, { polarCenterX: t / 2, polarCenterY: i / 2 }); for (var p = t / Math.pow(2, g); p <= 8;)p = p * 2, g -= 1; p = Math.ceil(p); var m = p, w = 0, A = m, T = 1; for (y + p > t && (w = m, A = 0, T = -1), n = 0; n < i; n += 1)for (r = w; r !== A; r += T)s = Math.round(r + y) % t, f = (t * n + s) * 4, o = b.data[f + 0], l = b.data[f + 1], h = b.data[f + 2], c = b.data[f + 3], u = (t * n + r) * 4, b.data[u + 0] = o, b.data[u + 1] = l, b.data[u + 2] = h, b.data[u + 3] = c; for (n = 0; n < i; n += 1)for (m = Math.floor(p), a = 0; a < g; a += 1) { for (r = 0; r < m + 1; r += 1)f = (t * n + r) * 4, o = b.data[f + 0], l = b.data[f + 1], h = b.data[f + 2], c = b.data[f + 3], u = (t * n + m * 2 - r - 1) * 4, b.data[u + 0] = o, b.data[u + 1] = l, b.data[u + 2] = h, b.data[u + 3] = c; m *= 2 } lp(b, e, { polarRotation: 0 }) } }; v.addGetterSetter(U, "kaleidoscopePower", 2, W(), v.afterSetFilter); v.addGetterSetter(U, "kaleidoscopeAngle", 0, W(), v.afterSetFilter); function Vr(e, t, i) { var r = (i * e.width + t) * 4, n = []; return n.push(e.data[r++], e.data[r++], e.data[r++], e.data[r++]), n } function Ui(e, t) { return Math.sqrt(Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2)) } function cp(e) { for (var t = [0, 0, 0], i = 0; i < e.length; i++)t[0] += e[i][0], t[1] += e[i][1], t[2] += e[i][2]; return t[0] /= e.length, t[1] /= e.length, t[2] /= e.length, t } function fp(e, t) { var i = Vr(e, 0, 0), r = Vr(e, e.width - 1, 0), n = Vr(e, 0, e.height - 1), s = Vr(e, e.width - 1, e.height - 1), a = t || 10; if (Ui(i, r) < a && Ui(r, s) < a && Ui(s, n) < a && Ui(n, i) < a) { for (var o = cp([r, i, s, n]), l = [], h = 0; h < e.width * e.height; h++) { var c = Ui(o, [e.data[h * 4], e.data[h * 4 + 1], e.data[h * 4 + 2]]); l[h] = c < a ? 0 : 255 } return l } } function up(e, t) { for (var i = 0; i < e.width * e.height; i++)e.data[4 * i + 3] = t[i] } function dp(e, t, i) { for (var r = [1, 1, 1, 1, 0, 1, 1, 1, 1], n = Math.round(Math.sqrt(r.length)), s = Math.floor(n / 2), a = [], o = 0; o < i; o++)for (var l = 0; l < t; l++) { for (var h = o * t + l, c = 0, f = 0; f < n; f++)for (var u = 0; u < n; u++) { var g = o + f - s, d = l + u - s; if (g >= 0 && g < i && d >= 0 && d < t) { var y = g * t + d, C = r[f * n + u]; c += e[y] * C } } a[h] = c === 255 * 8 ? 255 : 0 } return a } function gp(e, t, i) { for (var r = [1, 1, 1, 1, 1, 1, 1, 1, 1], n = Math.round(Math.sqrt(r.length)), s = Math.floor(n / 2), a = [], o = 0; o < i; o++)for (var l = 0; l < t; l++) { for (var h = o * t + l, c = 0, f = 0; f < n; f++)for (var u = 0; u < n; u++) { var g = o + f - s, d = l + u - s; if (g >= 0 && g < i && d >= 0 && d < t) { var y = g * t + d, C = r[f * n + u]; c += e[y] * C } } a[h] = c >= 255 * 4 ? 255 : 0 } return a } function pp(e, t, i) { for (var r = [.1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111], n = Math.round(Math.sqrt(r.length)), s = Math.floor(n / 2), a = [], o = 0; o < i; o++)for (var l = 0; l < t; l++) { for (var h = o * t + l, c = 0, f = 0; f < n; f++)for (var u = 0; u < n; u++) { var g = o + f - s, d = l + u - s; if (g >= 0 && g < i && d >= 0 && d < t) { var y = g * t + d, C = r[f * n + u]; c += e[y] * C } } a[h] = c } return a } const vp = function (e) { var t = this.threshold(), i = fp(e, t); return i && (i = dp(i, e.width, e.height), i = gp(i, e.width, e.height), i = pp(i, e.width, e.height), up(e, i)), e }; v.addGetterSetter(U, "threshold", 0, W(), v.afterSetFilter); const mp = function (e) { var t = this.noise() * 255, i = e.data, r = i.length, n = t / 2, s; for (s = 0; s < r; s += 4)i[s + 0] += n - 2 * n * Math.random(), i[s + 1] += n - 2 * n * Math.random(), i[s + 2] += n - 2 * n * Math.random() }; v.addGetterSetter(U, "noise", .2, W(), v.afterSetFilter); const _p = function (e) { var t = Math.ceil(this.pixelSize()), i = e.width, r = e.height, n, s, a, o, l, h, c, f = Math.ceil(i / t), u = Math.ceil(r / t), g, d, y, C, b, p, m, w = e.data; if (t <= 0) { x.error("pixelSize value can not be <= 0"); return } for (b = 0; b < f; b += 1)for (p = 0; p < u; p += 1) { for (o = 0, l = 0, h = 0, c = 0, g = b * t, d = g + t, y = p * t, C = y + t, m = 0, n = g; n < d; n += 1)if (!(n >= i)) for (s = y; s < C; s += 1)s >= r || (a = (i * s + n) * 4, o += w[a + 0], l += w[a + 1], h += w[a + 2], c += w[a + 3], m += 1); for (o = o / m, l = l / m, h = h / m, c = c / m, n = g; n < d; n += 1)if (!(n >= i)) for (s = y; s < C; s += 1)s >= r || (a = (i * s + n) * 4, w[a + 0] = o, w[a + 1] = l, w[a + 2] = h, w[a + 3] = c) } }; v.addGetterSetter(U, "pixelSize", 8, W(), v.afterSetFilter); const yp = function (e) { var t = Math.round(this.levels() * 254) + 1, i = e.data, r = i.length, n = 255 / t, s; for (s = 0; s < r; s += 1)i[s] = Math.floor(i[s] / n) * n }; v.addGetterSetter(U, "levels", .5, W(), v.afterSetFilter); const bp = function (e) { var t = e.data, i = t.length, r = this.red(), n = this.green(), s = this.blue(), a, o; for (a = 0; a < i; a += 4)o = (.34 * t[a] + .5 * t[a + 1] + .16 * t[a + 2]) / 255, t[a] = o * r, t[a + 1] = o * n, t[a + 2] = o * s, t[a + 3] = t[a + 3] }; v.addGetterSetter(U, "red", 0, function (e) { return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e) }); v.addGetterSetter(U, "green", 0, function (e) { return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e) }); v.addGetterSetter(U, "blue", 0, hh, v.afterSetFilter); const Cp = function (e) { var t = e.data, i = t.length, r = this.red(), n = this.green(), s = this.blue(), a = this.alpha(), o, l; for (o = 0; o < i; o += 4)l = 1 - a, t[o] = r * a + t[o] * l, t[o + 1] = n * a + t[o + 1] * l, t[o + 2] = s * a + t[o + 2] * l }; v.addGetterSetter(U, "red", 0, function (e) { return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e) }); v.addGetterSetter(U, "green", 0, function (e) { return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e) }); v.addGetterSetter(U, "blue", 0, hh, v.afterSetFilter); v.addGetterSetter(U, "alpha", 1, function (e) { return this._filterUpToDate = !1, e > 1 ? 1 : e < 0 ? 0 : e }); const Sp = function (e) { var t = e.data, i = t.length, r, n, s, a; for (r = 0; r < i; r += 4)n = t[r + 0], s = t[r + 1], a = t[r + 2], t[r + 0] = Math.min(255, n * .393 + s * .769 + a * .189), t[r + 1] = Math.min(255, n * .349 + s * .686 + a * .168), t[r + 2] = Math.min(255, n * .272 + s * .534 + a * .131) }, wp = function (e) { var t = e.data, i = e.width, r = e.height, n = i * 4, s = r; do { var a = (s - 1) * n, o = i; do { var l = a + (o - 1) * 4, h = t[l], c = t[l + 1], f = t[l + 2]; h > 127 && (h = 255 - h), c > 127 && (c = 255 - c), f > 127 && (f = 255 - f), t[l] = h, t[l + 1] = c, t[l + 2] = f } while (--o) } while (--s) }, xp = function (e) { var t = this.threshold() * 255, i = e.data, r = i.length, n; for (n = 0; n < r; n += 1)i[n] = i[n] < t ? 0 : 255 }; v.addGetterSetter(U, "threshold", .5, W(), v.afterSetFilter); const ve = go.Util._assign(go, { Arc: Se, Arrow: oi, Circle: Li, Ellipse: He, Image: ue, Label: fa, Tag: li, Line: we, Path: gt, Rect: wr, RegularPolygon: hi, Ring: ci, Sprite: de, Star: Ue, Text: Ct, TextPath: Mt, Transformer: ft, Wedge: xe, Filters: { Blur: Qg, Brighten: Zg, Contrast: tp, Emboss: ep, Enhance: ip, Grayscale: rp, HSL: np, HSV: sp, Invert: ap, Kaleidoscope: hp, Mask: vp, Noise: mp, Pixelate: _p, Posterize: yp, RGB: bp, RGBA: Cp, Sepia: Sp, Solarize: wp, Threshold: xp } }), Ep = Object.freeze(Object.defineProperty({ __proto__: null, default: ve }, Symbol.toStringTag, { value: "Module" })); function Tp(e, t) { if (!e) throw new Error(t || "unexpected compiler condition") } new RegExp("\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"); var Kr, Pp = new Uint8Array(16); function Ap() { if (!Kr && (Kr = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Kr)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); return Kr(Pp) } const kp = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i; function Mp(e) { return typeof e == "string" && kp.test(e) } var It = []; for (var Jn = 0; Jn < 256; ++Jn)It.push((Jn + 256).toString(16).substr(1)); function Rp(e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = (It[e[t + 0]] + It[e[t + 1]] + It[e[t + 2]] + It[e[t + 3]] + "-" + It[e[t + 4]] + It[e[t + 5]] + "-" + It[e[t + 6]] + It[e[t + 7]] + "-" + It[e[t + 8]] + It[e[t + 9]] + "-" + It[e[t + 10]] + It[e[t + 11]] + It[e[t + 12]] + It[e[t + 13]] + It[e[t + 14]] + It[e[t + 15]]).toLowerCase(); if (!Mp(i)) throw TypeError("Stringified UUID is invalid"); return i } function xr(e, t, i) { e = e || {}; var r = e.random || (e.rng || Ap)(); if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, t) { i = i || 0; for (var n = 0; n < 16; ++n)t[i + n] = r[n]; return t } return Rp(r) } class ua { constructor(t = xr()) { Lt(this, "id"); Lt(this, "father"); Lt(this, "children"); Lt(this, "container"); Lt(this, "type"); this.id = t, this.father = {}, this.children = {}, this.container = {}, this.type = "ShapeObject" } event(t) { } } class kt extends ua { constructor(i, r, n = xr()) { super(n); Lt(this, "x"); Lt(this, "y"); Lt(this, "type"); this.x = i, this.y = r, this.type = "Point" } event(i) { i.type === "move" && (this.x += i.dx, this.y += i.dy) } distance(i) { return Math.sqrt((this.x - i.x) ** 2 + (this.y - i.y) ** 2) } } class Wi extends ua { constructor(i, r, n = xr()) { super(n); Lt(this, "start"); Lt(this, "end"); Lt(this, "type"); this.start = i, this.end = r, this.end.container[this.id] = this, this.start.container[this.id] = this, this.type = "Line" } event(i) { i.type === "move" && (this.start.event(i), this.end.event(i)) } distance(i) { let r = this.end.y - this.start.y, n = this.start.x - this.end.x, s = this.end.x * this.start.y - this.start.x * this.end.y, a = Math.abs(r * i.x + n * i.y + s) / Math.sqrt(r * r + n * n), o = this.projection(i); return Math.min(this.start.x, this.end.x) > o.x || Math.max(this.start.x, this.end.x) < o.x || Math.min(this.start.y, this.end.y) > o.y || Math.max(this.start.y, this.end.y) < o.y ? Math.min(i.distance(this.start), i.distance(this.end)) : a } projection(i) { let r = this.end.y - this.start.y, n = this.start.x - this.end.x, s = this.end.x * this.start.y - this.start.x * this.end.y, a = (n * (n * i.x - r * i.y) - r * s) / (r * r + n * n), o = (r * (-n * i.x + r * i.y) - n * s) / (r * r + n * n); return a = Math.round(a), o = Math.round(o), new kt(a, o) } } class wo extends ua { constructor(i, r = xr()) { super(r); Lt(this, "lines"); Lt(this, "type"); this.lines = i, this.type = "Polygon"; for (let n = 0; n < i.length; n++)i[n].container[this.id] = this } event(i) { if (i.type === "move") for (let r = 0; r < this.lines.length; r++)this.lines[r].event(i) } inPolygon(i) { let r = 0; for (let n = 0; n < this.lines.length; n++) { let s = this.lines[n]; if (s.start.y === s.end.y || i.y < Math.min(s.start.y, s.end.y) || i.y >= Math.max(s.start.y, s.end.y)) continue; (i.y - s.start.y) * (s.end.x - s.start.x) / (s.end.y - s.start.y) + s.start.x > i.x && r++ } return r % 2 === 1 } toPoints() { let i = []; for (let r = 0; r < this.lines.length; r++)this.lines[(r + 1) % this.lines.length], i.push(this.isInverseLine(r) ? this.lines[r].end : this.lines[r].start); return i } isInverseLine(i) { let r = this.lines[i], n = this.lines[(i + 1) % this.lines.length]; return r.start === n.start || r.start === n.end } } class Op { constructor() { Lt(this, "points"); Lt(this, "lines"); Lt(this, "polygons"); this.points = {}, this.lines = {}, this.polygons = {} } addPoint(t, i) { t = Math.round(t), i = Math.round(i); let r = Object.values(this.points).find(s => s.distance(new kt(t, i)) < 2); if (r !== void 0) return r; let n = new kt(t, i); return this.points[n.id] = n, n } addLine(t, i) { t.x = Math.round(t.x), t.y = Math.round(t.y), i.x = Math.round(i.x), i.y = Math.round(i.y); let r = new kt(t.x, t.y), n = new kt(i.x, i.y), s = Object.values(this.lines).find(o => o.start.distance(r) < 2 && o.end.distance(n) < 2 || o.start.distance(n) < 2 && o.end.distance(r) < 2); if (s !== void 0) return s; let a = new Wi(this.addPoint(t.x, t.y), this.addPoint(i.x, i.y)); return this.lines[a.id] = a, a } addPolygon(t) { for (let n = 0; n < t.length; ++n)t[n].x = Math.round(t[n].x), t[n].y = Math.round(t[n].y), this.splitLines(t[n].x, t[n].y); let i = []; for (let n = 0; n < t.length - 1; n++)i.push({ start: t[n], end: t[n + 1] }); i.push({ start: t[t.length - 1], end: t[0] }); let r = xr(); return this.polygons[r] = new wo(i.map(n => this.lines[this.addLine(n.start, n.end).id]), r), console.log(this.polygons[r].lines.map(n => "(" + n.start.x + "," + n.start.y + ") -> (" + n.end.x + "," + n.end.y + ")")), this.polygons[r] } deletePolygon(t) { for (let i of this.polygons[t].lines) delete i.container[t]; delete this.polygons[t] } closestLine(t, i) { let r = 1e9, n = null; for (let s in this.lines) { let a = this.lines[s], o = a.distance(new kt(t, i)); o < r && (r = o, n = a) } return n } closestPoint(t, i) { let r = 1e9, n = null; for (let s in this.points) { let a = this.points[s], o = a.distance(new kt(t, i)); o < r && (r = o, n = a) } return n } closestShape(t, i) { const r = this.closestPoint(t, i), n = this.closestLine(t, i); return r === null && n === null ? null : r === null ? n : n === null ? r : r.distance(new kt(t, i)) < n.distance(new kt(t, i)) ? n : r } splitLines(t, i) { let r = new kt(t, i), n = this.closestLine(t, i); if (n !== null && n.distance(new kt(t, i)) < 2 && n.start.distance(r) > 2 && n.end.distance(r) > 2) { let s = this.addLine(n.start, r), a = this.addLine(r, n.end); for (let h in n.container) { let c = n.container[h]; if (c.type === "Polygon") { let f = c.lines.indexOf(n); c.isInverseLine(f) ? c.lines.splice(f, 1, a, s) : c.lines.splice(f, 1, s, a), s.container[h] = c, a.container[h] = c } } delete this.lines[n.id], this.lines[s.id] = s, this.lines[a.id] = a; let o = this.splitLines(t, i), l = [[s, a]]; return o !== null && (l = l.concat(o)), l } return null } inPolygon(t, i) { let r = null; for (let n in this.polygons) { let s = this.polygons[n]; s.inPolygon(new kt(t, i)) && (r = s) } return r } split(t) { if (t.length < 2) return; let i = { x: (t[0].x + t[1].x) / 2, y: (t[0].y + t[1].y) / 2 }, r = this.inPolygon(i.x, i.y); if (r === null) return; console.log(":", JSON.stringify(t)); let n = this.splitLines(t[0].x, t[0].y), s = this.splitLines(t.at(-1).x, t.at(-1).y); Tp((n == null ? void 0 : n.length) === 1 && (s == null ? void 0 : s.length) === 1); let a = [], o = []; console.log(":", JSON.stringify(r.lines.map(l => ({ start: { x: l.start.x, y: l.start.y }, end: { x: l.end.x, y: l.end.y } })))); for (let l = 0; l < r.lines.length; ++l) { let h = l === r.lines.length - 1 ? 0 : l + 1; if ((r.lines[l] === n[0][0] || r.lines[l] === n[0][1]) && r.lines[h] !== n[0][0] && r.lines[h] !== n[0][1]) { let c = l; for (; ;) { h = c === r.lines.length - 1 ? 0 : c + 1; let f = r.isInverseLine(c) ? r.lines[c].end : r.lines[c].start; if (a.push({ x: f.x, y: f.y }), r.lines[c] === s[0][0] || r.lines[c] === s[0][1]) { c = h; break } c = h } for (let f = t.length - 1; f; --f)a.push(t[f]), console.log("", t[f].x, t[f].y); for (let f = 0; f < t.length - 1; ++f)o.push(t[f]); for (; ;) { h = c === r.lines.length - 1 ? 0 : c + 1; let f = r.lines[c].start === r.lines[h].start || r.lines[c].start === r.lines[h].end ? r.lines[c].end : r.lines[c].start; if (o.push({ x: f.x, y: f.y }), r.lines[c] === n[0][0] || r.lines[c] === n[0][1]) break; c = h } console.log(JSON.stringify(a)), console.log(JSON.stringify(o)); break } } this.deletePolygon(r.id), this.addPolygon(a), this.addPolygon(o), console.log(this.polygons) } init() { let t = new kt(10, 10), i = new kt(100, 10), r = new kt(100, 100), n = new kt(10, 100), s = new Wi(t, i), a = new Wi(i, r), o = new Wi(r, n), l = new Wi(n, t), h = new wo([s, a, o, l]); this.addPoint(t.x, t.y), this.addPoint(i.x, i.y), this.addPoint(r.x, r.y), this.addPoint(n.x, n.y), this.addLine(s.start, s.end), this.addLine(a.start, a.end), this.addLine(o.start, o.end), this.addLine(l.start, l.end), this.addPolygon(h.lines.map(c => ({ x: c.start.x, y: c.start.y }))) } generateDrawing() { let t = []; for (let i in this.polygons) t.push(this.polygons[i]); for (let i in this.lines) t.push(this.lines[i]); for (let i in this.points) t.push(this.points[i]); return t } } let Ye = new Op; const Lp = { data() { return { configKonva: { width: window.innerWidth, height: window.innerHeight }, current: { focus: { x: 0, y: 0 }, points: [] }, list: [], layer: {}, status: 1, showFocus: !1 } }, methods: { stringToColour(e) { for (var t = 0, i = 0; i < e.length; i++)t = e.charCodeAt(i) + ((t << 5) - t); for (var r = "#", i = 0; i < 3; i++) { var n = t >> i * 8 & 255; r += ("00" + n.toString(16)).substr(-2) } return r }, makePoint(e) { const t = this.list.filter(i => i.id === e && i.type === "Point")[0]; return { x: t.x, y: t.y, radius: 1, fill: "black", id: e } }, makePolygon(e) { return { points: this.list.filter(r => r.id === e && r.type === "Polygon")[0].toPoints().map(r => [r.x, r.y]).reduce((r, n) => r.concat(n)), opacity: .3, fill: this.stringToColour(e), closed: !0 } }, closestFocus() { let e = this.layer.getRelativePointerPosition(), t = { x: -1, y: -1 }, i = Ye.closestLine(e.x, e.y); return i && i.distance(new kt(e.x, e.y)) < 4 && (t = i.projection(new kt(e.x, e.y))), i = Ye.closestPoint(e.x, e.y), i && i.distance(new kt(e.x, e.y)) < 5 && (t = { x: i.x, y: i.y }), t }, draw() { this.layer.destroyChildren(); const e = new Image; e.onload = () => { this.layer.batchDraw() }, e.src = "https://htbest.github.io/room_drawing_demo/30b1e56b-905d-4b24-b850-ee330bd1cbbb.jpg"; let t = new ve.Image({ x: 0, y: 0, width: window.innerWidth, height: window.innerHeight, image: e }); this.layer.add(t), this.list = Ye.generateDrawing(), this.list.forEach(i => { i.type === "Point" ? this.layer.add(new ve.Circle(this.makePoint(i.id))) : i.type === "Line" || i.type === "Polygon" && this.layer.add(new ve.Line(this.makePolygon(i.id))) }), this.current.points.length > 0 && this.layer.add(new ve.Line({ points: this.current.points.map(i => [i.x, i.y]).reduce((i, r) => i.concat(r)), fill: "blue", opacity: this.status === 1 ? .1 : 1, stroke: this.status === 1 ? "black" : "grey", strokeWidth: 1, closed: this.status === 1 })), this.current.points.forEach(i => { this.layer.add(new ve.Circle({ x: i.x, y: i.y, fill: this.status === 1 ? "orange" : "green", radius: 1 })) }), this.showFocus && this.layer.add(new ve.Circle({ x: this.current.focus.x, y: this.current.focus.y, fill: this.status === 1 ? "orange" : "green", radius: 1 })) } }, mounted() { Ye.init(); const e = this; let t = new ve.Stage({ container: "container", width: window.innerWidth, height: window.innerHeight, x: 20, y: 50 }), i = new ve.Layer({ clearBeforeDraw: !0 }); e.layer = i, t.add(i), t.on("mousedown", function (r) { if (r.evt.button === 0) { if (e.status === 1) i.getRelativePointerPosition(), e.current.points.length === 0 && e.current.points.push({ x: e.current.focus.x, y: e.current.focus.y }), e.current.points.push({ x: e.current.focus.x, y: e.current.focus.y }), e.draw(); else if (e.status === 2) { if (e.current.focus.x === -1 && e.current.focus.y === -1) return; if (i.getRelativePointerPosition(), e.current.points.length === 0) e.current.points.push({ x: e.current.focus.x, y: e.current.focus.y }); else { let n = e.closestFocus(); if (n.x !== -1 && n.y !== -1) { Ye.split(e.current.points), e.current.points = [], e.draw(); return } } e.current.points.push({ x: e.current.focus.x, y: e.current.focus.y }), e.draw() } } }), t.on("mousemove", function () { let r = i.getRelativePointerPosition(), n = e.closestFocus(); n.x === -1 && n.y === -1 && (n = e.status === 1 || e.current.points.length !== 0 ? { x: r.x, y: r.y } : { x: -1, y: -1 }), e.current.focus = { x: n.x, y: n.y }, e.current.points.length && (e.current.points[e.current.points.length - 1].x = n.x, e.current.points[e.current.points.length - 1].y = n.y), e.draw() }), window.addEventListener("keydown", function (r) { if (r.code === "Digit1") { if (e.current.points.length < 4 || e.status !== 1) { e.current.points = [], e.draw(), e.status = 1; return } e.current.points.pop(), Ye.addPolygon(e.current.points), e.current.points = [], e.draw() } else if (r.code === "Digit2") { if (e.current.points.length < 3 || e.status !== 2) { e.current.points = [], e.draw(), e.status = 2; return } e.current.points.pop(), Ye.split(e.current.points), e.current.points = [], e.draw() } else r.code === "Escape" && (e.current.points = [], e.draw()); r.code === "ShiftLeft" && (e.showFocus = !0, e.draw()) }), window.addEventListener("keyup", function (r) { r.code === "ShiftLeft" && (e.showFocus = !1, e.draw()) }), e.draw() } }; const Ip = (e, t) => { const i = e.__vccOpts || e; for (const [r, n] of t) i[r] = n; return i }, Dp = { id: "container" }; function Np(e, t, i, r, n, s) { return Sr(), Al("div", Dp) } const Fp = Ip(Lp, [["render", Np], ["__scopeId", "data-v-5007fce7"]]); var Gp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function Bp(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } function Uh(e) { if (e.__esModule) return e; var t = e.default; if (typeof t == "function") { var i = function r() { if (this instanceof r) { var n = [null]; n.push.apply(n, arguments); var s = Function.bind.apply(t, n); return new s } return t.apply(this, arguments) }; i.prototype = t.prototype } else i = {}; return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(e).forEach(function (r) { var n = Object.getOwnPropertyDescriptor(e, r); Object.defineProperty(i, r, n.get ? n : { enumerable: !0, get: function () { return e[r] } }) }), i } var Es = {}, Hp = { get exports() { return Es }, set exports(e) { Es = e } }; const Up = Uh(gd), Wp = Uh(Ep);/*!
 * vue-konva v3.0.1 - https://github.com/konvajs/vue-konva#readme
 * MIT Licensed
 */(function (e, t) { (function (r, n) { e.exports = n(Up, Wp) })(Gp, function (i, r) { return function (n) { var s = {}; function a(o) { if (s[o]) return s[o].exports; var l = s[o] = { i: o, l: !1, exports: {} }; return n[o].call(l.exports, l, l.exports, a), l.l = !0, l.exports } return a.m = n, a.c = s, a.d = function (o, l, h) { a.o(o, l) || Object.defineProperty(o, l, { enumerable: !0, get: h }) }, a.r = function (o) { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(o, "__esModule", { value: !0 }) }, a.t = function (o, l) { if (l & 1 && (o = a(o)), l & 8 || l & 4 && typeof o == "object" && o && o.__esModule) return o; var h = Object.create(null); if (a.r(h), Object.defineProperty(h, "default", { enumerable: !0, value: o }), l & 2 && typeof o != "string") for (var c in o) a.d(h, c, function (f) { return o[f] }.bind(null, c)); return h }, a.n = function (o) { var l = o && o.__esModule ? function () { return o.default } : function () { return o }; return a.d(l, "a", l), l }, a.o = function (o, l) { return Object.prototype.hasOwnProperty.call(o, l) }, a.p = "", a(a.s = 2) }([function (n, s) { n.exports = i }, function (n, s) { n.exports = r }, function (n, s, a) { n.exports = a(3) }, function (n, s, a) { a.r(s); var o = a(0), l = a(1), h = a.n(l); function c(k) { if (!h.a.autoDrawEnabled) { var P = k.getLayer() || k.getStage(); P && P.batchDraw() } } var f = { key: !0, style: !0, elm: !0, isRootInsert: !0 }, u = ".vue-konva-event"; function g(k, P, V, H) { P === void 0 && (P = {}), V === void 0 && (V = {}); var $ = k.__konvaNode, Z = {}, st = !1; for (var q in V) if (!f[q]) { var nt = q.slice(0, 2) === "on", ot = V[q] !== P[q]; if (nt && ot) { var ut = q.substr(2).toLowerCase(); ut.substr(0, 7) === "content" && (ut = "content" + ut.substr(7, 1).toUpperCase() + ut.substr(8)), $.off(ut + u, V[q]) } var Gt = !P.hasOwnProperty(q); Gt && $.setAttr(q, void 0) } for (var wt in P) if (!f[wt]) { var xt = wt.slice(0, 2) === "on", ee = V[wt] !== P[wt]; if (xt && ee) { var Rt = wt.substr(2).toLowerCase(); Rt.substr(0, 7) === "content" && (Rt = "content" + Rt.substr(7, 1).toUpperCase() + Rt.substr(8)), P[wt] && ($.off(Rt + u), $.on(Rt + u, P[wt])) } !xt && (P[wt] !== V[wt] || H && P[wt] !== $.getAttr(wt)) && (st = !0, Z[wt] = P[wt]) } st && ($.setAttrs(Z), c($)) } var d = "v"; function y(k) { function P(V) { return V.__konvaNode ? V : V.parent ? P(V.parent) : (console.error("vue-konva error: Can not find parent node"), {}) } return P(k.parent) } function C(k) { if (k != null && k.component) return k.component.__konvaNode || C(k.component.subTree) } function b(k) { var P = k.el, V = k.component, H = C(k); if (P != null && P.tagName && V && !H) { var $ = P && P.tagName.toLowerCase(); return console.error('vue-konva error: You are trying to render "' + $ + '" inside your component tree. Looks like it is not a Konva node. You can render only Konva components inside the Stage.'), null } return H } function p(k) { var P = []; return k.children && k.children.forEach(function (V) { !V.component && Array.isArray(V.children) && V.children.forEach(function (H) { !H.component && Array.isArray(H.children) ? P.push.apply(P, H.children) : P.push(H) }), V.component && P.push(V) }), P } function m(k, P) { var V = p(k), H = []; V.forEach(function (Z) { var st = b(Z); st && H.push(st) }); var $ = !1; H.forEach(function (Z, st) { Z.getZIndex() !== st && (Z.setZIndex(st), $ = !0) }), $ && c(P) } function w() { return w = Object.assign || function (k) { for (var P = 1; P < arguments.length; P++) { var V = arguments[P]; for (var H in V) Object.prototype.hasOwnProperty.call(V, H) && (k[H] = V[H]) } return k }, w.apply(this, arguments) } var A = { props: { config: { type: Object, default: function () { return {} } }, __useStrictMode: { type: Boolean } }, inheritAttrs: !1, setup: function (P, V) { var H = V.attrs, $ = V.slots, Z = V.expose; V.emits; var st = Object(o.getCurrentInstance)(), q = Object(o.reactive)({}), nt = Object(o.ref)(null), ot = new window.Konva.Stage({ width: P.config.width, height: P.config.height, container: document.createElement("div") }); st.__konvaNode = ot, wt(); function ut() { return st.__konvaNode } function Gt() { return st.__konvaNode } function wt() { var xt = q || {}, ee = w({}, H, P.config); g(st, ee, xt, P.__useStrictMode), Object.assign(q, ee) } return Object(o.onMounted)(function () { nt.value.innerHTML = "", ot.container(nt.value), wt() }), Object(o.onUpdated)(function () { wt(), m(st.subTree, ot) }), Object(o.onBeforeUnmount)(function () { ot.destroy() }), Object(o.watch)(function () { return P.config }, wt, { deep: !0 }), Z({ getStage: Gt, getNode: ut }), function () { var xt; return Object(o.h)("div", { ref: nt }, (xt = $.default) === null || xt === void 0 ? void 0 : xt.call($)) } } }; function T() { return T = Object.assign || function (k) { for (var P = 1; P < arguments.length; P++) { var V = arguments[P]; for (var H in V) Object.prototype.hasOwnProperty.call(V, H) && (k[H] = V[H]) } return k }, T.apply(this, arguments) } var R = ".vue-konva-event", E = { Group: !0, Layer: !0, FastLayer: !0, Label: !0 }, L = function (k) { return { props: { config: { type: Object, default: function () { return {} } }, __useStrictMode: { type: Boolean } }, setup: function (V, H) { var $ = H.attrs, Z = H.slots, st = H.expose, q = Object(o.getCurrentInstance)(), nt = Object(o.reactive)({}), ot = window.Konva[k]; if (!ot) { console.error("vue-konva error: Can not find node " + k); return } var ut = new ot; q.__konvaNode = ut, q.vnode.__konvaNode = ut, xt(); function Gt() { return q.__konvaNode } function wt() { return q.__konvaNode } function xt() { var Rt = {}; for (var oe in q.vnode.props) oe.slice(0, 2) === "on" && (Rt[oe] = q.vnode.props[oe]); var Ii = nt || {}, fi = T({}, $, V.config, Rt); g(q, fi, Ii, V.__useStrictMode), Object.assign(nt, fi) } Object(o.onMounted)(function () { var Rt = y(q).__konvaNode; Rt.add(ut), c(ut) }), Object(o.onUnmounted)(function () { c(ut), ut.destroy(), ut.off(R) }), Object(o.onUpdated)(function () { xt(), m(q.subTree, ut) }), Object(o.watch)(function () { return V.config }, xt, { deep: !0 }), st({ getStage: wt, getNode: Gt }); var ee = E[k]; return ee ? function () { var Rt; return Object(o.h)("template", {}, (Rt = Z.default) === null || Rt === void 0 ? void 0 : Rt.call(Z)) } : function () { return null } } } }; typeof window < "u" && !window.Konva && a(1); var O = ["Layer", "FastLayer", "Group", "Label", "Rect", "Circle", "Ellipse", "Wedge", "Line", "Sprite", "Image", "Text", "TextPath", "Star", "Ring", "Arc", "Tag", "Path", "RegularPolygon", "Arrow", "Shape", "Transformer"], I = [{ name: "Stage", component: A }].concat(O.map(function (k) { return { name: k, component: L(k) } })), D = { install: function (P, V) { var H = d; V && V.prefix && (H = V.prefix), I.forEach(function ($) { P.component("" + H + $.name, $.component) }) } }; s.default = D }]).default }) })(Hp); const jp = Bp(Es), Wh = oh(Fp); Wh.use(jp); Wh.mount("#app");
